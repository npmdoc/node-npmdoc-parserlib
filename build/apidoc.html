<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/CSSLint/parser-lib"

    >parserlib (v1.1.1)</a>
</h1>
<h4>CSS3 SAX-inspired parser</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.parserlib">module parserlib</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.PropertyValueIterator">
            function <span class="apidocSignatureSpan">parserlib.</span>PropertyValueIterator
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Combinator">
            function <span class="apidocSignatureSpan">parserlib.</span>css.Combinator
            <span class="apidocSignatureSpan">(text, line, col)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Matcher">
            function <span class="apidocSignatureSpan">parserlib.</span>css.Matcher
            <span class="apidocSignatureSpan">(matchFunc, toString)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.MediaFeature">
            function <span class="apidocSignatureSpan">parserlib.</span>css.MediaFeature
            <span class="apidocSignatureSpan">(name, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.MediaQuery">
            function <span class="apidocSignatureSpan">parserlib.</span>css.MediaQuery
            <span class="apidocSignatureSpan">(modifier, mediaType, features, line, col)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser">
            function <span class="apidocSignatureSpan">parserlib.</span>css.Parser
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.PropertyName">
            function <span class="apidocSignatureSpan">parserlib.</span>css.PropertyName
            <span class="apidocSignatureSpan">(text, hack, line, col)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.PropertyValue">
            function <span class="apidocSignatureSpan">parserlib.</span>css.PropertyValue
            <span class="apidocSignatureSpan">(parts, line, col)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.PropertyValuePart">
            function <span class="apidocSignatureSpan">parserlib.</span>css.PropertyValuePart
            <span class="apidocSignatureSpan">(text, line, col, optionalHint)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Selector">
            function <span class="apidocSignatureSpan">parserlib.</span>css.Selector
            <span class="apidocSignatureSpan">(parts, line, col)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.SelectorPart">
            function <span class="apidocSignatureSpan">parserlib.</span>css.SelectorPart
            <span class="apidocSignatureSpan">(elementName, modifiers, text, line, col)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.SelectorSubPart">
            function <span class="apidocSignatureSpan">parserlib.</span>css.SelectorSubPart
            <span class="apidocSignatureSpan">(text, type, line, col)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Specificity">
            function <span class="apidocSignatureSpan">parserlib.</span>css.Specificity
            <span class="apidocSignatureSpan">(a, b, c, d)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.TokenStream">
            function <span class="apidocSignatureSpan">parserlib.</span>css.TokenStream
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.util.EventTarget">
            function <span class="apidocSignatureSpan">parserlib.</span>util.EventTarget
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.util.StringReader">
            function <span class="apidocSignatureSpan">parserlib.</span>util.StringReader
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.util.SyntaxError">
            function <span class="apidocSignatureSpan">parserlib.</span>util.SyntaxError
            <span class="apidocSignatureSpan">(message, line, col)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.util.SyntaxUnit">
            function <span class="apidocSignatureSpan">parserlib.</span>util.SyntaxUnit
            <span class="apidocSignatureSpan">(text, line, col, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.util.TokenStreamBase">
            function <span class="apidocSignatureSpan">parserlib.</span>util.TokenStreamBase
            <span class="apidocSignatureSpan">(input, tokenData)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.</span>PropertyValueIterator.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.</span>Pseudos</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.</span>Validation</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.</span>ValidationTypes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.</span>css</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.</span>css.Combinator.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.</span>css.Matcher.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.</span>css.MediaFeature.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.</span>css.MediaQuery.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.</span>css.Parser.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.</span>css.PropertyName.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.</span>css.PropertyValue.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.</span>css.PropertyValuePart.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.</span>css.Selector.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.</span>css.SelectorPart.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.</span>css.SelectorSubPart.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.</span>css.Specificity.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.</span>css.TokenStream.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.</span>css.Tokens</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.</span>util</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.</span>util.EventTarget.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.</span>util.StringReader.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.</span>util.SyntaxError.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.</span>util.SyntaxUnit.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.</span>util.TokenStreamBase.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.parserlib.PropertyValueIterator">module parserlib.PropertyValueIterator</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.PropertyValueIterator.PropertyValueIterator">
            function <span class="apidocSignatureSpan">parserlib.</span>PropertyValueIterator
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.parserlib.PropertyValueIterator.prototype">module parserlib.PropertyValueIterator.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.PropertyValueIterator.prototype.count">
            function <span class="apidocSignatureSpan">parserlib.PropertyValueIterator.prototype.</span>count
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.PropertyValueIterator.prototype.drop">
            function <span class="apidocSignatureSpan">parserlib.PropertyValueIterator.prototype.</span>drop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.PropertyValueIterator.prototype.hasNext">
            function <span class="apidocSignatureSpan">parserlib.PropertyValueIterator.prototype.</span>hasNext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.PropertyValueIterator.prototype.isFirst">
            function <span class="apidocSignatureSpan">parserlib.PropertyValueIterator.prototype.</span>isFirst
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.PropertyValueIterator.prototype.mark">
            function <span class="apidocSignatureSpan">parserlib.PropertyValueIterator.prototype.</span>mark
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.PropertyValueIterator.prototype.next">
            function <span class="apidocSignatureSpan">parserlib.PropertyValueIterator.prototype.</span>next
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.PropertyValueIterator.prototype.peek">
            function <span class="apidocSignatureSpan">parserlib.PropertyValueIterator.prototype.</span>peek
            <span class="apidocSignatureSpan">(count)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.PropertyValueIterator.prototype.previous">
            function <span class="apidocSignatureSpan">parserlib.PropertyValueIterator.prototype.</span>previous
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.PropertyValueIterator.prototype.restore">
            function <span class="apidocSignatureSpan">parserlib.PropertyValueIterator.prototype.</span>restore
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.parserlib.Pseudos">module parserlib.Pseudos</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.Pseudos.isElement">
            function <span class="apidocSignatureSpan">parserlib.Pseudos.</span>isElement
            <span class="apidocSignatureSpan">(pseudo)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.Pseudos.</span>CLASS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.Pseudos.</span>ELEMENT</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.parserlib.Validation">module parserlib.Validation</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.Validation.singleProperty">
            function <span class="apidocSignatureSpan">parserlib.Validation.</span>singleProperty
            <span class="apidocSignatureSpan">(types, expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.Validation.validate">
            function <span class="apidocSignatureSpan">parserlib.Validation.</span>validate
            <span class="apidocSignatureSpan">(property, value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.parserlib.ValidationTypes">module parserlib.ValidationTypes</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.ValidationTypes.describe">
            function <span class="apidocSignatureSpan">parserlib.ValidationTypes.</span>describe
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.ValidationTypes.isAny">
            function <span class="apidocSignatureSpan">parserlib.ValidationTypes.</span>isAny
            <span class="apidocSignatureSpan">(expression, types)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.ValidationTypes.isAnyOfGroup">
            function <span class="apidocSignatureSpan">parserlib.ValidationTypes.</span>isAnyOfGroup
            <span class="apidocSignatureSpan">(expression, types)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.ValidationTypes.isComplex">
            function <span class="apidocSignatureSpan">parserlib.ValidationTypes.</span>isComplex
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.ValidationTypes.isLiteral">
            function <span class="apidocSignatureSpan">parserlib.ValidationTypes.</span>isLiteral
            <span class="apidocSignatureSpan">(part, literals)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.ValidationTypes.isSimple">
            function <span class="apidocSignatureSpan">parserlib.ValidationTypes.</span>isSimple
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.ValidationTypes.isType">
            function <span class="apidocSignatureSpan">parserlib.ValidationTypes.</span>isType
            <span class="apidocSignatureSpan">(expression, type)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.ValidationTypes.</span>complex</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.ValidationTypes.</span>simple</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.parserlib.css">module parserlib.css</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Combinator">
            function <span class="apidocSignatureSpan">parserlib.css.</span>Combinator
            <span class="apidocSignatureSpan">(text, line, col)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Matcher">
            function <span class="apidocSignatureSpan">parserlib.css.</span>Matcher
            <span class="apidocSignatureSpan">(matchFunc, toString)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.MediaFeature">
            function <span class="apidocSignatureSpan">parserlib.css.</span>MediaFeature
            <span class="apidocSignatureSpan">(name, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.MediaQuery">
            function <span class="apidocSignatureSpan">parserlib.css.</span>MediaQuery
            <span class="apidocSignatureSpan">(modifier, mediaType, features, line, col)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser">
            function <span class="apidocSignatureSpan">parserlib.css.</span>Parser
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.PropertyName">
            function <span class="apidocSignatureSpan">parserlib.css.</span>PropertyName
            <span class="apidocSignatureSpan">(text, hack, line, col)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.PropertyValue">
            function <span class="apidocSignatureSpan">parserlib.css.</span>PropertyValue
            <span class="apidocSignatureSpan">(parts, line, col)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.PropertyValuePart">
            function <span class="apidocSignatureSpan">parserlib.css.</span>PropertyValuePart
            <span class="apidocSignatureSpan">(text, line, col, optionalHint)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Selector">
            function <span class="apidocSignatureSpan">parserlib.css.</span>Selector
            <span class="apidocSignatureSpan">(parts, line, col)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.SelectorPart">
            function <span class="apidocSignatureSpan">parserlib.css.</span>SelectorPart
            <span class="apidocSignatureSpan">(elementName, modifiers, text, line, col)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.SelectorSubPart">
            function <span class="apidocSignatureSpan">parserlib.css.</span>SelectorSubPart
            <span class="apidocSignatureSpan">(text, type, line, col)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Specificity">
            function <span class="apidocSignatureSpan">parserlib.css.</span>Specificity
            <span class="apidocSignatureSpan">(a, b, c, d)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.TokenStream">
            function <span class="apidocSignatureSpan">parserlib.css.</span>TokenStream
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.ValidationError">
            function <span class="apidocSignatureSpan">parserlib.css.</span>ValidationError
            <span class="apidocSignatureSpan">(message, line, col)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.</span>Colors</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.</span>Tokens</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.parserlib.css.Combinator">module parserlib.css.Combinator</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Combinator.Combinator">
            function <span class="apidocSignatureSpan">parserlib.css.</span>Combinator
            <span class="apidocSignatureSpan">(text, line, col)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.parserlib.css.Combinator.prototype">module parserlib.css.Combinator.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Combinator.prototype.constructor">
            function <span class="apidocSignatureSpan">parserlib.css.Combinator.prototype.</span>constructor
            <span class="apidocSignatureSpan">(text, line, col)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.parserlib.css.Matcher">module parserlib.css.Matcher</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Matcher.Matcher">
            function <span class="apidocSignatureSpan">parserlib.css.</span>Matcher
            <span class="apidocSignatureSpan">(matchFunc, toString)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Matcher.alt">
            function <span class="apidocSignatureSpan">parserlib.css.Matcher.</span>alt
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Matcher.andand">
            function <span class="apidocSignatureSpan">parserlib.css.Matcher.</span>andand
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Matcher.cast">
            function <span class="apidocSignatureSpan">parserlib.css.Matcher.</span>cast
            <span class="apidocSignatureSpan">(m)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Matcher.fromType">
            function <span class="apidocSignatureSpan">parserlib.css.Matcher.</span>fromType
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Matcher.many">
            function <span class="apidocSignatureSpan">parserlib.css.Matcher.</span>many
            <span class="apidocSignatureSpan">(required)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Matcher.oror">
            function <span class="apidocSignatureSpan">parserlib.css.Matcher.</span>oror
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Matcher.parse">
            function <span class="apidocSignatureSpan">parserlib.css.Matcher.</span>parse
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Matcher.seq">
            function <span class="apidocSignatureSpan">parserlib.css.Matcher.</span>seq
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Matcher.</span>prec</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.parserlib.css.Matcher.prototype">module parserlib.css.Matcher.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Matcher.prototype.andand">
            function <span class="apidocSignatureSpan">parserlib.css.Matcher.prototype.</span>andand
            <span class="apidocSignatureSpan">(m)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Matcher.prototype.braces">
            function <span class="apidocSignatureSpan">parserlib.css.Matcher.prototype.</span>braces
            <span class="apidocSignatureSpan">(min, max, marker, optSep)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Matcher.prototype.constructor">
            function <span class="apidocSignatureSpan">parserlib.css.Matcher.prototype.</span>constructor
            <span class="apidocSignatureSpan">(matchFunc, toString)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Matcher.prototype.func">
            function <span class="apidocSignatureSpan">parserlib.css.Matcher.prototype.</span>func
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Matcher.prototype.hash">
            function <span class="apidocSignatureSpan">parserlib.css.Matcher.prototype.</span>hash
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Matcher.prototype.match">
            function <span class="apidocSignatureSpan">parserlib.css.Matcher.prototype.</span>match
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Matcher.prototype.or">
            function <span class="apidocSignatureSpan">parserlib.css.Matcher.prototype.</span>or
            <span class="apidocSignatureSpan">(m)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Matcher.prototype.oror">
            function <span class="apidocSignatureSpan">parserlib.css.Matcher.prototype.</span>oror
            <span class="apidocSignatureSpan">(m)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Matcher.prototype.plus">
            function <span class="apidocSignatureSpan">parserlib.css.Matcher.prototype.</span>plus
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Matcher.prototype.question">
            function <span class="apidocSignatureSpan">parserlib.css.Matcher.prototype.</span>question
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Matcher.prototype.star">
            function <span class="apidocSignatureSpan">parserlib.css.Matcher.prototype.</span>star
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Matcher.prototype.then">
            function <span class="apidocSignatureSpan">parserlib.css.Matcher.prototype.</span>then
            <span class="apidocSignatureSpan">(m)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Matcher.prototype.toString">
            function <span class="apidocSignatureSpan">parserlib.css.Matcher.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.parserlib.css.MediaFeature">module parserlib.css.MediaFeature</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.MediaFeature.MediaFeature">
            function <span class="apidocSignatureSpan">parserlib.css.</span>MediaFeature
            <span class="apidocSignatureSpan">(name, value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.parserlib.css.MediaFeature.prototype">module parserlib.css.MediaFeature.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.MediaFeature.prototype.constructor">
            function <span class="apidocSignatureSpan">parserlib.css.MediaFeature.prototype.</span>constructor
            <span class="apidocSignatureSpan">(name, value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.parserlib.css.MediaQuery">module parserlib.css.MediaQuery</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.MediaQuery.MediaQuery">
            function <span class="apidocSignatureSpan">parserlib.css.</span>MediaQuery
            <span class="apidocSignatureSpan">(modifier, mediaType, features, line, col)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.parserlib.css.MediaQuery.prototype">module parserlib.css.MediaQuery.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.MediaQuery.prototype.constructor">
            function <span class="apidocSignatureSpan">parserlib.css.MediaQuery.prototype.</span>constructor
            <span class="apidocSignatureSpan">(modifier, mediaType, features, line, col)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.parserlib.css.Parser">module parserlib.css.Parser</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.Parser">
            function <span class="apidocSignatureSpan">parserlib.css.</span>Parser
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Parser.</span>COMBINATOR_TYPE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Parser.</span>DEFAULT_TYPE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Parser.</span>MEDIA_FEATURE_TYPE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Parser.</span>MEDIA_QUERY_TYPE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Parser.</span>PROPERTY_NAME_TYPE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Parser.</span>PROPERTY_VALUE_PART_TYPE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Parser.</span>PROPERTY_VALUE_TYPE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Parser.</span>SELECTOR_PART_TYPE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Parser.</span>SELECTOR_SUB_PART_TYPE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Parser.</span>SELECTOR_TYPE</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.parserlib.css.Parser.prototype">module parserlib.css.Parser.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._attrib">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_attrib
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._charset">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_charset
            <span class="apidocSignatureSpan">(emit)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._class">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_class
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._combinator">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_combinator
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._declaration">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_declaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._document">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_document
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._document_function">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_document_function
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._element_name">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_element_name
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._expr">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_expr
            <span class="apidocSignatureSpan">(inFunction)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._expression">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_expression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._font_face">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_font_face
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._function">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_function
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._functional_pseudo">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_functional_pseudo
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._hexcolor">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_hexcolor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._ie_function">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_ie_function
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._import">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_import
            <span class="apidocSignatureSpan">(emit)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._key">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_key
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._key_list">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_key_list
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._keyframe_name">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_keyframe_name
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._keyframe_rule">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_keyframe_rule
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._keyframes">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_keyframes
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._margin">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_margin
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._margin_sym">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_margin_sym
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._media">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_media
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._media_expression">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_media_expression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._media_feature">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_media_feature
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._media_query">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_media_query
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._media_query_list">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_media_query_list
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._media_type">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_media_type
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._namespace">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_namespace
            <span class="apidocSignatureSpan">(emit)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._namespace_prefix">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_namespace_prefix
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._negation">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_negation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._negation_arg">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_negation_arg
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._operator">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_operator
            <span class="apidocSignatureSpan">(inFunction)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._page">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_page
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._prio">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_prio
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._property">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_property
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._pseudo">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_pseudo
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._pseudo_page">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_pseudo_page
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._readDeclarations">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_readDeclarations
            <span class="apidocSignatureSpan">(checkStart, readMargins)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._readWhitespace">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_readWhitespace
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._ruleset">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_ruleset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._selector">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_selector
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._selectors_group">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_selectors_group
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._simple_selector_sequence">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_simple_selector_sequence
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._skipCruft">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_skipCruft
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._stylesheet">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_stylesheet
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._supports">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_supports
            <span class="apidocSignatureSpan">(emit)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._supports_condition">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_supports_condition
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._supports_condition_in_parens">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_supports_condition_in_parens
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._supports_declaration_condition">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_supports_declaration_condition
            <span class="apidocSignatureSpan">(requireStartParen)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._term">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_term
            <span class="apidocSignatureSpan">(inFunction)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._type_selector">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_type_selector
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._unary_operator">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_unary_operator
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._unexpectedToken">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_unexpectedToken
            <span class="apidocSignatureSpan">(token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._universal">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_universal
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._validateProperty">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_validateProperty
            <span class="apidocSignatureSpan">(property, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._verifyEnd">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_verifyEnd
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype._viewport">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_viewport
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype.constructor">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>constructor
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype.parse">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>parse
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype.parseMediaQuery">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>parseMediaQuery
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype.parsePropertyValue">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>parsePropertyValue
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype.parseRule">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>parseRule
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype.parseSelector">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>parseSelector
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype.parseStyleAttribute">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>parseStyleAttribute
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Parser.prototype.parseStyleSheet">
            function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>parseStyleSheet
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>COMBINATOR_TYPE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>DEFAULT_TYPE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>MEDIA_FEATURE_TYPE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>MEDIA_QUERY_TYPE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>PROPERTY_NAME_TYPE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>PROPERTY_VALUE_PART_TYPE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>PROPERTY_VALUE_TYPE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>SELECTOR_PART_TYPE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>SELECTOR_SUB_PART_TYPE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>SELECTOR_TYPE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_listeners</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.parserlib.css.PropertyName">module parserlib.css.PropertyName</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.PropertyName.PropertyName">
            function <span class="apidocSignatureSpan">parserlib.css.</span>PropertyName
            <span class="apidocSignatureSpan">(text, hack, line, col)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.parserlib.css.PropertyName.prototype">module parserlib.css.PropertyName.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.PropertyName.prototype.constructor">
            function <span class="apidocSignatureSpan">parserlib.css.PropertyName.prototype.</span>constructor
            <span class="apidocSignatureSpan">(text, hack, line, col)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.PropertyName.prototype.toString">
            function <span class="apidocSignatureSpan">parserlib.css.PropertyName.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.parserlib.css.PropertyValue">module parserlib.css.PropertyValue</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.PropertyValue.PropertyValue">
            function <span class="apidocSignatureSpan">parserlib.css.</span>PropertyValue
            <span class="apidocSignatureSpan">(parts, line, col)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.parserlib.css.PropertyValue.prototype">module parserlib.css.PropertyValue.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.PropertyValue.prototype.constructor">
            function <span class="apidocSignatureSpan">parserlib.css.PropertyValue.prototype.</span>constructor
            <span class="apidocSignatureSpan">(parts, line, col)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.parserlib.css.PropertyValuePart">module parserlib.css.PropertyValuePart</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.PropertyValuePart.PropertyValuePart">
            function <span class="apidocSignatureSpan">parserlib.css.</span>PropertyValuePart
            <span class="apidocSignatureSpan">(text, line, col, optionalHint)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.PropertyValuePart.fromToken">
            function <span class="apidocSignatureSpan">parserlib.css.PropertyValuePart.</span>fromToken
            <span class="apidocSignatureSpan">(token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.PropertyValuePart.parseString">
            function <span class="apidocSignatureSpan">parserlib.css.PropertyValuePart.</span>parseString
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.PropertyValuePart.serializeString">
            function <span class="apidocSignatureSpan">parserlib.css.PropertyValuePart.</span>serializeString
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.parserlib.css.PropertyValuePart.prototype">module parserlib.css.PropertyValuePart.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.PropertyValuePart.prototype.constructor">
            function <span class="apidocSignatureSpan">parserlib.css.PropertyValuePart.prototype.</span>constructor
            <span class="apidocSignatureSpan">(text, line, col, optionalHint)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.parserlib.css.Selector">module parserlib.css.Selector</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Selector.Selector">
            function <span class="apidocSignatureSpan">parserlib.css.</span>Selector
            <span class="apidocSignatureSpan">(parts, line, col)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.parserlib.css.Selector.prototype">module parserlib.css.Selector.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Selector.prototype.constructor">
            function <span class="apidocSignatureSpan">parserlib.css.Selector.prototype.</span>constructor
            <span class="apidocSignatureSpan">(parts, line, col)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.parserlib.css.SelectorPart">module parserlib.css.SelectorPart</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.SelectorPart.SelectorPart">
            function <span class="apidocSignatureSpan">parserlib.css.</span>SelectorPart
            <span class="apidocSignatureSpan">(elementName, modifiers, text, line, col)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.parserlib.css.SelectorPart.prototype">module parserlib.css.SelectorPart.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.SelectorPart.prototype.constructor">
            function <span class="apidocSignatureSpan">parserlib.css.SelectorPart.prototype.</span>constructor
            <span class="apidocSignatureSpan">(elementName, modifiers, text, line, col)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.parserlib.css.SelectorSubPart">module parserlib.css.SelectorSubPart</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.SelectorSubPart.SelectorSubPart">
            function <span class="apidocSignatureSpan">parserlib.css.</span>SelectorSubPart
            <span class="apidocSignatureSpan">(text, type, line, col)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.parserlib.css.SelectorSubPart.prototype">module parserlib.css.SelectorSubPart.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.SelectorSubPart.prototype.constructor">
            function <span class="apidocSignatureSpan">parserlib.css.SelectorSubPart.prototype.</span>constructor
            <span class="apidocSignatureSpan">(text, type, line, col)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.parserlib.css.Specificity">module parserlib.css.Specificity</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Specificity.Specificity">
            function <span class="apidocSignatureSpan">parserlib.css.</span>Specificity
            <span class="apidocSignatureSpan">(a, b, c, d)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Specificity.calculate">
            function <span class="apidocSignatureSpan">parserlib.css.Specificity.</span>calculate
            <span class="apidocSignatureSpan">(selector)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.parserlib.css.Specificity.prototype">module parserlib.css.Specificity.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Specificity.prototype.compare">
            function <span class="apidocSignatureSpan">parserlib.css.Specificity.prototype.</span>compare
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Specificity.prototype.constructor">
            function <span class="apidocSignatureSpan">parserlib.css.Specificity.prototype.</span>constructor
            <span class="apidocSignatureSpan">(a, b, c, d)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Specificity.prototype.toString">
            function <span class="apidocSignatureSpan">parserlib.css.Specificity.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Specificity.prototype.valueOf">
            function <span class="apidocSignatureSpan">parserlib.css.Specificity.prototype.</span>valueOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.parserlib.css.TokenStream">module parserlib.css.TokenStream</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.TokenStream.TokenStream">
            function <span class="apidocSignatureSpan">parserlib.css.</span>TokenStream
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.parserlib.css.TokenStream.prototype">module parserlib.css.TokenStream.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.TokenStream.prototype._getToken">
            function <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>_getToken
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.TokenStream.prototype.atRuleToken">
            function <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>atRuleToken
            <span class="apidocSignatureSpan">(first, startLine, startCol)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.TokenStream.prototype.charToken">
            function <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>charToken
            <span class="apidocSignatureSpan">(c, startLine, startCol)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.TokenStream.prototype.commentToken">
            function <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>commentToken
            <span class="apidocSignatureSpan">(first, startLine, startCol)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.TokenStream.prototype.comparisonToken">
            function <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>comparisonToken
            <span class="apidocSignatureSpan">(c, startLine, startCol)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.TokenStream.prototype.createToken">
            function <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>createToken
            <span class="apidocSignatureSpan">(tt, value, startLine, startCol, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.TokenStream.prototype.hashToken">
            function <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>hashToken
            <span class="apidocSignatureSpan">(first, startLine, startCol)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.TokenStream.prototype.htmlCommentEndToken">
            function <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>htmlCommentEndToken
            <span class="apidocSignatureSpan">(first, startLine, startCol)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.TokenStream.prototype.htmlCommentStartToken">
            function <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>htmlCommentStartToken
            <span class="apidocSignatureSpan">(first, startLine, startCol)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.TokenStream.prototype.identOrFunctionToken">
            function <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>identOrFunctionToken
            <span class="apidocSignatureSpan">(first, startLine, startCol)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.TokenStream.prototype.importantToken">
            function <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>importantToken
            <span class="apidocSignatureSpan">(first, startLine, startCol)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.TokenStream.prototype.notToken">
            function <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>notToken
            <span class="apidocSignatureSpan">(first, startLine, startCol)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.TokenStream.prototype.numberToken">
            function <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>numberToken
            <span class="apidocSignatureSpan">(first, startLine, startCol)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.TokenStream.prototype.readComment">
            function <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>readComment
            <span class="apidocSignatureSpan">(first)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.TokenStream.prototype.readEscape">
            function <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>readEscape
            <span class="apidocSignatureSpan">(first, unescape)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.TokenStream.prototype.readName">
            function <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>readName
            <span class="apidocSignatureSpan">(first)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.TokenStream.prototype.readNumber">
            function <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>readNumber
            <span class="apidocSignatureSpan">(first)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.TokenStream.prototype.readString">
            function <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>readString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.TokenStream.prototype.readURI">
            function <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>readURI
            <span class="apidocSignatureSpan">(first)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.TokenStream.prototype.readUnicodeRangePart">
            function <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>readUnicodeRangePart
            <span class="apidocSignatureSpan">(allowQuestionMark)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.TokenStream.prototype.readUnquotedURL">
            function <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>readUnquotedURL
            <span class="apidocSignatureSpan">(first)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.TokenStream.prototype.readWhitespace">
            function <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>readWhitespace
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.TokenStream.prototype.stringToken">
            function <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>stringToken
            <span class="apidocSignatureSpan">(first, startLine, startCol)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.TokenStream.prototype.unicodeRangeToken">
            function <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>unicodeRangeToken
            <span class="apidocSignatureSpan">(first, startLine, startCol)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.TokenStream.prototype.whitespaceToken">
            function <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>whitespaceToken
            <span class="apidocSignatureSpan">(first, startLine, startCol)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>_ltIndex</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>_lt</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>_ltIndexCache</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>_reader</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>_token</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.parserlib.css.Tokens">module parserlib.css.Tokens</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Tokens.name">
            function <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>name
            <span class="apidocSignatureSpan">(tt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.css.Tokens.type">
            function <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>type
            <span class="apidocSignatureSpan">(c)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>ANGLE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>BOTTOMCENTER_SYM</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>BOTTOMLEFTCORNER_SYM</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>BOTTOMLEFT_SYM</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>BOTTOMRIGHTCORNER_SYM</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>BOTTOMRIGHT_SYM</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>CDC</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>CDO</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>CHAR</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>CHARSET_SYM</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>COLON</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>COMMA</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>COMMENT</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>DASHMATCH</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>DIMENSION</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>DOCUMENT_SYM</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>DOT</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>EOF</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>EQUALS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>FONT_FACE_SYM</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>FREQ</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>FUNCTION</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>GREATER</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>HASH</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>IDENT</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>IE_FUNCTION</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>IMPORTANT_SYM</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>IMPORT_SYM</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>INCLUDES</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>INVALID</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>KEYFRAMES_SYM</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>LBRACE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>LBRACKET</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>LEFTBOTTOM_SYM</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>LEFTMIDDLE_SYM</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>LEFTTOP_SYM</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>LENGTH</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>LPAREN</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>MEDIA_SYM</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>MINUS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>NAMESPACE_SYM</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>NOT</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>NUMBER</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>PAGE_SYM</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>PERCENTAGE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>PIPE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>PLUS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>PREFIXMATCH</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>RBRACE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>RBRACKET</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>RESOLUTION</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>RIGHTBOTTOM_SYM</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>RIGHTMIDDLE_SYM</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>RIGHTTOP_SYM</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>RPAREN</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>S</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>SEMICOLON</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>SLASH</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>STAR</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>STRING</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>SUBSTRINGMATCH</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>SUFFIXMATCH</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>SUPPORTS_SYM</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>TILDE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>TIME</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>TOPCENTER_SYM</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>TOPLEFTCORNER_SYM</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>TOPLEFT_SYM</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>TOPRIGHTCORNER_SYM</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>TOPRIGHT_SYM</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>UNICODE_RANGE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>UNKNOWN</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>UNKNOWN_SYM</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>URI</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>VIEWPORT_SYM</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>0</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>1</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>10</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>11</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>12</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>13</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>14</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>15</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>16</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>17</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>18</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>19</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>2</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>20</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>21</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>22</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>23</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>24</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>25</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>26</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>27</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>28</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>29</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>3</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>30</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>31</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>32</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>33</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>34</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>35</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>36</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>37</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>38</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>39</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>4</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>40</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>41</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>42</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>43</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>44</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>45</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>46</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>47</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>48</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>49</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>5</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>50</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>51</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>52</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>53</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>54</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>55</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>56</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>57</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>58</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>59</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>6</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>60</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>61</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>62</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>63</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>64</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>65</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>66</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>67</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>68</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>69</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>7</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>70</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>71</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>72</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>73</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>8</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>9</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.parserlib.util">module parserlib.util</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.util.EventTarget">
            function <span class="apidocSignatureSpan">parserlib.util.</span>EventTarget
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.util.StringReader">
            function <span class="apidocSignatureSpan">parserlib.util.</span>StringReader
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.util.SyntaxError">
            function <span class="apidocSignatureSpan">parserlib.util.</span>SyntaxError
            <span class="apidocSignatureSpan">(message, line, col)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.util.SyntaxUnit">
            function <span class="apidocSignatureSpan">parserlib.util.</span>SyntaxUnit
            <span class="apidocSignatureSpan">(text, line, col, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.util.TokenStreamBase">
            function <span class="apidocSignatureSpan">parserlib.util.</span>TokenStreamBase
            <span class="apidocSignatureSpan">(input, tokenData)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.parserlib.util.EventTarget">module parserlib.util.EventTarget</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.util.EventTarget.EventTarget">
            function <span class="apidocSignatureSpan">parserlib.util.</span>EventTarget
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.parserlib.util.EventTarget.prototype">module parserlib.util.EventTarget.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.util.EventTarget.prototype.addListener">
            function <span class="apidocSignatureSpan">parserlib.util.EventTarget.prototype.</span>addListener
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.util.EventTarget.prototype.constructor">
            function <span class="apidocSignatureSpan">parserlib.util.EventTarget.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.util.EventTarget.prototype.fire">
            function <span class="apidocSignatureSpan">parserlib.util.EventTarget.prototype.</span>fire
            <span class="apidocSignatureSpan">(event)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.util.EventTarget.prototype.removeListener">
            function <span class="apidocSignatureSpan">parserlib.util.EventTarget.prototype.</span>removeListener
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.parserlib.util.StringReader">module parserlib.util.StringReader</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.util.StringReader.StringReader">
            function <span class="apidocSignatureSpan">parserlib.util.</span>StringReader
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.parserlib.util.StringReader.prototype">module parserlib.util.StringReader.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.util.StringReader.prototype.constructor">
            function <span class="apidocSignatureSpan">parserlib.util.StringReader.prototype.</span>constructor
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.util.StringReader.prototype.eof">
            function <span class="apidocSignatureSpan">parserlib.util.StringReader.prototype.</span>eof
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.util.StringReader.prototype.getCol">
            function <span class="apidocSignatureSpan">parserlib.util.StringReader.prototype.</span>getCol
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.util.StringReader.prototype.getLine">
            function <span class="apidocSignatureSpan">parserlib.util.StringReader.prototype.</span>getLine
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.util.StringReader.prototype.mark">
            function <span class="apidocSignatureSpan">parserlib.util.StringReader.prototype.</span>mark
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.util.StringReader.prototype.peek">
            function <span class="apidocSignatureSpan">parserlib.util.StringReader.prototype.</span>peek
            <span class="apidocSignatureSpan">(count)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.util.StringReader.prototype.read">
            function <span class="apidocSignatureSpan">parserlib.util.StringReader.prototype.</span>read
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.util.StringReader.prototype.readCount">
            function <span class="apidocSignatureSpan">parserlib.util.StringReader.prototype.</span>readCount
            <span class="apidocSignatureSpan">(count)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.util.StringReader.prototype.readMatch">
            function <span class="apidocSignatureSpan">parserlib.util.StringReader.prototype.</span>readMatch
            <span class="apidocSignatureSpan">(matcher)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.util.StringReader.prototype.readTo">
            function <span class="apidocSignatureSpan">parserlib.util.StringReader.prototype.</span>readTo
            <span class="apidocSignatureSpan">(pattern)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.util.StringReader.prototype.readWhile">
            function <span class="apidocSignatureSpan">parserlib.util.StringReader.prototype.</span>readWhile
            <span class="apidocSignatureSpan">(filter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.util.StringReader.prototype.reset">
            function <span class="apidocSignatureSpan">parserlib.util.StringReader.prototype.</span>reset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.parserlib.util.SyntaxError">module parserlib.util.SyntaxError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.util.SyntaxError.SyntaxError">
            function <span class="apidocSignatureSpan">parserlib.util.</span>SyntaxError
            <span class="apidocSignatureSpan">(message, line, col)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.parserlib.util.SyntaxError.prototype">module parserlib.util.SyntaxError.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.util.SyntaxError.prototype.constructor">
            function <span class="apidocSignatureSpan">parserlib.util.SyntaxError.prototype.</span>constructor
            <span class="apidocSignatureSpan">(message, line, col)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.parserlib.util.SyntaxUnit">module parserlib.util.SyntaxUnit</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.util.SyntaxUnit.SyntaxUnit">
            function <span class="apidocSignatureSpan">parserlib.util.</span>SyntaxUnit
            <span class="apidocSignatureSpan">(text, line, col, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.util.SyntaxUnit.fromToken">
            function <span class="apidocSignatureSpan">parserlib.util.SyntaxUnit.</span>fromToken
            <span class="apidocSignatureSpan">(token)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.parserlib.util.SyntaxUnit.prototype">module parserlib.util.SyntaxUnit.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.util.SyntaxUnit.prototype.constructor">
            function <span class="apidocSignatureSpan">parserlib.util.SyntaxUnit.prototype.</span>constructor
            <span class="apidocSignatureSpan">(text, line, col, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.util.SyntaxUnit.prototype.toString">
            function <span class="apidocSignatureSpan">parserlib.util.SyntaxUnit.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.util.SyntaxUnit.prototype.valueOf">
            function <span class="apidocSignatureSpan">parserlib.util.SyntaxUnit.prototype.</span>valueOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.parserlib.util.TokenStreamBase">module parserlib.util.TokenStreamBase</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.util.TokenStreamBase.TokenStreamBase">
            function <span class="apidocSignatureSpan">parserlib.util.</span>TokenStreamBase
            <span class="apidocSignatureSpan">(input, tokenData)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.util.TokenStreamBase.createTokenData">
            function <span class="apidocSignatureSpan">parserlib.util.TokenStreamBase.</span>createTokenData
            <span class="apidocSignatureSpan">(tokens)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.parserlib.util.TokenStreamBase.prototype">module parserlib.util.TokenStreamBase.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.util.TokenStreamBase.prototype.LA">
            function <span class="apidocSignatureSpan">parserlib.util.TokenStreamBase.prototype.</span>LA
            <span class="apidocSignatureSpan">(index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.util.TokenStreamBase.prototype.LT">
            function <span class="apidocSignatureSpan">parserlib.util.TokenStreamBase.prototype.</span>LT
            <span class="apidocSignatureSpan">(index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.util.TokenStreamBase.prototype.advance">
            function <span class="apidocSignatureSpan">parserlib.util.TokenStreamBase.prototype.</span>advance
            <span class="apidocSignatureSpan">(tokenTypes, channel)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.util.TokenStreamBase.prototype.constructor">
            function <span class="apidocSignatureSpan">parserlib.util.TokenStreamBase.prototype.</span>constructor
            <span class="apidocSignatureSpan">(input, tokenData)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.util.TokenStreamBase.prototype.get">
            function <span class="apidocSignatureSpan">parserlib.util.TokenStreamBase.prototype.</span>get
            <span class="apidocSignatureSpan">(channel)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.util.TokenStreamBase.prototype.match">
            function <span class="apidocSignatureSpan">parserlib.util.TokenStreamBase.prototype.</span>match
            <span class="apidocSignatureSpan">(tokenTypes, channel)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.util.TokenStreamBase.prototype.mustMatch">
            function <span class="apidocSignatureSpan">parserlib.util.TokenStreamBase.prototype.</span>mustMatch
            <span class="apidocSignatureSpan">(tokenTypes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.util.TokenStreamBase.prototype.peek">
            function <span class="apidocSignatureSpan">parserlib.util.TokenStreamBase.prototype.</span>peek
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.util.TokenStreamBase.prototype.token">
            function <span class="apidocSignatureSpan">parserlib.util.TokenStreamBase.prototype.</span>token
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.util.TokenStreamBase.prototype.tokenName">
            function <span class="apidocSignatureSpan">parserlib.util.TokenStreamBase.prototype.</span>tokenName
            <span class="apidocSignatureSpan">(tokenType)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.util.TokenStreamBase.prototype.tokenType">
            function <span class="apidocSignatureSpan">parserlib.util.TokenStreamBase.prototype.</span>tokenType
            <span class="apidocSignatureSpan">(tokenName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parserlib.util.TokenStreamBase.prototype.unget">
            function <span class="apidocSignatureSpan">parserlib.util.TokenStreamBase.prototype.</span>unget
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.parserlib" id="apidoc.module.parserlib">module parserlib</a></h1>


    <h2>
        <a href="#apidoc.element.parserlib.PropertyValueIterator" id="apidoc.element.parserlib.PropertyValueIterator">
        function <span class="apidocSignatureSpan">parserlib.</span>PropertyValueIterator
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PropertyValueIterator(value) {

    /**
     * Iterator value
     * @type int
     * @property _i
     * @private
     */
    this._i = 0;

    /**
     * The parts that make up the value.
     * @type Array
     * @property _parts
     * @private
     */
    this._parts = value.parts;

    /**
     * Keeps track of bookmarks along the way.
     * @type Array
     * @property _marks
     * @private
     */
    this._marks = [];

    /**
     * Holds the original property value.
     * @type parserlib.css.PropertyValue
     * @property value
     */
    this.value = value;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Combinator" id="apidoc.element.parserlib.css.Combinator">
        function <span class="apidocSignatureSpan">parserlib.</span>css.Combinator
        <span class="apidocSignatureSpan">(text, line, col)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Combinator(text, line, col) {

    SyntaxUnit.call(this, text, line, col, Parser.COMBINATOR_TYPE);

    /**
     * The type of modifier.
     * @type String
     * @property type
     */
    this.type = &#x22;unknown&#x22;;

    //pretty simple
    if (/^\s+$/.test(text)) {
        this.type = &#x22;descendant&#x22;;
    } else if (text === &#x22;&#x3e;&#x22;) {
        this.type = &#x22;child&#x22;;
    } else if (text === &#x22;+&#x22;) {
        this.type = &#x22;adjacent-sibling&#x22;;
    } else if (text === &#x22;~&#x22;) {
        this.type = &#x22;sibling&#x22;;
    }

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Matcher" id="apidoc.element.parserlib.css.Matcher">
        function <span class="apidocSignatureSpan">parserlib.</span>css.Matcher
        <span class="apidocSignatureSpan">(matchFunc, toString)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Matcher(matchFunc, toString) {
    this.match = function(expression) {
        // Save/restore marks to ensure that failed matches always restore
        // the original location in the expression.
        var result;
        expression.mark();
        result = matchFunc(expression);
        if (result) {
            expression.drop();
        } else {
            expression.restore();
        }
        return result;
    };
    this.toString = typeof toString === &#x22;function&#x22; ? toString : function() {
        return toString;
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.MediaFeature" id="apidoc.element.parserlib.css.MediaFeature">
        function <span class="apidocSignatureSpan">parserlib.</span>css.MediaFeature
        <span class="apidocSignatureSpan">(name, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MediaFeature(name, value) {

    SyntaxUnit.call(this, &#x22;(&#x22; + name + (value !== null ? &#x22;:&#x22; + value : &#x22;&#x22;) + &#x22;)&#x22;, name.startLine, name.startCol, Parser.MEDIA_FEATURE_TYPE
);

    /**
     * The name of the media feature
     * @type String
     * @property name
     */
    this.name = name;

    /**
     * The value for the feature or null if there is none.
     * @type SyntaxUnit
     * @property value
     */
    this.value = value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.MediaQuery" id="apidoc.element.parserlib.css.MediaQuery">
        function <span class="apidocSignatureSpan">parserlib.</span>css.MediaQuery
        <span class="apidocSignatureSpan">(modifier, mediaType, features, line, col)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MediaQuery(modifier, mediaType, features, line, col) {

    SyntaxUnit.call(this, (modifier ? modifier + &#x22; &#x22;: &#x22;&#x22;) + (mediaType ? mediaType : &#x22;&#x22;) + (mediaType &#x26;&#x26; features.length &#x3e; 0 ? &#x22;
and &#x22; : &#x22;&#x22;) + features.join(&#x22; and &#x22;), line, col, Parser.MEDIA_QUERY_TYPE);

    /**
     * The media modifier (&#x22;not&#x22; or &#x22;only&#x22;)
     * @type String
     * @property modifier
     */
    this.modifier = modifier;

    /**
     * The mediaType (i.e., &#x22;print&#x22;)
     * @type String
     * @property mediaType
     */
    this.mediaType = mediaType;

    /**
     * The parts that make up the selector.
     * @type Array
     * @property features
     */
    this.features = features;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser" id="apidoc.element.parserlib.css.Parser">
        function <span class="apidocSignatureSpan">parserlib.</span>css.Parser
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parser(options) {

    //inherit event functionality
    EventTarget.call(this);


    this.options = options || {};

    this._tokenStream = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

You can use the CSS parser in a `Node.js` script via the standard
`npm` package manager as the `parserlib` package (`npm install parserlib`):

```js
var parserlib = require(&#x22;parserlib&#x22;);

var parser = new parserlib.<span class="apidocCodeKeywordSpan">css.Parser</span>();
```

Alternatively, you can copy a single file version of the parser from
`dist/node-parserlib.js` to your own project, and use it as follows:

```js
var parserlib = require(&#x22;./node-parserlib&#x22;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.PropertyName" id="apidoc.element.parserlib.css.PropertyName">
        function <span class="apidocSignatureSpan">parserlib.</span>css.PropertyName
        <span class="apidocSignatureSpan">(text, hack, line, col)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PropertyName(text, hack, line, col) {

    SyntaxUnit.call(this, text, line, col, Parser.PROPERTY_NAME_TYPE);

    /**
     * The type of IE hack applied (&#x22;*&#x22;, &#x22;_&#x22;, or null).
     * @type String
     * @property hack
     */
    this.hack = hack;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.PropertyValue" id="apidoc.element.parserlib.css.PropertyValue">
        function <span class="apidocSignatureSpan">parserlib.</span>css.PropertyValue
        <span class="apidocSignatureSpan">(parts, line, col)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PropertyValue(parts, line, col) {

    SyntaxUnit.call(this, parts.join(&#x22; &#x22;), line, col, Parser.PROPERTY_VALUE_TYPE);

    /**
     * The parts that make up the selector.
     * @type Array
     * @property parts
     */
    this.parts = parts;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.PropertyValuePart" id="apidoc.element.parserlib.css.PropertyValuePart">
        function <span class="apidocSignatureSpan">parserlib.</span>css.PropertyValuePart
        <span class="apidocSignatureSpan">(text, line, col, optionalHint)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PropertyValuePart(text, line, col, optionalHint) {
    var hint = optionalHint || {};

    SyntaxUnit.call(this, text, line, col, Parser.PROPERTY_VALUE_PART_TYPE);

    /**
     * Indicates the type of value unit.
     * @type String
     * @property type
     */
    this.type = &#x22;unknown&#x22;;

    //figure out what type of data it is

    var temp;

    //it is a measurement?
    if (/^([+\-]?[\d\.]+)([a-z]+)$/i.test(text)) {  //dimension
        this.type = &#x22;dimension&#x22;;
        this.value = +RegExp.$1;
        this.units = RegExp.$2;

        //try to narrow down
        switch (this.units.toLowerCase()) {

            case &#x22;em&#x22;:
            case &#x22;rem&#x22;:
            case &#x22;ex&#x22;:
            case &#x22;px&#x22;:
            case &#x22;cm&#x22;:
            case &#x22;mm&#x22;:
            case &#x22;in&#x22;:
            case &#x22;pt&#x22;:
            case &#x22;pc&#x22;:
            case &#x22;ch&#x22;:
            case &#x22;vh&#x22;:
            case &#x22;vw&#x22;:
            case &#x22;vmax&#x22;:
            case &#x22;vmin&#x22;:
                this.type = &#x22;length&#x22;;
                break;

            case &#x22;fr&#x22;:
                this.type = &#x22;grid&#x22;;
                break;

            case &#x22;deg&#x22;:
            case &#x22;rad&#x22;:
            case &#x22;grad&#x22;:
            case &#x22;turn&#x22;:
                this.type = &#x22;angle&#x22;;
                break;

            case &#x22;ms&#x22;:
            case &#x22;s&#x22;:
                this.type = &#x22;time&#x22;;
                break;

            case &#x22;hz&#x22;:
            case &#x22;khz&#x22;:
                this.type = &#x22;frequency&#x22;;
                break;

            case &#x22;dpi&#x22;:
            case &#x22;dpcm&#x22;:
                this.type = &#x22;resolution&#x22;;
                break;

            //default

        }

    } else if (/^([+\-]?[\d\.]+)%$/i.test(text)) {  //percentage
        this.type = &#x22;percentage&#x22;;
        this.value = +RegExp.$1;
    } else if (/^([+\-]?\d+)$/i.test(text)) {  //integer
        this.type = &#x22;integer&#x22;;
        this.value = +RegExp.$1;
    } else if (/^([+\-]?[\d\.]+)$/i.test(text)) {  //number
        this.type = &#x22;number&#x22;;
        this.value = +RegExp.$1;

    } else if (/^#([a-f0-9]{3,6})/i.test(text)) {  //hexcolor
        this.type = &#x22;color&#x22;;
        temp = RegExp.$1;
        if (temp.length === 3) {
            this.red    = parseInt(temp.charAt(0)+temp.charAt(0), 16);
            this.green  = parseInt(temp.charAt(1)+temp.charAt(1), 16);
            this.blue   = parseInt(temp.charAt(2)+temp.charAt(2), 16);
        } else {
            this.red    = parseInt(temp.substring(0, 2), 16);
            this.green  = parseInt(temp.substring(2, 4), 16);
            this.blue   = parseInt(temp.substring(4, 6), 16);
        }
    } else if (/^rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/i.test(text)) { //rgb() color with absolute numbers
        this.type   = &#x22;color&#x22;;
        this.red    = +RegExp.$1;
        this.green  = +RegExp.$2;
        this.blue   = +RegExp.$3;
    } else if (/^rgb\(\s*(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*\)/i.test(text)) { //rgb() color with percentages
        this.type   = &#x22;color&#x22;;
        this.red    = +RegExp.$1 * 255 / 100;
        this.green  = +RegExp.$2 * 255 / 100;
        this.blue   = +RegExp.$3 * 255 / 100;
    } else if (/^rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d\.]+)\s*\)/i.test(text)) { //rgba() color with absolute numbers
        this.type   = &#x22;color&#x22;;
        this.red    = +RegExp.$1;
        this.green  = +RegExp.$2;
        this.blue   = +RegExp.$3;
        this.alpha  = +RegExp.$4;
    } else if (/^rgba\(\s*(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*,\s*([\d\.]+)\s*\)/i.test(text)) { //rgba() color with percentages
        this.type   = &#x22;color&#x22;;
        this.red    = +RegExp.$1 * 255 / 100;
        this.green  = +RegExp.$2 * 255 / 100;
        this.blue   = +RegExp.$3 * 255 / 100;
        this.alpha  = +RegExp.$4;
    } else if (/^hsl\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*\)/i.test(text)) { //hsl()
        this.type   = &#x22;color&#x22;;
        this.hue    = +RegExp.$1;
        this.saturation = +RegExp.$2 / 100;
        this.lightness  = +RegExp.$3 / 100;
    } else if ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Selector" id="apidoc.element.parserlib.css.Selector">
        function <span class="apidocSignatureSpan">parserlib.</span>css.Selector
        <span class="apidocSignatureSpan">(parts, line, col)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Selector(parts, line, col) {

    SyntaxUnit.call(this, parts.join(&#x22; &#x22;), line, col, Parser.SELECTOR_TYPE);

    /**
     * The parts that make up the selector.
     * @type Array
     * @property parts
     */
    this.parts = parts;

    /**
     * The specificity of the selector.
     * @type parserlib.css.Specificity
     * @property specificity
     */
    this.specificity = Specificity.calculate(this);

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.SelectorPart" id="apidoc.element.parserlib.css.SelectorPart">
        function <span class="apidocSignatureSpan">parserlib.</span>css.SelectorPart
        <span class="apidocSignatureSpan">(elementName, modifiers, text, line, col)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SelectorPart(elementName, modifiers, text, line, col) {

    SyntaxUnit.call(this, text, line, col, Parser.SELECTOR_PART_TYPE);

    /**
     * The tag name of the element to which this part
     * of the selector affects.
     * @type String
     * @property elementName
     */
    this.elementName = elementName;

    /**
     * The parts that come after the element name, such as class names, IDs,
     * pseudo classes/elements, etc.
     * @type Array
     * @property modifiers
     */
    this.modifiers = modifiers;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.SelectorSubPart" id="apidoc.element.parserlib.css.SelectorSubPart">
        function <span class="apidocSignatureSpan">parserlib.</span>css.SelectorSubPart
        <span class="apidocSignatureSpan">(text, type, line, col)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SelectorSubPart(text, type, line, col) {

    SyntaxUnit.call(this, text, line, col, Parser.SELECTOR_SUB_PART_TYPE);

    /**
     * The type of modifier.
     * @type String
     * @property type
     */
    this.type = type;

    /**
     * Some subparts have arguments, this represents them.
     * @type Array
     * @property args
     */
    this.args = [];

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Specificity" id="apidoc.element.parserlib.css.Specificity">
        function <span class="apidocSignatureSpan">parserlib.</span>css.Specificity
        <span class="apidocSignatureSpan">(a, b, c, d)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Specificity(a, b, c, d) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.TokenStream" id="apidoc.element.parserlib.css.TokenStream">
        function <span class="apidocSignatureSpan">parserlib.</span>css.TokenStream
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TokenStream(input) {
    TokenStreamBase.call(this, input, Tokens);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.util.EventTarget" id="apidoc.element.parserlib.util.EventTarget">
        function <span class="apidocSignatureSpan">parserlib.</span>util.EventTarget
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventTarget() {

    /**
     * The array of listeners for various events.
     * @type Object
     * @property _listeners
     * @private
     */
    this._listeners = Object.create(null);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.util.StringReader" id="apidoc.element.parserlib.util.StringReader">
        function <span class="apidocSignatureSpan">parserlib.</span>util.StringReader
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function StringReader(text) {

    /**
     * The input text with line endings normalized.
     * @property _input
     * @type String
     * @private
     */
    this._input = text.replace(/(\r\n?|\n)/g, &#x22;\n&#x22;);


    /**
     * The row for the character to be read next.
     * @property _line
     * @type int
     * @private
     */
    this._line = 1;


    /**
     * The column for the character to be read next.
     * @property _col
     * @type int
     * @private
     */
    this._col = 1;

    /**
     * The index of the character in the input to be read next.
     * @property _cursor
     * @type int
     * @private
     */
    this._cursor = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.util.SyntaxError" id="apidoc.element.parserlib.util.SyntaxError">
        function <span class="apidocSignatureSpan">parserlib.</span>util.SyntaxError
        <span class="apidocSignatureSpan">(message, line, col)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntaxError(message, line, col) {
    Error.call(this);
    this.name = this.constructor.name;

    /**
     * The column at which the error occurred.
     * @type int
     * @property col
     */
    this.col = col;

    /**
     * The line at which the error occurred.
     * @type int
     * @property line
     */
    this.line = line;

    /**
     * The text representation of the unit.
     * @type String
     * @property text
     */
    this.message = message;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.util.SyntaxUnit" id="apidoc.element.parserlib.util.SyntaxUnit">
        function <span class="apidocSignatureSpan">parserlib.</span>util.SyntaxUnit
        <span class="apidocSignatureSpan">(text, line, col, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntaxUnit(text, line, col, type) {


    /**
     * The column of text on which the unit resides.
     * @type int
     * @property col
     */
    this.col = col;

    /**
     * The line of text on which the unit resides.
     * @type int
     * @property line
     */
    this.line = line;

    /**
     * The text representation of the unit.
     * @type String
     * @property text
     */
    this.text = text;

    /**
     * The type of syntax unit.
     * @type int
     * @property type
     */
    this.type = type;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.util.TokenStreamBase" id="apidoc.element.parserlib.util.TokenStreamBase">
        function <span class="apidocSignatureSpan">parserlib.</span>util.TokenStreamBase
        <span class="apidocSignatureSpan">(input, tokenData)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TokenStreamBase(input, tokenData) {

    /**
     * The string reader for easy access to the text.
     * @type StringReader
     * @property _reader
     * @private
     */
    this._reader = new StringReader(input ? input.toString() : &#x22;&#x22;);

    /**
     * Token object for the last consumed token.
     * @type Token
     * @property _token
     * @private
     */
    this._token = null;

    /**
     * The array of token information.
     * @type Array
     * @property _tokenData
     * @private
     */
    this._tokenData = tokenData;

    /**
     * Lookahead token buffer.
     * @type Array
     * @property _lt
     * @private
     */
    this._lt = [];

    /**
     * Lookahead token buffer index.
     * @type int
     * @property _ltIndex
     * @private
     */
    this._ltIndex = 0;

    this._ltIndexCache = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




















































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.parserlib.PropertyValueIterator" id="apidoc.module.parserlib.PropertyValueIterator">module parserlib.PropertyValueIterator</a></h1>


    <h2>
        <a href="#apidoc.element.parserlib.PropertyValueIterator.PropertyValueIterator" id="apidoc.element.parserlib.PropertyValueIterator.PropertyValueIterator">
        function <span class="apidocSignatureSpan">parserlib.</span>PropertyValueIterator
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PropertyValueIterator(value) {

    /**
     * Iterator value
     * @type int
     * @property _i
     * @private
     */
    this._i = 0;

    /**
     * The parts that make up the value.
     * @type Array
     * @property _parts
     * @private
     */
    this._parts = value.parts;

    /**
     * Keeps track of bookmarks along the way.
     * @type Array
     * @property _marks
     * @private
     */
    this._marks = [];

    /**
     * Holds the original property value.
     * @type parserlib.css.PropertyValue
     * @property value
     */
    this.value = value;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.parserlib.PropertyValueIterator.prototype" id="apidoc.module.parserlib.PropertyValueIterator.prototype">module parserlib.PropertyValueIterator.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.parserlib.PropertyValueIterator.prototype.count" id="apidoc.element.parserlib.PropertyValueIterator.prototype.count">
        function <span class="apidocSignatureSpan">parserlib.PropertyValueIterator.prototype.</span>count
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">count = function () {
    return this._parts.length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.PropertyValueIterator.prototype.drop" id="apidoc.element.parserlib.PropertyValueIterator.prototype.drop">
        function <span class="apidocSignatureSpan">parserlib.PropertyValueIterator.prototype.</span>drop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">drop = function () {
    this._marks.pop();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.match = function(expression) {
    // Save/restore marks to ensure that failed matches always restore
    // the original location in the expression.
    var result;
    expression.mark();
    result = matchFunc(expression);
    if (result) {
        expression.<span class="apidocCodeKeywordSpan">drop</span>();
    } else {
        expression.restore();
    }
    return result;
};
this.toString = typeof toString === &#x22;function&#x22; ? toString : function() {
    return toString;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.PropertyValueIterator.prototype.hasNext" id="apidoc.element.parserlib.PropertyValueIterator.prototype.hasNext">
        function <span class="apidocSignatureSpan">parserlib.PropertyValueIterator.prototype.</span>hasNext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasNext = function () {
    return this._i &#x3c; this._parts.length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* Create a matcher for a single type.
*/
Matcher.fromType = function(type) {
   // Late require of ValidationTypes to break a dependency cycle.
   var ValidationTypes = require(&#x22;./ValidationTypes&#x22;);
   return new Matcher(function(expression) {
       return expression.<span class="apidocCodeKeywordSpan">hasNext</span>() &#x26;&#x26; ValidationTypes.isType(expression, type
);
   }, type);
};

/**
* Create a matcher for one or more juxtaposed words, which all must
* occur, in the given order.
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.PropertyValueIterator.prototype.isFirst" id="apidoc.element.parserlib.PropertyValueIterator.prototype.isFirst">
        function <span class="apidocSignatureSpan">parserlib.PropertyValueIterator.prototype.</span>isFirst
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isFirst = function () {
    return this._i === 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var result      = false,
    value       = expression.value,
    part;

result = Matcher.parse(types).match(expression);

if (!result) {
    if (expression.hasNext() &#x26;&#x26; !expression.<span class="apidocCodeKeywordSpan">isFirst</span>()) {
        part = expression.peek();
        throw new ValidationError(&#x22;Expected end of value but found &#x27;&#x22; + part + &#x22;&#x27;.&#x22;, part.line, part
.col);
    } else {
        throw new ValidationError(&#x22;Expected (&#x22; + ValidationTypes.describe(types) + &#x22;) but found &#x27;&#x22; + value
 + &#x22;&#x27;.&#x22;, value.line, value.col);
    }
} else if (expression.hasNext()) {
    part = expression.next();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.PropertyValueIterator.prototype.mark" id="apidoc.element.parserlib.PropertyValueIterator.prototype.mark">
        function <span class="apidocSignatureSpan">parserlib.PropertyValueIterator.prototype.</span>mark
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mark = function () {
    this._marks.push(this._i);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * https://developer.mozilla.org/en-US/docs/Web/CSS/Value_definition_syntax#Component_value_combinators
 */
function Matcher(matchFunc, toString) {
this.match = function(expression) {
    // Save/restore marks to ensure that failed matches always restore
    // the original location in the expression.
    var result;
    expression.<span class="apidocCodeKeywordSpan">mark</span>();
    result = matchFunc(expression);
    if (result) {
        expression.drop();
    } else {
        expression.restore();
    }
    return result;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.PropertyValueIterator.prototype.next" id="apidoc.element.parserlib.PropertyValueIterator.prototype.next">
        function <span class="apidocSignatureSpan">parserlib.PropertyValueIterator.prototype.</span>next
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">next = function () {
    return this.hasNext() ? this._parts[this._i++] : null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
        } else if (typeof spec !== &#x22;number&#x22;) {

// All properties accept some CSS-wide values.
// https://drafts.csswg.org/css-values-3/#common-keywords
if (ValidationTypes.isAny(expression, &#x22;inherit | initial | unset&#x22;)) {
    if (expression.hasNext()) {
        part = expression.<span class="apidocCodeKeywordSpan">next</span>();
        throw new ValidationError(&#x22;Expected end of value but found &#x27;&#x22; + part + &#x22;&#x27;.&#x22;, part.line, part
.col);
    }
    return;
}

// Property-specific validation.
this.singleProperty(spec, expression);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.PropertyValueIterator.prototype.peek" id="apidoc.element.parserlib.PropertyValueIterator.prototype.peek">
        function <span class="apidocSignatureSpan">parserlib.PropertyValueIterator.prototype.</span>peek
        <span class="apidocSignatureSpan">(count)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">peek = function (count) {
    return this.hasNext() ? this._parts[this._i + (count || 0)] : null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

//try to read character set
this._charset();

this._skipCruft();

//try to read imports - may be more than one
while (tokenStream.<span class="apidocCodeKeywordSpan">peek</span>() === Tokens.IMPORT_SYM) {
    this._import();
    this._skipCruft();
}

//try to read namespaces - may be more than one
while (tokenStream.peek() === Tokens.NAMESPACE_SYM) {
    this._namespace();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.PropertyValueIterator.prototype.previous" id="apidoc.element.parserlib.PropertyValueIterator.prototype.previous">
        function <span class="apidocSignatureSpan">parserlib.PropertyValueIterator.prototype.</span>previous
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">previous = function () {
    return this._i &#x3e; 0 ? this._parts[--this._i] : null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.PropertyValueIterator.prototype.restore" id="apidoc.element.parserlib.PropertyValueIterator.prototype.restore">
        function <span class="apidocSignatureSpan">parserlib.PropertyValueIterator.prototype.</span>restore
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">restore = function () {
    if (this._marks.length) {
        this._i = this._marks.pop();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        // the original location in the expression.
        var result;
        expression.mark();
        result = matchFunc(expression);
        if (result) {
            expression.drop();
        } else {
            expression.<span class="apidocCodeKeywordSpan">restore</span>();
        }
        return result;
    };
    this.toString = typeof toString === &#x22;function&#x22; ? toString : function() {
        return toString;
    };
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.parserlib.Pseudos" id="apidoc.module.parserlib.Pseudos">module parserlib.Pseudos</a></h1>


    <h2>
        <a href="#apidoc.element.parserlib.Pseudos.isElement" id="apidoc.element.parserlib.Pseudos.isElement">
        function <span class="apidocSignatureSpan">parserlib.Pseudos.</span>isElement
        <span class="apidocSignatureSpan">(pseudo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isElement = function (pseudo) {
    return pseudo.indexOf(&#x22;::&#x22;) === 0 || Pseudos[pseudo.toLowerCase()] === Pseudos.ELEMENT;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    break;

case &#x22;id&#x22;:
    b++;
    break;

case &#x22;pseudo&#x22;:
    if (Pseudos.<span class="apidocCodeKeywordSpan">isElement</span>(modifier.text)) {
        d++;
    } else {
        c++;
    }
    break;

case &#x22;not&#x22;:
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.parserlib.Validation" id="apidoc.module.parserlib.Validation">module parserlib.Validation</a></h1>


    <h2>
        <a href="#apidoc.element.parserlib.Validation.singleProperty" id="apidoc.element.parserlib.Validation.singleProperty">
        function <span class="apidocSignatureSpan">parserlib.Validation.</span>singleProperty
        <span class="apidocSignatureSpan">(types, expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">singleProperty = function (types, expression) {

    var result      = false,
        value       = expression.value,
        part;

    result = Matcher.parse(types).match(expression);

    if (!result) {
        if (expression.hasNext() &#x26;&#x26; !expression.isFirst()) {
            part = expression.peek();
            throw new ValidationError(&#x22;Expected end of value but found &#x27;&#x22; + part + &#x22;&#x27;.&#x22;, part.line, part.col);
        } else {
            throw new ValidationError(&#x22;Expected (&#x22; + ValidationTypes.describe(types) + &#x22;) but found &#x27;&#x22; + value + &#x22;&#x27;.&#x22;, value.line
, value.col);
        }
    } else if (expression.hasNext()) {
        part = expression.next();
        throw new ValidationError(&#x22;Expected end of value but found &#x27;&#x22; + part + &#x22;&#x27;.&#x22;, part.line, part.col);
    }

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                part = expression.next();
                throw new ValidationError(&#x22;Expected end of value but found &#x27;&#x22; + part + &#x22;&#x27;.&#x22;, part.
line, part.col);
            }
            return;
        }

        // Property-specific validation.
        this.<span class="apidocCodeKeywordSpan">singleProperty</span>(spec, expression);

    }

},

singleProperty: function(types, expression) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.Validation.validate" id="apidoc.element.parserlib.Validation.validate">
        function <span class="apidocSignatureSpan">parserlib.Validation.</span>validate
        <span class="apidocSignatureSpan">(property, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate = function (property, value) {

    //normalize name
    var name        = property.toString().toLowerCase(),
        expression  = new PropertyValueIterator(value),
        spec        = Properties[name],
        part;

    if (!spec) {
        if (name.indexOf(&#x22;-&#x22;) !== 0) {    //vendor prefixed are ok
            throw new ValidationError(&#x22;Unknown property &#x27;&#x22; + property + &#x22;&#x27;.&#x22;, property.line, property.col);
        }
    } else if (typeof spec !== &#x22;number&#x22;) {

        // All properties accept some CSS-wide values.
        // https://drafts.csswg.org/css-values-3/#common-keywords
        if (ValidationTypes.isAny(expression, &#x22;inherit | initial | unset&#x22;)) {
            if (expression.hasNext()) {
                part = expression.next();
                throw new ValidationError(&#x22;Expected end of value but found &#x27;&#x22; + part + &#x22;&#x27;.&#x22;, part.line, part.col);
            }
            return;
        }

        // Property-specific validation.
        this.singleProperty(spec, expression);

    }

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
},

//-----------------------------------------------------------------
// Validation methods
//-----------------------------------------------------------------
_validateProperty: function(property, value) {
    Validation.<span class="apidocCodeKeywordSpan">validate</span>(property, value);
},

//-----------------------------------------------------------------
// Parsing methods
//-----------------------------------------------------------------

parse: function(input) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.parserlib.ValidationTypes" id="apidoc.module.parserlib.ValidationTypes">module parserlib.ValidationTypes</a></h1>


    <h2>
        <a href="#apidoc.element.parserlib.ValidationTypes.describe" id="apidoc.element.parserlib.ValidationTypes.describe">
        function <span class="apidocSignatureSpan">parserlib.ValidationTypes.</span>describe
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">describe = function (type) {
    if (this.complex[type] instanceof Matcher) {
        return this.complex[type].toString(0);
    }
    return type;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    result = Matcher.parse(types).match(expression);

    if (!result) {
        if (expression.hasNext() &#x26;&#x26; !expression.isFirst()) {
            part = expression.peek();
            throw new ValidationError(&#x22;Expected end of value but found &#x27;&#x22; + part + &#x22;&#x27;.&#x22;, part.line
, part.col);
        } else {
            throw new ValidationError(&#x22;Expected (&#x22; + ValidationTypes.<span class="apidocCodeKeywordSpan">describe</span
>(types) + &#x22;) but found &#x27;&#x22; + value + &#x22;&#x27;.&#x22;, value.line, value.col);
        }
    } else if (expression.hasNext()) {
        part = expression.next();
        throw new ValidationError(&#x22;Expected end of value but found &#x27;&#x22; + part + &#x22;&#x27;.&#x22;, part.line, part
.col);
    }

}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.ValidationTypes.isAny" id="apidoc.element.parserlib.ValidationTypes.isAny">
        function <span class="apidocSignatureSpan">parserlib.ValidationTypes.</span>isAny
        <span class="apidocSignatureSpan">(expression, types)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isAny = function (expression, types) {
    var args = types.split(&#x22; | &#x22;),
        i, len, found = false;

    for (i=0, len=args.length; i &#x3c; len &#x26;&#x26; !found &#x26;&#x26; expression.hasNext(); i++) {
        found = this.isType(expression, args[i]);
    }

    return found;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (name.indexOf(&#x22;-&#x22;) !== 0) {    //vendor prefixed are ok
    throw new ValidationError(&#x22;Unknown property &#x27;&#x22; + property + &#x22;&#x27;.&#x22;, property.line, property.col);
}
        } else if (typeof spec !== &#x22;number&#x22;) {

// All properties accept some CSS-wide values.
// https://drafts.csswg.org/css-values-3/#common-keywords
if (ValidationTypes.<span class="apidocCodeKeywordSpan">isAny</span>(expression, &#x22;inherit | initial | unset&#x22;)) {
    if (expression.hasNext()) {
        part = expression.next();
        throw new ValidationError(&#x22;Expected end of value but found &#x27;&#x22; + part + &#x22;&#x27;.&#x22;, part.line, part
.col);
    }
    return;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.ValidationTypes.isAnyOfGroup" id="apidoc.element.parserlib.ValidationTypes.isAnyOfGroup">
        function <span class="apidocSignatureSpan">parserlib.ValidationTypes.</span>isAnyOfGroup
        <span class="apidocSignatureSpan">(expression, types)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isAnyOfGroup = function (expression, types) {
    var args = types.split(&#x22; || &#x22;),
        i, len, found = false;

    for (i=0, len=args.length; i &#x3c; len &#x26;&#x26; !found; i++) {
        found = this.isType(expression, args[i]);
    }

    return found ? args[i-1] : false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.ValidationTypes.isComplex" id="apidoc.element.parserlib.ValidationTypes.isComplex">
        function <span class="apidocSignatureSpan">parserlib.ValidationTypes.</span>isComplex
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isComplex = function (type) {
    return Boolean(this.complex[type]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.ValidationTypes.isLiteral" id="apidoc.element.parserlib.ValidationTypes.isLiteral">
        function <span class="apidocSignatureSpan">parserlib.ValidationTypes.</span>isLiteral
        <span class="apidocSignatureSpan">(part, literals)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isLiteral = function (part, literals) {
    var text = part.text.toString().toLowerCase(),
        args = literals.split(&#x22; | &#x22;),
        i, len, found = false;

    for (i=0, len=args.length; i &#x3c; len &#x26;&#x26; !found; i++) {
        if (args[i].charAt(0) === &#x22;&#x3c;&#x22;) {
            found = this.simple[args[i]](part);
        } else if (args[i].slice(-2) === &#x22;()&#x22;) {
            found = (part.type === &#x22;function&#x22; &#x26;&#x26;
                     part.name === args[i].slice(0, -2));
        } else if (text === args[i].toLowerCase()) {
            found = true;
        }
    }

    return found;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * are of a given type.
     */
    isType: function (expression, type) {
var part = expression.peek(),
    result = false;

if (type.charAt(0) !== &#x22;&#x3c;&#x22;) {
    result = this.<span class="apidocCodeKeywordSpan">isLiteral</span>(part, type);
    if (result) {
        expression.next();
    }
} else if (this.simple[type]) {
    result = this.simple[type](part);
    if (result) {
        expression.next();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.ValidationTypes.isSimple" id="apidoc.element.parserlib.ValidationTypes.isSimple">
        function <span class="apidocSignatureSpan">parserlib.ValidationTypes.</span>isSimple
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isSimple = function (type) {
    return Boolean(this.simple[type]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.ValidationTypes.isType" id="apidoc.element.parserlib.ValidationTypes.isType">
        function <span class="apidocSignatureSpan">parserlib.ValidationTypes.</span>isType
        <span class="apidocSignatureSpan">(expression, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isType = function (expression, type) {
    var part = expression.peek(),
        result = false;

    if (type.charAt(0) !== &#x22;&#x3c;&#x22;) {
        result = this.isLiteral(part, type);
        if (result) {
            expression.next();
        }
    } else if (this.simple[type]) {
        result = this.simple[type](part);
        if (result) {
            expression.next();
        }
    } else if (this.complex[type] instanceof Matcher) {
        result = this.complex[type].match(expression);
    } else {
        result = this.complex[type](expression);
    }

    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* Create a matcher for a single type.
*/
Matcher.fromType = function(type) {
   // Late require of ValidationTypes to break a dependency cycle.
   var ValidationTypes = require(&#x22;./ValidationTypes&#x22;);
   return new Matcher(function(expression) {
       return expression.hasNext() &#x26;&#x26; ValidationTypes.<span class="apidocCodeKeywordSpan">isType</span>(expression, type
);
   }, type);
};

/**
* Create a matcher for one or more juxtaposed words, which all must
* occur, in the given order.
*/
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.parserlib.css" id="apidoc.module.parserlib.css">module parserlib.css</a></h1>


    <h2>
        <a href="#apidoc.element.parserlib.css.Combinator" id="apidoc.element.parserlib.css.Combinator">
        function <span class="apidocSignatureSpan">parserlib.css.</span>Combinator
        <span class="apidocSignatureSpan">(text, line, col)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Combinator(text, line, col) {

    SyntaxUnit.call(this, text, line, col, Parser.COMBINATOR_TYPE);

    /**
     * The type of modifier.
     * @type String
     * @property type
     */
    this.type = &#x22;unknown&#x22;;

    //pretty simple
    if (/^\s+$/.test(text)) {
        this.type = &#x22;descendant&#x22;;
    } else if (text === &#x22;&#x3e;&#x22;) {
        this.type = &#x22;child&#x22;;
    } else if (text === &#x22;+&#x22;) {
        this.type = &#x22;adjacent-sibling&#x22;;
    } else if (text === &#x22;~&#x22;) {
        this.type = &#x22;sibling&#x22;;
    }

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Matcher" id="apidoc.element.parserlib.css.Matcher">
        function <span class="apidocSignatureSpan">parserlib.css.</span>Matcher
        <span class="apidocSignatureSpan">(matchFunc, toString)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Matcher(matchFunc, toString) {
    this.match = function(expression) {
        // Save/restore marks to ensure that failed matches always restore
        // the original location in the expression.
        var result;
        expression.mark();
        result = matchFunc(expression);
        if (result) {
            expression.drop();
        } else {
            expression.restore();
        }
        return result;
    };
    this.toString = typeof toString === &#x22;function&#x22; ? toString : function() {
        return toString;
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.MediaFeature" id="apidoc.element.parserlib.css.MediaFeature">
        function <span class="apidocSignatureSpan">parserlib.css.</span>MediaFeature
        <span class="apidocSignatureSpan">(name, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MediaFeature(name, value) {

    SyntaxUnit.call(this, &#x22;(&#x22; + name + (value !== null ? &#x22;:&#x22; + value : &#x22;&#x22;) + &#x22;)&#x22;, name.startLine, name.startCol, Parser.MEDIA_FEATURE_TYPE
);

    /**
     * The name of the media feature
     * @type String
     * @property name
     */
    this.name = name;

    /**
     * The value for the feature or null if there is none.
     * @type SyntaxUnit
     * @property value
     */
    this.value = value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.MediaQuery" id="apidoc.element.parserlib.css.MediaQuery">
        function <span class="apidocSignatureSpan">parserlib.css.</span>MediaQuery
        <span class="apidocSignatureSpan">(modifier, mediaType, features, line, col)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MediaQuery(modifier, mediaType, features, line, col) {

    SyntaxUnit.call(this, (modifier ? modifier + &#x22; &#x22;: &#x22;&#x22;) + (mediaType ? mediaType : &#x22;&#x22;) + (mediaType &#x26;&#x26; features.length &#x3e; 0 ? &#x22;
and &#x22; : &#x22;&#x22;) + features.join(&#x22; and &#x22;), line, col, Parser.MEDIA_QUERY_TYPE);

    /**
     * The media modifier (&#x22;not&#x22; or &#x22;only&#x22;)
     * @type String
     * @property modifier
     */
    this.modifier = modifier;

    /**
     * The mediaType (i.e., &#x22;print&#x22;)
     * @type String
     * @property mediaType
     */
    this.mediaType = mediaType;

    /**
     * The parts that make up the selector.
     * @type Array
     * @property features
     */
    this.features = features;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser" id="apidoc.element.parserlib.css.Parser">
        function <span class="apidocSignatureSpan">parserlib.css.</span>Parser
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parser(options) {

    //inherit event functionality
    EventTarget.call(this);


    this.options = options || {};

    this._tokenStream = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

You can use the CSS parser in a `Node.js` script via the standard
`npm` package manager as the `parserlib` package (`npm install parserlib`):

```js
var parserlib = require(&#x22;parserlib&#x22;);

var parser = new parserlib.css.<span class="apidocCodeKeywordSpan">Parser</span>();
```

Alternatively, you can copy a single file version of the parser from
`dist/node-parserlib.js` to your own project, and use it as follows:

```js
var parserlib = require(&#x22;./node-parserlib&#x22;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.PropertyName" id="apidoc.element.parserlib.css.PropertyName">
        function <span class="apidocSignatureSpan">parserlib.css.</span>PropertyName
        <span class="apidocSignatureSpan">(text, hack, line, col)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PropertyName(text, hack, line, col) {

    SyntaxUnit.call(this, text, line, col, Parser.PROPERTY_NAME_TYPE);

    /**
     * The type of IE hack applied (&#x22;*&#x22;, &#x22;_&#x22;, or null).
     * @type String
     * @property hack
     */
    this.hack = hack;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.PropertyValue" id="apidoc.element.parserlib.css.PropertyValue">
        function <span class="apidocSignatureSpan">parserlib.css.</span>PropertyValue
        <span class="apidocSignatureSpan">(parts, line, col)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PropertyValue(parts, line, col) {

    SyntaxUnit.call(this, parts.join(&#x22; &#x22;), line, col, Parser.PROPERTY_VALUE_TYPE);

    /**
     * The parts that make up the selector.
     * @type Array
     * @property parts
     */
    this.parts = parts;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.PropertyValuePart" id="apidoc.element.parserlib.css.PropertyValuePart">
        function <span class="apidocSignatureSpan">parserlib.css.</span>PropertyValuePart
        <span class="apidocSignatureSpan">(text, line, col, optionalHint)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PropertyValuePart(text, line, col, optionalHint) {
    var hint = optionalHint || {};

    SyntaxUnit.call(this, text, line, col, Parser.PROPERTY_VALUE_PART_TYPE);

    /**
     * Indicates the type of value unit.
     * @type String
     * @property type
     */
    this.type = &#x22;unknown&#x22;;

    //figure out what type of data it is

    var temp;

    //it is a measurement?
    if (/^([+\-]?[\d\.]+)([a-z]+)$/i.test(text)) {  //dimension
        this.type = &#x22;dimension&#x22;;
        this.value = +RegExp.$1;
        this.units = RegExp.$2;

        //try to narrow down
        switch (this.units.toLowerCase()) {

            case &#x22;em&#x22;:
            case &#x22;rem&#x22;:
            case &#x22;ex&#x22;:
            case &#x22;px&#x22;:
            case &#x22;cm&#x22;:
            case &#x22;mm&#x22;:
            case &#x22;in&#x22;:
            case &#x22;pt&#x22;:
            case &#x22;pc&#x22;:
            case &#x22;ch&#x22;:
            case &#x22;vh&#x22;:
            case &#x22;vw&#x22;:
            case &#x22;vmax&#x22;:
            case &#x22;vmin&#x22;:
                this.type = &#x22;length&#x22;;
                break;

            case &#x22;fr&#x22;:
                this.type = &#x22;grid&#x22;;
                break;

            case &#x22;deg&#x22;:
            case &#x22;rad&#x22;:
            case &#x22;grad&#x22;:
            case &#x22;turn&#x22;:
                this.type = &#x22;angle&#x22;;
                break;

            case &#x22;ms&#x22;:
            case &#x22;s&#x22;:
                this.type = &#x22;time&#x22;;
                break;

            case &#x22;hz&#x22;:
            case &#x22;khz&#x22;:
                this.type = &#x22;frequency&#x22;;
                break;

            case &#x22;dpi&#x22;:
            case &#x22;dpcm&#x22;:
                this.type = &#x22;resolution&#x22;;
                break;

            //default

        }

    } else if (/^([+\-]?[\d\.]+)%$/i.test(text)) {  //percentage
        this.type = &#x22;percentage&#x22;;
        this.value = +RegExp.$1;
    } else if (/^([+\-]?\d+)$/i.test(text)) {  //integer
        this.type = &#x22;integer&#x22;;
        this.value = +RegExp.$1;
    } else if (/^([+\-]?[\d\.]+)$/i.test(text)) {  //number
        this.type = &#x22;number&#x22;;
        this.value = +RegExp.$1;

    } else if (/^#([a-f0-9]{3,6})/i.test(text)) {  //hexcolor
        this.type = &#x22;color&#x22;;
        temp = RegExp.$1;
        if (temp.length === 3) {
            this.red    = parseInt(temp.charAt(0)+temp.charAt(0), 16);
            this.green  = parseInt(temp.charAt(1)+temp.charAt(1), 16);
            this.blue   = parseInt(temp.charAt(2)+temp.charAt(2), 16);
        } else {
            this.red    = parseInt(temp.substring(0, 2), 16);
            this.green  = parseInt(temp.substring(2, 4), 16);
            this.blue   = parseInt(temp.substring(4, 6), 16);
        }
    } else if (/^rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/i.test(text)) { //rgb() color with absolute numbers
        this.type   = &#x22;color&#x22;;
        this.red    = +RegExp.$1;
        this.green  = +RegExp.$2;
        this.blue   = +RegExp.$3;
    } else if (/^rgb\(\s*(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*\)/i.test(text)) { //rgb() color with percentages
        this.type   = &#x22;color&#x22;;
        this.red    = +RegExp.$1 * 255 / 100;
        this.green  = +RegExp.$2 * 255 / 100;
        this.blue   = +RegExp.$3 * 255 / 100;
    } else if (/^rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d\.]+)\s*\)/i.test(text)) { //rgba() color with absolute numbers
        this.type   = &#x22;color&#x22;;
        this.red    = +RegExp.$1;
        this.green  = +RegExp.$2;
        this.blue   = +RegExp.$3;
        this.alpha  = +RegExp.$4;
    } else if (/^rgba\(\s*(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*,\s*([\d\.]+)\s*\)/i.test(text)) { //rgba() color with percentages
        this.type   = &#x22;color&#x22;;
        this.red    = +RegExp.$1 * 255 / 100;
        this.green  = +RegExp.$2 * 255 / 100;
        this.blue   = +RegExp.$3 * 255 / 100;
        this.alpha  = +RegExp.$4;
    } else if (/^hsl\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*\)/i.test(text)) { //hsl()
        this.type   = &#x22;color&#x22;;
        this.hue    = +RegExp.$1;
        this.saturation = +RegExp.$2 / 100;
        this.lightness  = +RegExp.$3 / 100;
    } else if ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Selector" id="apidoc.element.parserlib.css.Selector">
        function <span class="apidocSignatureSpan">parserlib.css.</span>Selector
        <span class="apidocSignatureSpan">(parts, line, col)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Selector(parts, line, col) {

    SyntaxUnit.call(this, parts.join(&#x22; &#x22;), line, col, Parser.SELECTOR_TYPE);

    /**
     * The parts that make up the selector.
     * @type Array
     * @property parts
     */
    this.parts = parts;

    /**
     * The specificity of the selector.
     * @type parserlib.css.Specificity
     * @property specificity
     */
    this.specificity = Specificity.calculate(this);

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.SelectorPart" id="apidoc.element.parserlib.css.SelectorPart">
        function <span class="apidocSignatureSpan">parserlib.css.</span>SelectorPart
        <span class="apidocSignatureSpan">(elementName, modifiers, text, line, col)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SelectorPart(elementName, modifiers, text, line, col) {

    SyntaxUnit.call(this, text, line, col, Parser.SELECTOR_PART_TYPE);

    /**
     * The tag name of the element to which this part
     * of the selector affects.
     * @type String
     * @property elementName
     */
    this.elementName = elementName;

    /**
     * The parts that come after the element name, such as class names, IDs,
     * pseudo classes/elements, etc.
     * @type Array
     * @property modifiers
     */
    this.modifiers = modifiers;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.SelectorSubPart" id="apidoc.element.parserlib.css.SelectorSubPart">
        function <span class="apidocSignatureSpan">parserlib.css.</span>SelectorSubPart
        <span class="apidocSignatureSpan">(text, type, line, col)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SelectorSubPart(text, type, line, col) {

    SyntaxUnit.call(this, text, line, col, Parser.SELECTOR_SUB_PART_TYPE);

    /**
     * The type of modifier.
     * @type String
     * @property type
     */
    this.type = type;

    /**
     * Some subparts have arguments, this represents them.
     * @type Array
     * @property args
     */
    this.args = [];

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Specificity" id="apidoc.element.parserlib.css.Specificity">
        function <span class="apidocSignatureSpan">parserlib.css.</span>Specificity
        <span class="apidocSignatureSpan">(a, b, c, d)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Specificity(a, b, c, d) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.TokenStream" id="apidoc.element.parserlib.css.TokenStream">
        function <span class="apidocSignatureSpan">parserlib.css.</span>TokenStream
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TokenStream(input) {
    TokenStreamBase.call(this, input, Tokens);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.ValidationError" id="apidoc.element.parserlib.css.ValidationError">
        function <span class="apidocSignatureSpan">parserlib.css.</span>ValidationError
        <span class="apidocSignatureSpan">(message, line, col)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ValidationError(message, line, col) {

    /**
     * The column at which the error occurred.
     * @type int
     * @property col
     */
    this.col = col;

    /**
     * The line at which the error occurred.
     * @type int
     * @property line
     */
    this.line = line;

    /**
     * The text representation of the unit.
     * @type String
     * @property text
     */
    this.message = message;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.parserlib.css.Combinator" id="apidoc.module.parserlib.css.Combinator">module parserlib.css.Combinator</a></h1>


    <h2>
        <a href="#apidoc.element.parserlib.css.Combinator.Combinator" id="apidoc.element.parserlib.css.Combinator.Combinator">
        function <span class="apidocSignatureSpan">parserlib.css.</span>Combinator
        <span class="apidocSignatureSpan">(text, line, col)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Combinator(text, line, col) {

    SyntaxUnit.call(this, text, line, col, Parser.COMBINATOR_TYPE);

    /**
     * The type of modifier.
     * @type String
     * @property type
     */
    this.type = &#x22;unknown&#x22;;

    //pretty simple
    if (/^\s+$/.test(text)) {
        this.type = &#x22;descendant&#x22;;
    } else if (text === &#x22;&#x3e;&#x22;) {
        this.type = &#x22;child&#x22;;
    } else if (text === &#x22;+&#x22;) {
        this.type = &#x22;adjacent-sibling&#x22;;
    } else if (text === &#x22;~&#x22;) {
        this.type = &#x22;sibling&#x22;;
    }

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.parserlib.css.Combinator.prototype" id="apidoc.module.parserlib.css.Combinator.prototype">module parserlib.css.Combinator.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.parserlib.css.Combinator.prototype.constructor" id="apidoc.element.parserlib.css.Combinator.prototype.constructor">
        function <span class="apidocSignatureSpan">parserlib.css.Combinator.prototype.</span>constructor
        <span class="apidocSignatureSpan">(text, line, col)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Combinator(text, line, col) {

    SyntaxUnit.call(this, text, line, col, Parser.COMBINATOR_TYPE);

    /**
     * The type of modifier.
     * @type String
     * @property type
     */
    this.type = &#x22;unknown&#x22;;

    //pretty simple
    if (/^\s+$/.test(text)) {
        this.type = &#x22;descendant&#x22;;
    } else if (text === &#x22;&#x3e;&#x22;) {
        this.type = &#x22;child&#x22;;
    } else if (text === &#x22;+&#x22;) {
        this.type = &#x22;adjacent-sibling&#x22;;
    } else if (text === &#x22;~&#x22;) {
        this.type = &#x22;sibling&#x22;;
    }

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.parserlib.css.Matcher" id="apidoc.module.parserlib.css.Matcher">module parserlib.css.Matcher</a></h1>


    <h2>
        <a href="#apidoc.element.parserlib.css.Matcher.Matcher" id="apidoc.element.parserlib.css.Matcher.Matcher">
        function <span class="apidocSignatureSpan">parserlib.css.</span>Matcher
        <span class="apidocSignatureSpan">(matchFunc, toString)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Matcher(matchFunc, toString) {
    this.match = function(expression) {
        // Save/restore marks to ensure that failed matches always restore
        // the original location in the expression.
        var result;
        expression.mark();
        result = matchFunc(expression);
        if (result) {
            expression.drop();
        } else {
            expression.restore();
        }
        return result;
    };
    this.toString = typeof toString === &#x22;function&#x22; ? toString : function() {
        return toString;
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Matcher.alt" id="apidoc.element.parserlib.css.Matcher.alt">
        function <span class="apidocSignatureSpan">parserlib.css.Matcher.</span>alt
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">alt = function () {
    var ms = Array.prototype.slice.call(arguments).map(Matcher.cast);
    if (ms.length === 1) {
        return ms[0];
    }
    return new Matcher(function(expression) {
        var i, result = false;
        for (i = 0; !result &#x26;&#x26; i &#x3c; ms.length; i++) {
            result = ms[i].match(expression);
        }
        return result;
    }, function(prec) {
        var p = Matcher.prec.ALT;
        var s = ms.map(function(m) {
            return m.toString(p);
        }).join(&#x22; | &#x22;);
        if (prec &#x3e; p) {
            s = &#x22;[ &#x22; + s + &#x22; ]&#x22;;
        }
        return s;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// These are expected to be overridden in every instance.
match: function() { throw new Error(&#x22;unimplemented&#x22;); },
toString: function() { throw new Error(&#x22;unimplemented&#x22;); },
// This returns a standalone function to do the matching.
func: function() { return this.match.bind(this); },
// Basic combinators
then: function(m) { return Matcher.seq(this, m); },
or: function(m) { return Matcher.<span class="apidocCodeKeywordSpan">alt</span>(this, m); },
andand: function(m) { return Matcher.many(true, this, m); },
oror: function(m) { return Matcher.many(false, this, m); },
// Component value multipliers
star: function() { return this.braces(0, Infinity, &#x22;*&#x22;); },
plus: function() { return this.braces(1, Infinity, &#x22;+&#x22;); },
question: function() { return this.braces(0, 1, &#x22;?&#x22;); },
hash: function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Matcher.andand" id="apidoc.element.parserlib.css.Matcher.andand">
        function <span class="apidocSignatureSpan">parserlib.css.Matcher.</span>andand
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">andand = function () {
    var args = Array.prototype.slice.call(arguments);
    args.unshift(true);
    return Matcher.many.apply(Matcher, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Matcher.cast" id="apidoc.element.parserlib.css.Matcher.cast">
        function <span class="apidocSignatureSpan">parserlib.css.Matcher.</span>cast
        <span class="apidocSignatureSpan">(m)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cast = function (m) {
    if (m instanceof Matcher) {
        return m;
    }
    return Matcher.parse(m);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var ms = Array.prototype.slice.call(arguments, 1).reduce(function(acc, v) {
    if (v.expand) {
        // Insert all of the options for the given complex rule as
        // individual options.
        var ValidationTypes = require(&#x22;./ValidationTypes&#x22;);
        acc.push.apply(acc, ValidationTypes.complex[v.expand].options);
    } else {
        acc.push(Matcher.<span class="apidocCodeKeywordSpan">cast</span>(v));
    }
    return acc;
}, []);

if (required === true) {
    required = ms.map(function() {
        return true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Matcher.fromType" id="apidoc.element.parserlib.css.Matcher.fromType">
        function <span class="apidocSignatureSpan">parserlib.css.Matcher.</span>fromType
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromType = function (type) {
    // Late require of ValidationTypes to break a dependency cycle.
    var ValidationTypes = require(&#x22;./ValidationTypes&#x22;);
    return new Matcher(function(expression) {
        return expression.hasNext() &#x26;&#x26; ValidationTypes.isType(expression, type);
    }, type);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
term = function() {
    // term = &#x3c;nt&#x3e; | literal | &#x22;[ &#x22; expression &#x22; ]&#x22;
    if (reader.readMatch(&#x22;[ &#x22;) !== null) {
        var m = expr();
        eat(&#x22; ]&#x22;);
        return m;
    }
    return Matcher.<span class="apidocCodeKeywordSpan">fromType</span>(eat(/^[^ ?*+#{]+/));
};
result = expr();
if (!reader.eof()) {
    throw new SyntaxError(
        &#x22;Expected end of string&#x22;, reader.getLine(), reader.getCol());
}
return result;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Matcher.many" id="apidoc.element.parserlib.css.Matcher.many">
        function <span class="apidocSignatureSpan">parserlib.css.Matcher.</span>many
        <span class="apidocSignatureSpan">(required)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">many = function (required) {
    var ms = Array.prototype.slice.call(arguments, 1).reduce(function(acc, v) {
        if (v.expand) {
            // Insert all of the options for the given complex rule as
            // individual options.
            var ValidationTypes = require(&#x22;./ValidationTypes&#x22;);
            acc.push.apply(acc, ValidationTypes.complex[v.expand].options);
        } else {
            acc.push(Matcher.cast(v));
        }
        return acc;
    }, []);

    if (required === true) {
        required = ms.map(function() {
            return true;
        });
    }

    var result = new Matcher(function(expression) {
        var seen = [], max = 0, pass = 0;
        var success = function(matchCount) {
            if (pass === 0) {
                max = Math.max(matchCount, max);
                return matchCount === ms.length;
            } else {
                return matchCount === max;
            }
        };
        var tryMatch = function(matchCount) {
            for (var i = 0; i &#x3c; ms.length; i++) {
                if (seen[i]) {
                    continue;
                }
                expression.mark();
                if (ms[i].match(expression)) {
                    seen[i] = true;
                    // Increase matchCount iff this was a required element
                    // (or if all the elements are optional)
                    if (tryMatch(matchCount + ((required === false || required[i]) ? 1 : 0))) {
                        expression.drop();
                        return true;
                    }
                    // Backtrack: try *not* matching using this rule, and
                    // let&#x27;s see if it leads to a better overall match.
                    expression.restore();
                    seen[i] = false;
                } else {
                    expression.drop();
                }
            }
            return success(matchCount);
        };
        if (!tryMatch(0)) {
            // Couldn&#x27;t get a complete match, retrace our steps to make the
            // match with the maximum # of required elements.
            pass++;
            tryMatch(0);
        }

        if (required === false) {
            return max &#x3e; 0;
        }
        // Use finer-grained specification of which matchers are required.
        for (var i = 0; i &#x3c; ms.length; i++) {
            if (required[i] &#x26;&#x26; !seen[i]) {
                return false;
            }
        }
        return true;
    }, function(prec) {
        var p = required === false ? Matcher.prec.OROR : Matcher.prec.ANDAND;
        var s = ms.map(function(m, i) {
            if (required !== false &#x26;&#x26; !required[i]) {
                return m.toString(Matcher.prec.MOD) + &#x22;?&#x22;;
            }
            return m.toString(p);
        }).join(required === false ? &#x22; || &#x22; : &#x22; &#x26;&#x26; &#x22;);
        if (prec &#x3e; p) {
            s = &#x22;[ &#x22; + s + &#x22; ]&#x22;;
        }
        return s;
    });
    result.options = ms;
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
match: function() { throw new Error(&#x22;unimplemented&#x22;); },
toString: function() { throw new Error(&#x22;unimplemented&#x22;); },
// This returns a standalone function to do the matching.
func: function() { return this.match.bind(this); },
// Basic combinators
then: function(m) { return Matcher.seq(this, m); },
or: function(m) { return Matcher.alt(this, m); },
andand: function(m) { return Matcher.<span class="apidocCodeKeywordSpan">many</span>(true, this, m); },
oror: function(m) { return Matcher.many(false, this, m); },
// Component value multipliers
star: function() { return this.braces(0, Infinity, &#x22;*&#x22;); },
plus: function() { return this.braces(1, Infinity, &#x22;+&#x22;); },
question: function() { return this.braces(0, 1, &#x22;?&#x22;); },
hash: function() {
    return this.braces(1, Infinity, &#x22;#&#x22;, Matcher.cast(&#x22;,&#x22;));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Matcher.oror" id="apidoc.element.parserlib.css.Matcher.oror">
        function <span class="apidocSignatureSpan">parserlib.css.Matcher.</span>oror
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">oror = function () {
    var args = Array.prototype.slice.call(arguments);
    args.unshift(false);
    return Matcher.many.apply(Matcher, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        ValidationTypes.complex[nt] = Matcher.parse(rule);
    }
});

// Because this is defined relative to other complex validation types,
// we need to define it *after* the rest of the types are initialized.
ValidationTypes.complex[&#x22;&#x3c;font-variant&#x3e;&#x22;] =
    Matcher.<span class="apidocCodeKeywordSpan">oror</span>({ expand: &#x22;&#x3c;font-variant-ligatures&#x3e;&#x22; },
                 { expand: &#x22;&#x3c;font-variant-alternates&#x3e;&#x22; },
                 &#x22;&#x3c;font-variant-caps&#x3e;&#x22;,
                 { expand: &#x22;&#x3c;font-variant-numeric&#x3e;&#x22; },
                 { expand: &#x22;&#x3c;font-variant-east-asian&#x3e;&#x22; });
},{&#x22;./Matcher&#x22;:3}],22:[function(require,module,exports){
&#x22;use strict&#x22;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Matcher.parse" id="apidoc.element.parserlib.css.Matcher.parse">
        function <span class="apidocSignatureSpan">parserlib.css.Matcher.</span>parse
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (str) {
    var reader, eat, expr, oror, andand, seq, mod, term, result;
    reader = new StringReader(str);
    eat = function(matcher) {
        var result = reader.readMatch(matcher);
        if (result === null) {
            throw new SyntaxError(
                &#x22;Expected &#x22;+matcher, reader.getLine(), reader.getCol());
        }
        return result;
    };
    expr = function() {
        // expr = oror (&#x22; | &#x22; oror)*
        var m = [ oror() ];
        while (reader.readMatch(&#x22; | &#x22;) !== null) {
            m.push(oror());
        }
        return m.length === 1 ? m[0] : Matcher.alt.apply(Matcher, m);
    };
    oror = function() {
        // oror = andand ( &#x22; || &#x22; andand)*
        var m = [ andand() ];
        while (reader.readMatch(&#x22; || &#x22;) !== null) {
            m.push(andand());
        }
        return m.length === 1 ? m[0] : Matcher.oror.apply(Matcher, m);
    };
    andand = function() {
        // andand = seq ( &#x22; &#x26;&#x26; &#x22; seq)*
        var m = [ seq() ];
        while (reader.readMatch(&#x22; &#x26;&#x26; &#x22;) !== null) {
            m.push(seq());
        }
        return m.length === 1 ? m[0] : Matcher.andand.apply(Matcher, m);
    };
    seq = function() {
        // seq = mod ( &#x22; &#x22; mod)*
        var m = [ mod() ];
        while (reader.readMatch(/^ (?![&#x26;|\]])/) !== null) {
            m.push(mod());
        }
        return m.length === 1 ? m[0] : Matcher.seq.apply(Matcher, m);
    };
    mod = function() {
        // mod = term ( &#x22;?&#x22; | &#x22;*&#x22; | &#x22;+&#x22; | &#x22;#&#x22; | &#x22;{&#x3c;num&#x3e;,&#x3c;num&#x3e;}&#x22; )?
        var m = term();
        if (reader.readMatch(&#x22;?&#x22;) !== null) {
            return m.question();
        } else if (reader.readMatch(&#x22;*&#x22;) !== null) {
            return m.star();
        } else if (reader.readMatch(&#x22;+&#x22;) !== null) {
            return m.plus();
        } else if (reader.readMatch(&#x22;#&#x22;) !== null) {
            return m.hash();
        } else if (reader.readMatch(/^\{\s*/) !== null) {
            var min = eat(/^\d+/);
            eat(/^\s*,\s*/);
            var max = eat(/^\d+/);
            eat(/^\s*\}/);
            return m.braces(+min, +max);
        }
        return m;
    };
    term = function() {
        // term = &#x3c;nt&#x3e; | literal | &#x22;[ &#x22; expression &#x22; ]&#x22;
        if (reader.readMatch(&#x22;[ &#x22;) !== null) {
            var m = expr();
            eat(&#x22; ]&#x22;);
            return m;
        }
        return Matcher.fromType(eat(/^[^ ?*+#{]+/));
    };
    result = expr();
    if (!reader.eof()) {
        throw new SyntaxError(
            &#x22;Expected end of string&#x22;, reader.getLine(), reader.getCol());
    }
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
var parser = new parserlib.css.Parser({ starHack: true, underscoreHack: true });
```

You can then parse a string of CSS code by passing into the `parse()` method:

```js
parser.<span class="apidocCodeKeywordSpan">parse</span>(someCSSText);
```

The `parse()` method throws an error if a non-recoverable syntax error occurs,
otherwise it finishes silently.
This method does not return a value nor does it build up an abstract syntax
tree (AST) for you, it simply parses the CSS text and fires events at important
moments along the parse.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Matcher.seq" id="apidoc.element.parserlib.css.Matcher.seq">
        function <span class="apidocSignatureSpan">parserlib.css.Matcher.</span>seq
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">seq = function () {
    var ms = Array.prototype.slice.call(arguments).map(Matcher.cast);
    if (ms.length === 1) {
        return ms[0];
    }
    return new Matcher(function(expression) {
        var i, result = true;
        for (i = 0; result &#x26;&#x26; i &#x3c; ms.length; i++) {
            result = ms[i].match(expression);
        }
        return result;
    }, function(prec) {
        var p = Matcher.prec.SEQ;
        var s = ms.map(function(m) {
            return m.toString(p);
        }).join(&#x22; &#x22;);
        if (prec &#x3e; p) {
            s = &#x22;[ &#x22; + s + &#x22; ]&#x22;;
        }
        return s;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
constructor: Matcher,
// These are expected to be overridden in every instance.
match: function() { throw new Error(&#x22;unimplemented&#x22;); },
toString: function() { throw new Error(&#x22;unimplemented&#x22;); },
// This returns a standalone function to do the matching.
func: function() { return this.match.bind(this); },
// Basic combinators
then: function(m) { return Matcher.<span class="apidocCodeKeywordSpan">seq</span>(this, m); },
or: function(m) { return Matcher.alt(this, m); },
andand: function(m) { return Matcher.many(true, this, m); },
oror: function(m) { return Matcher.many(false, this, m); },
// Component value multipliers
star: function() { return this.braces(0, Infinity, &#x22;*&#x22;); },
plus: function() { return this.braces(1, Infinity, &#x22;+&#x22;); },
question: function() { return this.braces(0, 1, &#x22;?&#x22;); },
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.parserlib.css.Matcher.prototype" id="apidoc.module.parserlib.css.Matcher.prototype">module parserlib.css.Matcher.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.parserlib.css.Matcher.prototype.andand" id="apidoc.element.parserlib.css.Matcher.prototype.andand">
        function <span class="apidocSignatureSpan">parserlib.css.Matcher.prototype.</span>andand
        <span class="apidocSignatureSpan">(m)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">andand = function (m) { return Matcher.many(true, this, m); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Matcher.prototype.braces" id="apidoc.element.parserlib.css.Matcher.prototype.braces">
        function <span class="apidocSignatureSpan">parserlib.css.Matcher.prototype.</span>braces
        <span class="apidocSignatureSpan">(min, max, marker, optSep)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">braces = function (min, max, marker, optSep) {
    var m1 = this, m2 = optSep ? optSep.then(this) : this;
    if (!marker) {
        marker = &#x22;{&#x22; + min + &#x22;,&#x22; + max + &#x22;}&#x22;;
    }
    return new Matcher(function(expression) {
        var result = true, i;
        for (i = 0; i &#x3c; max; i++) {
            if (i &#x3e; 0 &#x26;&#x26; optSep) {
                result = m2.match(expression);
            } else {
                result = m1.match(expression);
            }
            if (!result) {
                break;
            }
        }
        return i &#x3e;= min;
    }, function() {
        return m1.toString(Matcher.prec.MOD) + marker;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    } else if (reader.readMatch(&#x22;#&#x22;) !== null) {
        return m.hash();
    } else if (reader.readMatch(/^\{\s*/) !== null) {
        var min = eat(/^\d+/);
        eat(/^\s*,\s*/);
        var max = eat(/^\d+/);
        eat(/^\s*\}/);
        return m.<span class="apidocCodeKeywordSpan">braces</span>(+min, +max);
    }
    return m;
};
term = function() {
    // term = &#x3c;nt&#x3e; | literal | &#x22;[ &#x22; expression &#x22; ]&#x22;
    if (reader.readMatch(&#x22;[ &#x22;) !== null) {
        var m = expr();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Matcher.prototype.constructor" id="apidoc.element.parserlib.css.Matcher.prototype.constructor">
        function <span class="apidocSignatureSpan">parserlib.css.Matcher.prototype.</span>constructor
        <span class="apidocSignatureSpan">(matchFunc, toString)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Matcher(matchFunc, toString) {
    this.match = function(expression) {
        // Save/restore marks to ensure that failed matches always restore
        // the original location in the expression.
        var result;
        expression.mark();
        result = matchFunc(expression);
        if (result) {
            expression.drop();
        } else {
            expression.restore();
        }
        return result;
    };
    this.toString = typeof toString === &#x22;function&#x22; ? toString : function() {
        return toString;
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Matcher.prototype.func" id="apidoc.element.parserlib.css.Matcher.prototype.func">
        function <span class="apidocSignatureSpan">parserlib.css.Matcher.prototype.</span>func
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">func = function () { return this.match.bind(this); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Matcher.prototype.hash" id="apidoc.element.parserlib.css.Matcher.prototype.hash">
        function <span class="apidocSignatureSpan">parserlib.css.Matcher.prototype.</span>hash
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hash = function () {
    return this.braces(1, Infinity, &#x22;#&#x22;, Matcher.cast(&#x22;,&#x22;));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (reader.readMatch(&#x22;?&#x22;) !== null) {
    return m.question();
} else if (reader.readMatch(&#x22;*&#x22;) !== null) {
    return m.star();
} else if (reader.readMatch(&#x22;+&#x22;) !== null) {
    return m.plus();
} else if (reader.readMatch(&#x22;#&#x22;) !== null) {
    return m.<span class="apidocCodeKeywordSpan">hash</span>();
} else if (reader.readMatch(/^\{\s*/) !== null) {
    var min = eat(/^\d+/);
    eat(/^\s*,\s*/);
    var max = eat(/^\d+/);
    eat(/^\s*\}/);
    return m.braces(+min, +max);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Matcher.prototype.match" id="apidoc.element.parserlib.css.Matcher.prototype.match">
        function <span class="apidocSignatureSpan">parserlib.css.Matcher.prototype.</span>match
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">match = function () { throw new Error(&#x22;unimplemented&#x22;); }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var ms = Array.prototype.slice.call(arguments).map(Matcher.cast);
if (ms.length === 1) {
    return ms[0];
}
return new Matcher(function(expression) {
    var i, result = true;
    for (i = 0; result &#x26;&#x26; i &#x3c; ms.length; i++) {
        result = ms[i].<span class="apidocCodeKeywordSpan">match</span>(expression);
    }
    return result;
}, function(prec) {
    var p = Matcher.prec.SEQ;
    var s = ms.map(function(m) {
        return m.toString(p);
    }).join(&#x22; &#x22;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Matcher.prototype.or" id="apidoc.element.parserlib.css.Matcher.prototype.or">
        function <span class="apidocSignatureSpan">parserlib.css.Matcher.prototype.</span>or
        <span class="apidocSignatureSpan">(m)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">or = function (m) { return Matcher.alt(this, m); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Matcher.prototype.oror" id="apidoc.element.parserlib.css.Matcher.prototype.oror">
        function <span class="apidocSignatureSpan">parserlib.css.Matcher.prototype.</span>oror
        <span class="apidocSignatureSpan">(m)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">oror = function (m) { return Matcher.many(false, this, m); }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        ValidationTypes.complex[nt] = Matcher.parse(rule);
    }
});

// Because this is defined relative to other complex validation types,
// we need to define it *after* the rest of the types are initialized.
ValidationTypes.complex[&#x22;&#x3c;font-variant&#x3e;&#x22;] =
    Matcher.<span class="apidocCodeKeywordSpan">oror</span>({ expand: &#x22;&#x3c;font-variant-ligatures&#x3e;&#x22; },
                 { expand: &#x22;&#x3c;font-variant-alternates&#x3e;&#x22; },
                 &#x22;&#x3c;font-variant-caps&#x3e;&#x22;,
                 { expand: &#x22;&#x3c;font-variant-numeric&#x3e;&#x22; },
                 { expand: &#x22;&#x3c;font-variant-east-asian&#x3e;&#x22; });
},{&#x22;./Matcher&#x22;:3}],22:[function(require,module,exports){
&#x22;use strict&#x22;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Matcher.prototype.plus" id="apidoc.element.parserlib.css.Matcher.prototype.plus">
        function <span class="apidocSignatureSpan">parserlib.css.Matcher.prototype.</span>plus
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">plus = function () { return this.braces(1, Infinity, &#x22;+&#x22;); }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// mod = term ( &#x22;?&#x22; | &#x22;*&#x22; | &#x22;+&#x22; | &#x22;#&#x22; | &#x22;{&#x3c;num&#x3e;,&#x3c;num&#x3e;}&#x22; )?
var m = term();
if (reader.readMatch(&#x22;?&#x22;) !== null) {
    return m.question();
} else if (reader.readMatch(&#x22;*&#x22;) !== null) {
    return m.star();
} else if (reader.readMatch(&#x22;+&#x22;) !== null) {
    return m.<span class="apidocCodeKeywordSpan">plus</span>();
} else if (reader.readMatch(&#x22;#&#x22;) !== null) {
    return m.hash();
} else if (reader.readMatch(/^\{\s*/) !== null) {
    var min = eat(/^\d+/);
    eat(/^\s*,\s*/);
    var max = eat(/^\d+/);
    eat(/^\s*\}/);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Matcher.prototype.question" id="apidoc.element.parserlib.css.Matcher.prototype.question">
        function <span class="apidocSignatureSpan">parserlib.css.Matcher.prototype.</span>question
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">question = function () { return this.braces(0, 1, &#x22;?&#x22;); }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
    return m.length === 1 ? m[0] : Matcher.seq.apply(Matcher, m);
};
mod = function() {
    // mod = term ( &#x22;?&#x22; | &#x22;*&#x22; | &#x22;+&#x22; | &#x22;#&#x22; | &#x22;{&#x3c;num&#x3e;,&#x3c;num&#x3e;}&#x22
; )?
    var m = term();
    if (reader.readMatch(&#x22;?&#x22;) !== null) {
        return m.<span class="apidocCodeKeywordSpan">question</span>();
    } else if (reader.readMatch(&#x22;*&#x22;) !== null) {
        return m.star();
    } else if (reader.readMatch(&#x22;+&#x22;) !== null) {
        return m.plus();
    } else if (reader.readMatch(&#x22;#&#x22;) !== null) {
        return m.hash();
    } else if (reader.readMatch(/^\{\s*/) !== null) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Matcher.prototype.star" id="apidoc.element.parserlib.css.Matcher.prototype.star">
        function <span class="apidocSignatureSpan">parserlib.css.Matcher.prototype.</span>star
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">star = function () { return this.braces(0, Infinity, &#x22;*&#x22;); }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};
mod = function() {
    // mod = term ( &#x22;?&#x22; | &#x22;*&#x22; | &#x22;+&#x22; | &#x22;#&#x22; | &#x22;{&#x3c;num&#x3e;,&#x3c;num&#x3e;}&#x22
; )?
    var m = term();
    if (reader.readMatch(&#x22;?&#x22;) !== null) {
        return m.question();
    } else if (reader.readMatch(&#x22;*&#x22;) !== null) {
        return m.<span class="apidocCodeKeywordSpan">star</span>();
    } else if (reader.readMatch(&#x22;+&#x22;) !== null) {
        return m.plus();
    } else if (reader.readMatch(&#x22;#&#x22;) !== null) {
        return m.hash();
    } else if (reader.readMatch(/^\{\s*/) !== null) {
        var min = eat(/^\d+/);
        eat(/^\s*,\s*/);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Matcher.prototype.then" id="apidoc.element.parserlib.css.Matcher.prototype.then">
        function <span class="apidocSignatureSpan">parserlib.css.Matcher.prototype.</span>then
        <span class="apidocSignatureSpan">(m)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">then = function (m) { return Matcher.seq(this, m); }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
star: function() { return this.braces(0, Infinity, &#x22;*&#x22;); },
plus: function() { return this.braces(1, Infinity, &#x22;+&#x22;); },
question: function() { return this.braces(0, 1, &#x22;?&#x22;); },
hash: function() {
    return this.braces(1, Infinity, &#x22;#&#x22;, Matcher.cast(&#x22;,&#x22;));
},
braces: function(min, max, marker, optSep) {
    var m1 = this, m2 = optSep ? optSep.<span class="apidocCodeKeywordSpan">then</span>(this) : this;
    if (!marker) {
        marker = &#x22;{&#x22; + min + &#x22;,&#x22; + max + &#x22;}&#x22;;
    }
    return new Matcher(function(expression) {
        var result = true, i;
        for (i = 0; i &#x3c; max; i++) {
            if (i &#x3e; 0 &#x26;&#x26; optSep) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Matcher.prototype.toString" id="apidoc.element.parserlib.css.Matcher.prototype.toString">
        function <span class="apidocSignatureSpan">parserlib.css.Matcher.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () { throw new Error(&#x22;unimplemented&#x22;); }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        for (i = 0; result &#x26;&#x26; i &#x3c; ms.length; i++) {
            result = ms[i].match(expression);
        }
        return result;
    }, function(prec) {
        var p = Matcher.prec.SEQ;
        var s = ms.map(function(m) {
            return m.<span class="apidocCodeKeywordSpan">toString</span>(p);
        }).join(&#x22; &#x22;);
        if (prec &#x3e; p) {
            s = &#x22;[ &#x22; + s + &#x22; ]&#x22;;
        }
        return s;
    });
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.parserlib.css.MediaFeature" id="apidoc.module.parserlib.css.MediaFeature">module parserlib.css.MediaFeature</a></h1>


    <h2>
        <a href="#apidoc.element.parserlib.css.MediaFeature.MediaFeature" id="apidoc.element.parserlib.css.MediaFeature.MediaFeature">
        function <span class="apidocSignatureSpan">parserlib.css.</span>MediaFeature
        <span class="apidocSignatureSpan">(name, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MediaFeature(name, value) {

    SyntaxUnit.call(this, &#x22;(&#x22; + name + (value !== null ? &#x22;:&#x22; + value : &#x22;&#x22;) + &#x22;)&#x22;, name.startLine, name.startCol, Parser.MEDIA_FEATURE_TYPE
);

    /**
     * The name of the media feature
     * @type String
     * @property name
     */
    this.name = name;

    /**
     * The value for the feature or null if there is none.
     * @type SyntaxUnit
     * @property value
     */
    this.value = value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.parserlib.css.MediaFeature.prototype" id="apidoc.module.parserlib.css.MediaFeature.prototype">module parserlib.css.MediaFeature.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.parserlib.css.MediaFeature.prototype.constructor" id="apidoc.element.parserlib.css.MediaFeature.prototype.constructor">
        function <span class="apidocSignatureSpan">parserlib.css.MediaFeature.prototype.</span>constructor
        <span class="apidocSignatureSpan">(name, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MediaFeature(name, value) {

    SyntaxUnit.call(this, &#x22;(&#x22; + name + (value !== null ? &#x22;:&#x22; + value : &#x22;&#x22;) + &#x22;)&#x22;, name.startLine, name.startCol, Parser.MEDIA_FEATURE_TYPE
);

    /**
     * The name of the media feature
     * @type String
     * @property name
     */
    this.name = name;

    /**
     * The value for the feature or null if there is none.
     * @type SyntaxUnit
     * @property value
     */
    this.value = value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.parserlib.css.MediaQuery" id="apidoc.module.parserlib.css.MediaQuery">module parserlib.css.MediaQuery</a></h1>


    <h2>
        <a href="#apidoc.element.parserlib.css.MediaQuery.MediaQuery" id="apidoc.element.parserlib.css.MediaQuery.MediaQuery">
        function <span class="apidocSignatureSpan">parserlib.css.</span>MediaQuery
        <span class="apidocSignatureSpan">(modifier, mediaType, features, line, col)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MediaQuery(modifier, mediaType, features, line, col) {

    SyntaxUnit.call(this, (modifier ? modifier + &#x22; &#x22;: &#x22;&#x22;) + (mediaType ? mediaType : &#x22;&#x22;) + (mediaType &#x26;&#x26; features.length &#x3e; 0 ? &#x22;
and &#x22; : &#x22;&#x22;) + features.join(&#x22; and &#x22;), line, col, Parser.MEDIA_QUERY_TYPE);

    /**
     * The media modifier (&#x22;not&#x22; or &#x22;only&#x22;)
     * @type String
     * @property modifier
     */
    this.modifier = modifier;

    /**
     * The mediaType (i.e., &#x22;print&#x22;)
     * @type String
     * @property mediaType
     */
    this.mediaType = mediaType;

    /**
     * The parts that make up the selector.
     * @type Array
     * @property features
     */
    this.features = features;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.parserlib.css.MediaQuery.prototype" id="apidoc.module.parserlib.css.MediaQuery.prototype">module parserlib.css.MediaQuery.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.parserlib.css.MediaQuery.prototype.constructor" id="apidoc.element.parserlib.css.MediaQuery.prototype.constructor">
        function <span class="apidocSignatureSpan">parserlib.css.MediaQuery.prototype.</span>constructor
        <span class="apidocSignatureSpan">(modifier, mediaType, features, line, col)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MediaQuery(modifier, mediaType, features, line, col) {

    SyntaxUnit.call(this, (modifier ? modifier + &#x22; &#x22;: &#x22;&#x22;) + (mediaType ? mediaType : &#x22;&#x22;) + (mediaType &#x26;&#x26; features.length &#x3e; 0 ? &#x22;
and &#x22; : &#x22;&#x22;) + features.join(&#x22; and &#x22;), line, col, Parser.MEDIA_QUERY_TYPE);

    /**
     * The media modifier (&#x22;not&#x22; or &#x22;only&#x22;)
     * @type String
     * @property modifier
     */
    this.modifier = modifier;

    /**
     * The mediaType (i.e., &#x22;print&#x22;)
     * @type String
     * @property mediaType
     */
    this.mediaType = mediaType;

    /**
     * The parts that make up the selector.
     * @type Array
     * @property features
     */
    this.features = features;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.parserlib.css.Parser" id="apidoc.module.parserlib.css.Parser">module parserlib.css.Parser</a></h1>


    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.Parser" id="apidoc.element.parserlib.css.Parser.Parser">
        function <span class="apidocSignatureSpan">parserlib.css.</span>Parser
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parser(options) {

    //inherit event functionality
    EventTarget.call(this);


    this.options = options || {};

    this._tokenStream = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

You can use the CSS parser in a `Node.js` script via the standard
`npm` package manager as the `parserlib` package (`npm install parserlib`):

```js
var parserlib = require(&#x22;parserlib&#x22;);

var parser = new parserlib.css.<span class="apidocCodeKeywordSpan">Parser</span>();
```

Alternatively, you can copy a single file version of the parser from
`dist/node-parserlib.js` to your own project, and use it as follows:

```js
var parserlib = require(&#x22;./node-parserlib&#x22;);
...</pre></li>
    </ul>






















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.parserlib.css.Parser.prototype" id="apidoc.module.parserlib.css.Parser.prototype">module parserlib.css.Parser.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._attrib" id="apidoc.element.parserlib.css.Parser.prototype._attrib">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_attrib
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_attrib = function () {
    /*
     * attrib
     *   : &#x27;[&#x27; S* [ namespace_prefix ]? IDENT S*
     *         [ [ PREFIXMATCH |
     *             SUFFIXMATCH |
     *             SUBSTRINGMATCH |
     *             &#x27;=&#x27; |
     *             INCLUDES |
     *             DASHMATCH ] S* [ IDENT | STRING ] S*
     *         ]? &#x27;]&#x27;
     *   ;
     */

    var tokenStream = this._tokenStream,
        value       = null,
        ns,
        token;

    if (tokenStream.match(Tokens.LBRACKET)) {
        token = tokenStream.token();
        value = token.value;
        value += this._readWhitespace();

        ns = this._namespace_prefix();

        if (ns) {
            value += ns;
        }

        tokenStream.mustMatch(Tokens.IDENT);
        value += tokenStream.token().value;
        value += this._readWhitespace();

        if (tokenStream.match([Tokens.PREFIXMATCH, Tokens.SUFFIXMATCH, Tokens.SUBSTRINGMATCH,
                Tokens.EQUALS, Tokens.INCLUDES, Tokens.DASHMATCH])) {

            value += tokenStream.token().value;
            value += this._readWhitespace();

            tokenStream.mustMatch([Tokens.IDENT, Tokens.STRING]);
            value += tokenStream.token().value;
            value += this._readWhitespace();
        }

        tokenStream.mustMatch(Tokens.RBRACKET);

        return new SelectorSubPart(value + &#x22;]&#x22;, &#x22;attribute&#x22;, token.startLine, token.startCol);
    } else {
        return null;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._charset" id="apidoc.element.parserlib.css.Parser.prototype._charset">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_charset
        <span class="apidocSignatureSpan">(emit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_charset = function (emit) {
    var tokenStream = this._tokenStream,
        charset,
        token,
        line,
        col;

    if (tokenStream.match(Tokens.CHARSET_SYM)) {
        line = tokenStream.token().startLine;
        col = tokenStream.token().startCol;

        this._readWhitespace();
        tokenStream.mustMatch(Tokens.STRING);

        token = tokenStream.token();
        charset = token.value;

        this._readWhitespace();
        tokenStream.mustMatch(Tokens.SEMICOLON);

        if (emit !== false) {
            this.fire({
                type:   &#x22;charset&#x22;,
                charset:charset,
                line:   line,
                col:    col
            });
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    count,
    token,
    tt;

this.fire(&#x22;startstylesheet&#x22;);

//try to read character set
this.<span class="apidocCodeKeywordSpan">_charset</span>();

this._skipCruft();

//try to read imports - may be more than one
while (tokenStream.peek() === Tokens.IMPORT_SYM) {
    this._import();
    this._skipCruft();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._class" id="apidoc.element.parserlib.css.Parser.prototype._class">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_class
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_class = function () {
    /*
     * class
     *   : &#x27;.&#x27; IDENT
     *   ;
     */

    var tokenStream = this._tokenStream,
        token;

    if (tokenStream.match(Tokens.DOT)) {
        tokenStream.mustMatch(Tokens.IDENT);
        token = tokenStream.token();
        return new SelectorSubPart(&#x22;.&#x22; + token.value, &#x22;class&#x22;, token.startLine, token.startCol - 1);
    } else {
        return null;
    }

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._combinator" id="apidoc.element.parserlib.css.Parser.prototype._combinator">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_combinator
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_combinator = function () {

    /*
     * combinator
     *  : PLUS S* | GREATER S* | TILDE S* | S+
     *  ;
     */

    var tokenStream = this._tokenStream,
        value       = null,
        token;

    if (tokenStream.match([Tokens.PLUS, Tokens.GREATER, Tokens.TILDE])) {
        token = tokenStream.token();
        value = new Combinator(token.value, token.startLine, token.startCol);
        this._readWhitespace();
    }

    return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                }

                selector.push(nextSelector);

                do {

                    //look for a combinator
                    combinator = this.<span class="apidocCodeKeywordSpan">_combinator</span>();

                    if (combinator !== null) {
selector.push(combinator);
nextSelector = this._simple_selector_sequence();

//there must be a next selector
if (nextSelector === null) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._declaration" id="apidoc.element.parserlib.css.Parser.prototype._declaration">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_declaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_declaration = function () {

    /*
     * declaration
     *   : property &#x27;:&#x27; S* expr prio?
     *   | /( empty )/
     *   ;
     */

    var tokenStream = this._tokenStream,
        property    = null,
        expr        = null,
        prio        = null,
        invalid     = null,
        propertyName= &#x22;&#x22;;

    property = this._property();
    if (property !== null) {

        tokenStream.mustMatch(Tokens.COLON);
        this._readWhitespace();

        expr = this._expr();

        //if there&#x27;s no parts for the value, it&#x27;s an error
        if (!expr || expr.length === 0) {
            this._unexpectedToken(tokenStream.LT(1));
        }

        prio = this._prio();

        /*
         * If hacks should be allowed, then only check the root
         * property. If hacks should not be allowed, treat
         * _property or *property as invalid properties.
         */
        propertyName = property.toString();
        if (this.options.starHack &#x26;&#x26; property.hack === &#x22;*&#x22; ||
                this.options.underscoreHack &#x26;&#x26; property.hack === &#x22;_&#x22;) {

            propertyName = property.text;
        }

        try {
            this._validateProperty(propertyName, expr);
        } catch (ex) {
            invalid = ex;
        }

        this.fire({
            type:       &#x22;property&#x22;,
            property:   property,
            value:      expr,
            important:  prio,
            line:       property.line,
            col:        property.col,
            invalid:    invalid
        });

        return true;
    } else {
        return false;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     */
    var tokenStream = this._tokenStream;

    if (requireStartParen !== false) {
        tokenStream.mustMatch(Tokens.LPAREN);
    }
    this._readWhitespace();
    this.<span class="apidocCodeKeywordSpan">_declaration</span>();
    tokenStream.mustMatch(Tokens.RPAREN);
},

_media: function() {
    /*
     * media
     *   : MEDIA_SYM S* media_query_list S* &#x27;{&#x27; S* ruleset* &#x27;}&#x27; S*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._document" id="apidoc.element.parserlib.css.Parser.prototype._document">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_document
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_document = function () {
    /*
     * document
     *   : DOCUMENT_SYM S*
     *     _document_function [ &#x27;,&#x27; S* _document_function ]* S*
     *     &#x27;{&#x27; S* ruleset* &#x27;}&#x27;
     *   ;
     */

    var tokenStream = this._tokenStream,
        token,
        functions = [],
        prefix = &#x22;&#x22;;

    tokenStream.mustMatch(Tokens.DOCUMENT_SYM);
    token = tokenStream.token();
    if (/^@\-([^\-]+)\-/.test(token.value)) {
        prefix = RegExp.$1;
    }

    this._readWhitespace();
    functions.push(this._document_function());

    while (tokenStream.match(Tokens.COMMA)) {
        this._readWhitespace();
        functions.push(this._document_function());
    }

    tokenStream.mustMatch(Tokens.LBRACE);
    this._readWhitespace();

    this.fire({
        type:      &#x22;startdocument&#x22;,
        functions: functions,
        prefix:    prefix,
        line:      token.startLine,
        col:       token.startCol
    });

    var ok = true;
    while (ok) {
        switch (tokenStream.peek()) {
            case Tokens.PAGE_SYM:
                this._page();
                break;
            case Tokens.FONT_FACE_SYM:
                this._font_face();
                break;
            case Tokens.VIEWPORT_SYM:
                this._viewport();
                break;
            case Tokens.MEDIA_SYM:
                this._media();
                break;
            case Tokens.KEYFRAMES_SYM:
                this._keyframes();
                break;
            case Tokens.DOCUMENT_SYM:
                this._document();
                break;
            default:
                ok = Boolean(this._ruleset());
        }
    }

    tokenStream.mustMatch(Tokens.RBRACE);
    token = tokenStream.token();
    this._readWhitespace();

    this.fire({
        type:      &#x22;enddocument&#x22;,
        functions: functions,
        prefix:    prefix,
        line:      token.startLine,
        col:       token.startCol
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this._skipCruft();
    break;
case Tokens.VIEWPORT_SYM:
    this._viewport();
    this._skipCruft();
    break;
case Tokens.DOCUMENT_SYM:
    this.<span class="apidocCodeKeywordSpan">_document</span>();
    this._skipCruft();
    break;
case Tokens.SUPPORTS_SYM:
    this._supports();
    this._skipCruft();
    break;
case Tokens.UNKNOWN_SYM:  //unknown @ rule
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._document_function" id="apidoc.element.parserlib.css.Parser.prototype._document_function">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_document_function
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_document_function = function () {
    /*
     * document_function
     *   : function | URI S*
     *   ;
     */

    var tokenStream = this._tokenStream,
        value;

    if (tokenStream.match(Tokens.URI)) {
        value = tokenStream.token().value;
        this._readWhitespace();
    } else {
        value = this._function();
    }

    return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
tokenStream.mustMatch(Tokens.DOCUMENT_SYM);
token = tokenStream.token();
if (/^@\-([^\-]+)\-/.test(token.value)) {
    prefix = RegExp.$1;
}

this._readWhitespace();
functions.push(this.<span class="apidocCodeKeywordSpan">_document_function</span>());

while (tokenStream.match(Tokens.COMMA)) {
    this._readWhitespace();
    functions.push(this._document_function());
}

tokenStream.mustMatch(Tokens.LBRACE);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._element_name" id="apidoc.element.parserlib.css.Parser.prototype._element_name">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_element_name
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_element_name = function () {
    /*
     * element_name
     *   : IDENT
     *   ;
     */

    var tokenStream = this._tokenStream,
        token;

    if (tokenStream.match(Tokens.IDENT)) {
        token = tokenStream.token();
        return new SelectorSubPart(token.value, &#x22;elementName&#x22;, token.startLine, token.startCol);

    } else {
        return null;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * type_selector
 *   : [ namespace_prefix ]? element_name
 *   ;
 */

var tokenStream = this._tokenStream,
    ns          = this._namespace_prefix(),
    elementName = this.<span class="apidocCodeKeywordSpan">_element_name</span>();

if (!elementName) {
    /*
     * Need to back out the namespace that was read due to both
     * type_selector and universal reading namespace_prefix
     * first. Kind of hacky, but only way I can figure out
     * right now how to not change the grammar.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._expr" id="apidoc.element.parserlib.css.Parser.prototype._expr">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_expr
        <span class="apidocSignatureSpan">(inFunction)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_expr = function (inFunction) {
    /*
     * expr
     *   : term [ operator term ]*
     *   ;
     */

    var values      = [],
        //valueParts    = [],
        value       = null,
        operator    = null;

    value = this._term(inFunction);
    if (value !== null) {

        values.push(value);

        do {
            operator = this._operator(inFunction);

            //if there&#x27;s an operator, keep building up the value parts
            if (operator) {
                values.push(operator);
            } /*else {
                //if there&#x27;s not an operator, you have a full value
                values.push(new PropertyValue(valueParts, valueParts[0].line, valueParts[0].col));
                valueParts = [];
            }*/

            value = this._term(inFunction);

            if (value === null) {
                break;
            } else {
                values.push(value);
            }
        } while (true);
    }

    //cleanup
    /*if (valueParts.length) {
        values.push(new PropertyValue(valueParts, valueParts[0].line, valueParts[0].col));
    }*/

    return values.length &#x3e; 0 ? new PropertyValue(values, values[0].line, values[0].col) : null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

                property = this._property();
                if (property !== null) {

tokenStream.mustMatch(Tokens.COLON);
this._readWhitespace();

expr = this.<span class="apidocCodeKeywordSpan">_expr</span>();

//if there&#x27;s no parts for the value, it&#x27;s an error
if (!expr || expr.length === 0) {
    this._unexpectedToken(tokenStream.LT(1));
}

prio = this._prio();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._expression" id="apidoc.element.parserlib.css.Parser.prototype._expression">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_expression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_expression = function () {
    /*
     * expression
     *   : [ [ PLUS | &#x27;-&#x27; | DIMENSION | NUMBER | STRING | IDENT ] S* ]+
     *   ;
     */

    var tokenStream = this._tokenStream,
        value       = &#x22;&#x22;;

    while (tokenStream.match([Tokens.PLUS, Tokens.MINUS, Tokens.DIMENSION,
            Tokens.NUMBER, Tokens.STRING, Tokens.IDENT, Tokens.LENGTH,
            Tokens.FREQ, Tokens.ANGLE, Tokens.TIME,
            Tokens.RESOLUTION, Tokens.SLASH])) {

        value += tokenStream.token().value;
        value += this._readWhitespace();
    }

    return value.length ? value : null;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    feature = this._media_feature();
    this._readWhitespace();

    if (tokenStream.match(Tokens.COLON)) {
        this._readWhitespace();
        token = tokenStream.LT(1);
        expression = this.<span class="apidocCodeKeywordSpan">_expression</span>();
    }

    tokenStream.mustMatch(Tokens.RPAREN);
    this._readWhitespace();

    return new MediaFeature(feature, expression ? new SyntaxUnit(expression, token.startLine, token.startCol) : null);
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._font_face" id="apidoc.element.parserlib.css.Parser.prototype._font_face">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_font_face
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_font_face = function () {
    /*
     * font_face
     *   : FONT_FACE_SYM S*
     *     &#x27;{&#x27; S* declaration [ &#x27;;&#x27; S* declaration ]* &#x27;}&#x27; S*
     *   ;
     */
    var tokenStream = this._tokenStream,
        line,
        col;

    //look for @page
    tokenStream.mustMatch(Tokens.FONT_FACE_SYM);
    line = tokenStream.token().startLine;
    col = tokenStream.token().startCol;

    this._readWhitespace();

    this.fire({
        type:   &#x22;startfontface&#x22;,
        line:   line,
        col:    col
    });

    this._readDeclarations(true);

    this.fire({
        type:   &#x22;endfontface&#x22;,
        line:   line,
        col:    col
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this._skipCruft();
    break;
case Tokens.PAGE_SYM:
    this._page();
    this._skipCruft();
    break;
case Tokens.FONT_FACE_SYM:
    this.<span class="apidocCodeKeywordSpan">_font_face</span>();
    this._skipCruft();
    break;
case Tokens.KEYFRAMES_SYM:
    this._keyframes();
    this._skipCruft();
    break;
case Tokens.VIEWPORT_SYM:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._function" id="apidoc.element.parserlib.css.Parser.prototype._function">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_function
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_function = function () {

    /*
     * function
     *   : FUNCTION S* expr &#x27;)&#x27; S*
     *   ;
     */

    var tokenStream = this._tokenStream,
        functionText = null,
        expr        = null,
        lt;

    if (tokenStream.match(Tokens.FUNCTION)) {
        functionText = tokenStream.token().value;
        this._readWhitespace();
        expr = this._expr(true);
        functionText += expr;

        //START: Horrible hack in case it&#x27;s an IE filter
        if (this.options.ieFilters &#x26;&#x26; tokenStream.peek() === Tokens.EQUALS) {
            do {

                if (this._readWhitespace()) {
                    functionText += tokenStream.token().value;
                }

                //might be second time in the loop
                if (tokenStream.LA(0) === Tokens.COMMA) {
                    functionText += tokenStream.token().value;
                }

                tokenStream.match(Tokens.IDENT);
                functionText += tokenStream.token().value;

                tokenStream.match(Tokens.EQUALS);
                functionText += tokenStream.token().value;

                //functionText += this._term();
                lt = tokenStream.peek();
                while (lt !== Tokens.COMMA &#x26;&#x26; lt !== Tokens.S &#x26;&#x26; lt !== Tokens.RPAREN) {
                    tokenStream.get();
                    functionText += tokenStream.token().value;
                    lt = tokenStream.peek();
                }
            } while (tokenStream.match([Tokens.COMMA, Tokens.S]));
        }

        //END: Horrible Hack

        tokenStream.match(Tokens.RPAREN);
        functionText += &#x22;)&#x22;;
        this._readWhitespace();
    }

    return functionText;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var tokenStream = this._tokenStream,
        value;

    if (tokenStream.match(Tokens.URI)) {
        value = tokenStream.token().value;
        this._readWhitespace();
    } else {
        value = this.<span class="apidocCodeKeywordSpan">_function</span>();
    }

    return value;
},

_operator: function(inFunction) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._functional_pseudo" id="apidoc.element.parserlib.css.Parser.prototype._functional_pseudo">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_functional_pseudo
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_functional_pseudo = function () {
    /*
     * functional_pseudo
     *   : FUNCTION S* expression &#x27;)&#x27;
     *   ;
    */

    var tokenStream = this._tokenStream,
        value = null;

    if (tokenStream.match(Tokens.FUNCTION)) {
        value = tokenStream.token().value;
        value += this._readWhitespace();
        value += this._expression();
        tokenStream.mustMatch(Tokens.RPAREN);
        value += &#x22;)&#x22;;
    }

    return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (tokenStream.match(Tokens.IDENT)) {
    pseudo = tokenStream.token().value;
    line = tokenStream.token().startLine;
    col = tokenStream.token().startCol - colons.length;
} else if (tokenStream.peek() === Tokens.FUNCTION) {
    line = tokenStream.LT(1).startLine;
    col = tokenStream.LT(1).startCol - colons.length;
    pseudo = this.<span class="apidocCodeKeywordSpan">_functional_pseudo</span>();
}

if (pseudo) {
    pseudo = new SelectorSubPart(colons + pseudo, &#x22;pseudo&#x22;, line, col);
} else {
    var startLine = tokenStream.LT(1).startLine,
        startCol  = tokenStream.LT(0).startCol;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._hexcolor" id="apidoc.element.parserlib.css.Parser.prototype._hexcolor">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_hexcolor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_hexcolor = function () {
    /*
     * There is a constraint on the color that it must
     * have either 3 or 6 hex-digits (i.e., [0-9a-fA-F])
     * after the &#x22;#&#x22;; e.g., &#x22;#000&#x22; is OK, but &#x22;#abcd&#x22; is not.
     *
     * hexcolor
     *   : HASH S*
     *   ;
     */

    var tokenStream = this._tokenStream,
        token = null,
        color;

    if (tokenStream.match(Tokens.HASH)) {

        //need to do some validation here

        token = tokenStream.token();
        color = token.value;
        if (!/#[a-f0-9]{3,6}/i.test(color)) {
            throw new SyntaxError(&#x22;Expected a hex color but found &#x27;&#x22; + color + &#x22;&#x27; at line &#x22; + token.startLine + &#x22;, col &#x22; + token
.startCol + &#x22;.&#x22;, token.startLine, token.startCol);
        }
        this._readWhitespace();
    }

    return token;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// PropertyValuePart constructor.
part = PropertyValuePart.fromToken(tokenStream.token());
                    }
                    this._readWhitespace();
                } else {

                    //see if it&#x27;s a color
                    token = this.<span class="apidocCodeKeywordSpan">_hexcolor</span>();
                    if (token === null) {

//if there&#x27;s no unary, get the start of the next token for line/col info
if (unary === null) {
    line = tokenStream.LT(1).startLine;
    col = tokenStream.LT(1).startCol;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._ie_function" id="apidoc.element.parserlib.css.Parser.prototype._ie_function">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_ie_function
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_ie_function = function () {

    /* (My own extension)
     * ie_function
     *   : IE_FUNCTION S* IDENT &#x27;=&#x27; term [S* &#x27;,&#x27;? IDENT &#x27;=&#x27; term]+ &#x27;)&#x27; S*
     *   ;
     */

    var tokenStream = this._tokenStream,
        functionText = null,
        lt;

    //IE function can begin like a regular function, too
    if (tokenStream.match([Tokens.IE_FUNCTION, Tokens.FUNCTION])) {
        functionText = tokenStream.token().value;

        do {

            if (this._readWhitespace()) {
                functionText += tokenStream.token().value;
            }

            //might be second time in the loop
            if (tokenStream.LA(0) === Tokens.COMMA) {
                functionText += tokenStream.token().value;
            }

            tokenStream.match(Tokens.IDENT);
            functionText += tokenStream.token().value;

            tokenStream.match(Tokens.EQUALS);
            functionText += tokenStream.token().value;

            //functionText += this._term();
            lt = tokenStream.peek();
            while (lt !== Tokens.COMMA &#x26;&#x26; lt !== Tokens.S &#x26;&#x26; lt !== Tokens.RPAREN) {
                tokenStream.get();
                functionText += tokenStream.token().value;
                lt = tokenStream.peek();
            }
        } while (tokenStream.match([Tokens.COMMA, Tokens.S]));

        tokenStream.match(Tokens.RPAREN);
        functionText += &#x22;)&#x22;;
        this._readWhitespace();
    }

    return functionText;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    line = tokenStream.token().startLine;
    col = tokenStream.token().startCol;
}

//exception for IE filters
if (tokenStream.peek() === Tokens.IE_FUNCTION &#x26;&#x26; this.options.ieFilters) {

    value = this.<span class="apidocCodeKeywordSpan">_ie_function</span>();
    if (unary === null) {
        line = tokenStream.token().startLine;
        col = tokenStream.token().startCol;
    }

//see if it&#x27;s a simple block
} else if (inFunction &#x26;&#x26; tokenStream.match([Tokens.LPAREN, Tokens.LBRACE, Tokens.LBRACKET])) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._import" id="apidoc.element.parserlib.css.Parser.prototype._import">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_import
        <span class="apidocSignatureSpan">(emit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_import = function (emit) {
    /*
     * import
     *   : IMPORT_SYM S*
     *    [STRING|URI] S* media_query_list? &#x27;;&#x27; S*
     */

    var tokenStream = this._tokenStream,
        uri,
        importToken,
        mediaList   = [];

    //read import symbol
    tokenStream.mustMatch(Tokens.IMPORT_SYM);
    importToken = tokenStream.token();
    this._readWhitespace();

    tokenStream.mustMatch([Tokens.STRING, Tokens.URI]);

    //grab the URI value
    uri = tokenStream.token().value.replace(/^(?:url\()?[&#x22;&#x27;]?([^&#x22;&#x27;]+?)[&#x22;&#x27;]?\)?$/, &#x22;$1&#x22;);

    this._readWhitespace();

    mediaList = this._media_query_list();

    //must end with a semicolon
    tokenStream.mustMatch(Tokens.SEMICOLON);
    this._readWhitespace();

    if (emit !== false) {
        this.fire({
            type:   &#x22;import&#x22;,
            uri:    uri,
            media:  mediaList,
            line:   importToken.startLine,
            col:    importToken.startCol
        });
    }

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//try to read character set
this._charset();

this._skipCruft();

//try to read imports - may be more than one
while (tokenStream.peek() === Tokens.IMPORT_SYM) {
    this.<span class="apidocCodeKeywordSpan">_import</span>();
    this._skipCruft();
}

//try to read namespaces - may be more than one
while (tokenStream.peek() === Tokens.NAMESPACE_SYM) {
    this._namespace();
    this._skipCruft();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._key" id="apidoc.element.parserlib.css.Parser.prototype._key">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_key
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_key = function () {
    /*
     * There is a restriction that IDENT can be only &#x22;from&#x22; or &#x22;to&#x22;.
     *
     * key
     *   : PERCENTAGE
     *   | IDENT
     *   ;
     */

    var tokenStream = this._tokenStream,
        token;

    if (tokenStream.match(Tokens.PERCENTAGE)) {
        return SyntaxUnit.fromToken(tokenStream.token());
    } else if (tokenStream.match(Tokens.IDENT)) {
        token = tokenStream.token();

        if (/from|to/i.test(token.value)) {
            return SyntaxUnit.fromToken(token);
        }

        tokenStream.unget();
    }

    //if it gets here, there wasn&#x27;t a valid token, so time to explode
    this._unexpectedToken(tokenStream.LT(1));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *   : key [ S* &#x27;,&#x27; S* key]*
 *   ;
 */
var tokenStream = this._tokenStream,
    keyList = [];

//must be least one key
keyList.push(this.<span class="apidocCodeKeywordSpan">_key</span>());

this._readWhitespace();

while (tokenStream.match(Tokens.COMMA)) {
    this._readWhitespace();
    keyList.push(this._key());
    this._readWhitespace();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._key_list" id="apidoc.element.parserlib.css.Parser.prototype._key_list">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_key_list
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_key_list = function () {

    /*
     * key_list:
     *   : key [ S* &#x27;,&#x27; S* key]*
     *   ;
     */
    var tokenStream = this._tokenStream,
        keyList = [];

    //must be least one key
    keyList.push(this._key());

    this._readWhitespace();

    while (tokenStream.match(Tokens.COMMA)) {
        this._readWhitespace();
        keyList.push(this._key());
        this._readWhitespace();
    }

    return keyList;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/*
 * keyframe_rule:
 *   : key_list S*
 *     &#x27;{&#x27; S* declaration [ &#x27;;&#x27; S* declaration ]* &#x27;}&#x27; S*
 *   ;
 */
var keyList = this.<span class="apidocCodeKeywordSpan">_key_list</span>();

this.fire({
    type:   &#x22;startkeyframerule&#x22;,
    keys:   keyList,
    line:   keyList[0].line,
    col:    keyList[0].col
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._keyframe_name" id="apidoc.element.parserlib.css.Parser.prototype._keyframe_name">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_keyframe_name
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_keyframe_name = function () {

    /*
     * keyframe_name:
     *   : IDENT
     *   | STRING
     *   ;
     */
    var tokenStream = this._tokenStream;

    tokenStream.mustMatch([Tokens.IDENT, Tokens.STRING]);
    return SyntaxUnit.fromToken(tokenStream.token());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
tokenStream.mustMatch(Tokens.KEYFRAMES_SYM);
token = tokenStream.token();
if (/^@\-([^\-]+)\-/.test(token.value)) {
    prefix = RegExp.$1;
}

this._readWhitespace();
name = this.<span class="apidocCodeKeywordSpan">_keyframe_name</span>();

this._readWhitespace();
tokenStream.mustMatch(Tokens.LBRACE);

this.fire({
    type:   &#x22;startkeyframes&#x22;,
    name:   name,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._keyframe_rule" id="apidoc.element.parserlib.css.Parser.prototype._keyframe_rule">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_keyframe_rule
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_keyframe_rule = function () {

    /*
     * keyframe_rule:
     *   : key_list S*
     *     &#x27;{&#x27; S* declaration [ &#x27;;&#x27; S* declaration ]* &#x27;}&#x27; S*
     *   ;
     */
    var keyList = this._key_list();

    this.fire({
        type:   &#x22;startkeyframerule&#x22;,
        keys:   keyList,
        line:   keyList[0].line,
        col:    keyList[0].col
    });

    this._readDeclarations(true);

    this.fire({
        type:   &#x22;endkeyframerule&#x22;,
        keys:   keyList,
        line:   keyList[0].line,
        col:    keyList[0].col
    });

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});

this._readWhitespace();
tt = tokenStream.peek();

//check for key
while (tt === Tokens.IDENT || tt === Tokens.PERCENTAGE) {
    this.<span class="apidocCodeKeywordSpan">_keyframe_rule</span>();
    this._readWhitespace();
    tt = tokenStream.peek();
}

this.fire({
    type:   &#x22;endkeyframes&#x22;,
    name:   name,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._keyframes" id="apidoc.element.parserlib.css.Parser.prototype._keyframes">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_keyframes
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_keyframes = function () {

    /*
     * keyframes:
     *   : KEYFRAMES_SYM S* keyframe_name S* &#x27;{&#x27; S* keyframe_rule* &#x27;}&#x27; {
     *   ;
     */
    var tokenStream = this._tokenStream,
        token,
        tt,
        name,
        prefix = &#x22;&#x22;;

    tokenStream.mustMatch(Tokens.KEYFRAMES_SYM);
    token = tokenStream.token();
    if (/^@\-([^\-]+)\-/.test(token.value)) {
        prefix = RegExp.$1;
    }

    this._readWhitespace();
    name = this._keyframe_name();

    this._readWhitespace();
    tokenStream.mustMatch(Tokens.LBRACE);

    this.fire({
        type:   &#x22;startkeyframes&#x22;,
        name:   name,
        prefix: prefix,
        line:   token.startLine,
        col:    token.startCol
    });

    this._readWhitespace();
    tt = tokenStream.peek();

    //check for key
    while (tt === Tokens.IDENT || tt === Tokens.PERCENTAGE) {
        this._keyframe_rule();
        this._readWhitespace();
        tt = tokenStream.peek();
    }

    this.fire({
        type:   &#x22;endkeyframes&#x22;,
        name:   name,
        prefix: prefix,
        line:   token.startLine,
        col:    token.startCol
    });

    this._readWhitespace();
    tokenStream.mustMatch(Tokens.RBRACE);
    this._readWhitespace();

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this._skipCruft();
    break;
case Tokens.FONT_FACE_SYM:
    this._font_face();
    this._skipCruft();
    break;
case Tokens.KEYFRAMES_SYM:
    this.<span class="apidocCodeKeywordSpan">_keyframes</span>();
    this._skipCruft();
    break;
case Tokens.VIEWPORT_SYM:
    this._viewport();
    this._skipCruft();
    break;
case Tokens.DOCUMENT_SYM:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._margin" id="apidoc.element.parserlib.css.Parser.prototype._margin">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_margin
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_margin = function () {
    /*
     * margin :
     *    margin_sym S* &#x27;{&#x27; declaration [ &#x27;;&#x27; S* declaration? ]* &#x27;}&#x27; S*
     *    ;
     */
    var tokenStream = this._tokenStream,
        line,
        col,
        marginSym   = this._margin_sym();

    if (marginSym) {
        line = tokenStream.token().startLine;
        col = tokenStream.token().startCol;

        this.fire({
            type: &#x22;startpagemargin&#x22;,
            margin: marginSym,
            line:   line,
            col:    col
        });

        this._readDeclarations(true);

        this.fire({
            type: &#x22;endpagemargin&#x22;,
            margin: marginSym,
            line:   line,
            col:    col
        });
        return true;
    } else {
        return false;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

                this._readWhitespace();

                try {

                    while (true) {

if (tokenStream.match(Tokens.SEMICOLON) || (readMargins &#x26;&#x26; this.<span class="apidocCodeKeywordSpan">_margin</span>())) {
    //noop
} else if (this._declaration()) {
    if (!tokenStream.match(Tokens.SEMICOLON)) {
        break;
    }
} else {
    break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._margin_sym" id="apidoc.element.parserlib.css.Parser.prototype._margin_sym">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_margin_sym
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_margin_sym = function () {

    /*
     * margin_sym :
     *    TOPLEFTCORNER_SYM |
     *    TOPLEFT_SYM |
     *    TOPCENTER_SYM |
     *    TOPRIGHT_SYM |
     *    TOPRIGHTCORNER_SYM |
     *    BOTTOMLEFTCORNER_SYM |
     *    BOTTOMLEFT_SYM |
     *    BOTTOMCENTER_SYM |
     *    BOTTOMRIGHT_SYM |
     *    BOTTOMRIGHTCORNER_SYM |
     *    LEFTTOP_SYM |
     *    LEFTMIDDLE_SYM |
     *    LEFTBOTTOM_SYM |
     *    RIGHTTOP_SYM |
     *    RIGHTMIDDLE_SYM |
     *    RIGHTBOTTOM_SYM
     *    ;
     */

    var tokenStream = this._tokenStream;

    if (tokenStream.match([Tokens.TOPLEFTCORNER_SYM, Tokens.TOPLEFT_SYM,
            Tokens.TOPCENTER_SYM, Tokens.TOPRIGHT_SYM, Tokens.TOPRIGHTCORNER_SYM,
            Tokens.BOTTOMLEFTCORNER_SYM, Tokens.BOTTOMLEFT_SYM,
            Tokens.BOTTOMCENTER_SYM, Tokens.BOTTOMRIGHT_SYM,
            Tokens.BOTTOMRIGHTCORNER_SYM, Tokens.LEFTTOP_SYM,
            Tokens.LEFTMIDDLE_SYM, Tokens.LEFTBOTTOM_SYM, Tokens.RIGHTTOP_SYM,
            Tokens.RIGHTMIDDLE_SYM, Tokens.RIGHTBOTTOM_SYM])) {
        return SyntaxUnit.fromToken(tokenStream.token());
    } else {
        return null;
    }

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                 * margin :
                 *    margin_sym S* &#x27;{&#x27; declaration [ &#x27;;&#x27; S* declaration? ]* &#x27;}&#x27; S*
                 *    ;
                 */
                var tokenStream = this._tokenStream,
line,
col,
marginSym   = this.<span class="apidocCodeKeywordSpan">_margin_sym</span>();

                if (marginSym) {
line = tokenStream.token().startLine;
col = tokenStream.token().startCol;

this.fire({
    type: &#x22;startpagemargin&#x22;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._media" id="apidoc.element.parserlib.css.Parser.prototype._media">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_media
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_media = function () {
    /*
     * media
     *   : MEDIA_SYM S* media_query_list S* &#x27;{&#x27; S* ruleset* &#x27;}&#x27; S*
     *   ;
     */
    var tokenStream     = this._tokenStream,
        line,
        col,
        mediaList;//       = [];

    //look for @media
    tokenStream.mustMatch(Tokens.MEDIA_SYM);
    line = tokenStream.token().startLine;
    col = tokenStream.token().startCol;

    this._readWhitespace();

    mediaList = this._media_query_list();

    tokenStream.mustMatch(Tokens.LBRACE);
    this._readWhitespace();

    this.fire({
        type:   &#x22;startmedia&#x22;,
        media:  mediaList,
        line:   line,
        col:    col
    });

    while (true) {
        if (tokenStream.peek() === Tokens.PAGE_SYM) {
            this._page();
        } else if (tokenStream.peek() === Tokens.FONT_FACE_SYM) {
            this._font_face();
        } else if (tokenStream.peek() === Tokens.VIEWPORT_SYM) {
            this._viewport();
        } else if (tokenStream.peek() === Tokens.DOCUMENT_SYM) {
            this._document();
        } else if (tokenStream.peek() === Tokens.SUPPORTS_SYM) {
            this._supports();
        } else if (tokenStream.peek() === Tokens.MEDIA_SYM) {
            this._media();
        } else if (!this._ruleset()) {
            break;
        }
    }

    tokenStream.mustMatch(Tokens.RBRACE);
    this._readWhitespace();

    this.fire({
        type:   &#x22;endmedia&#x22;,
        media:  mediaList,
        line:   line,
        col:    col
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                //try to read the rest
                while (tt &#x3e; Tokens.EOF) {

                    try {

switch (tt) {
    case Tokens.MEDIA_SYM:
        this.<span class="apidocCodeKeywordSpan">_media</span>();
        this._skipCruft();
        break;
    case Tokens.PAGE_SYM:
        this._page();
        this._skipCruft();
        break;
    case Tokens.FONT_FACE_SYM:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._media_expression" id="apidoc.element.parserlib.css.Parser.prototype._media_expression">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_media_expression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_media_expression = function () {
    /*
     * expression
     *  : &#x27;(&#x27; S* media_feature S* [ &#x27;:&#x27; S* expr ]? &#x27;)&#x27; S*
     *  ;
     */
    var tokenStream = this._tokenStream,
        feature     = null,
        token,
        expression  = null;

    tokenStream.mustMatch(Tokens.LPAREN);

    feature = this._media_feature();
    this._readWhitespace();

    if (tokenStream.match(Tokens.COLON)) {
        this._readWhitespace();
        token = tokenStream.LT(1);
        expression = this._expression();
    }

    tokenStream.mustMatch(Tokens.RPAREN);
    this._readWhitespace();

    return new MediaFeature(feature, expression ? new SyntaxUnit(expression, token.startLine, token.startCol) : null);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (token === null) {
        token = tokenStream.token();
    }
} else if (tokenStream.peek() === Tokens.LPAREN) {
    if (token === null) {
        token = tokenStream.LT(1);
    }
    expressions.push(this.<span class="apidocCodeKeywordSpan">_media_expression</span>());
}

if (type === null &#x26;&#x26; expressions.length === 0) {
    return null;
} else {
    this._readWhitespace();
    while (tokenStream.match(Tokens.IDENT)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._media_feature" id="apidoc.element.parserlib.css.Parser.prototype._media_feature">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_media_feature
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_media_feature = function () {
    /*
     * media_feature
     *   : IDENT
     *   ;
     */
    var tokenStream = this._tokenStream;

    this._readWhitespace();

    tokenStream.mustMatch(Tokens.IDENT);

    return SyntaxUnit.fromToken(tokenStream.token());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//CSS3 Media Queries
_media_type: function() {
    /*
     * media_type
     *   : IDENT
     *   ;
     */
    return this.<span class="apidocCodeKeywordSpan">_media_feature</span>();
},

/**
 * Note: in CSS3 Media Queries, this is called &#x22;expression&#x22;.
 * Renamed here to avoid conflict with CSS3 Selectors
 * definition of &#x22;expression&#x22;. Also note that &#x22;expr&#x22; in the
 * grammar now maps to &#x22;expression&#x22; from CSS3 selectors.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._media_query" id="apidoc.element.parserlib.css.Parser.prototype._media_query">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_media_query
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_media_query = function () {
    /*
     * media_query
     *   : [ONLY | NOT]? S* media_type S* [ AND S* expression ]*
     *   | expression [ AND S* expression ]*
     *   ;
     */
    var tokenStream = this._tokenStream,
        type        = null,
        ident       = null,
        token       = null,
        expressions = [];

    if (tokenStream.match(Tokens.IDENT)) {
        ident = tokenStream.token().value.toLowerCase();

        //since there&#x27;s no custom tokens for these, need to manually check
        if (ident !== &#x22;only&#x22; &#x26;&#x26; ident !== &#x22;not&#x22;) {
            tokenStream.unget();
            ident = null;
        } else {
            token = tokenStream.token();
        }
    }

    this._readWhitespace();

    if (tokenStream.peek() === Tokens.IDENT) {
        type = this._media_type();
        if (token === null) {
            token = tokenStream.token();
        }
    } else if (tokenStream.peek() === Tokens.LPAREN) {
        if (token === null) {
            token = tokenStream.LT(1);
        }
        expressions.push(this._media_expression());
    }

    if (type === null &#x26;&#x26; expressions.length === 0) {
        return null;
    } else {
        this._readWhitespace();
        while (tokenStream.match(Tokens.IDENT)) {
            if (tokenStream.token().value.toLowerCase() !== &#x22;and&#x22;) {
                this._unexpectedToken(tokenStream.token());
            }

            this._readWhitespace();
            expressions.push(this._media_expression());
        }
    }

    return new MediaQuery(ident, type, expressions, token.startLine, token.startCol);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var tokenStream = this._tokenStream,
    mediaList   = [];


this._readWhitespace();

if (tokenStream.peek() === Tokens.IDENT || tokenStream.peek() === Tokens.LPAREN) {
    mediaList.push(this.<span class="apidocCodeKeywordSpan">_media_query</span>());
}

while (tokenStream.match(Tokens.COMMA)) {
    this._readWhitespace();
    mediaList.push(this._media_query());
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._media_query_list" id="apidoc.element.parserlib.css.Parser.prototype._media_query_list">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_media_query_list
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_media_query_list = function () {
    /*
     * media_query_list
     *   : S* [media_query [ &#x27;,&#x27; S* media_query ]* ]?
     *   ;
     */
    var tokenStream = this._tokenStream,
        mediaList   = [];


    this._readWhitespace();

    if (tokenStream.peek() === Tokens.IDENT || tokenStream.peek() === Tokens.LPAREN) {
        mediaList.push(this._media_query());
    }

    while (tokenStream.match(Tokens.COMMA)) {
        this._readWhitespace();
        mediaList.push(this._media_query());
    }

    return mediaList;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
tokenStream.mustMatch([Tokens.STRING, Tokens.URI]);

//grab the URI value
uri = tokenStream.token().value.replace(/^(?:url\()?[&#x22;&#x27;]?([^&#x22;&#x27;]+?)[&#x22;&#x27;]?\)?$/, &#x22;$1&#x22;);

this._readWhitespace();

mediaList = this.<span class="apidocCodeKeywordSpan">_media_query_list</span>();

//must end with a semicolon
tokenStream.mustMatch(Tokens.SEMICOLON);
this._readWhitespace();

if (emit !== false) {
    this.fire({
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._media_type" id="apidoc.element.parserlib.css.Parser.prototype._media_type">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_media_type
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_media_type = function () {
    /*
     * media_type
     *   : IDENT
     *   ;
     */
    return this._media_feature();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        token = tokenStream.token();
    }
}

this._readWhitespace();

if (tokenStream.peek() === Tokens.IDENT) {
    type = this.<span class="apidocCodeKeywordSpan">_media_type</span>();
    if (token === null) {
        token = tokenStream.token();
    }
} else if (tokenStream.peek() === Tokens.LPAREN) {
    if (token === null) {
        token = tokenStream.LT(1);
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._namespace" id="apidoc.element.parserlib.css.Parser.prototype._namespace">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_namespace
        <span class="apidocSignatureSpan">(emit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_namespace = function (emit) {
    /*
     * namespace
     *   : NAMESPACE_SYM S* [namespace_prefix S*]? [STRING|URI] S* &#x27;;&#x27; S*
     */

    var tokenStream = this._tokenStream,
        line,
        col,
        prefix,
        uri;

    //read import symbol
    tokenStream.mustMatch(Tokens.NAMESPACE_SYM);
    line = tokenStream.token().startLine;
    col = tokenStream.token().startCol;
    this._readWhitespace();

    //it&#x27;s a namespace prefix - no _namespace_prefix() method because it&#x27;s just an IDENT
    if (tokenStream.match(Tokens.IDENT)) {
        prefix = tokenStream.token().value;
        this._readWhitespace();
    }

    tokenStream.mustMatch([Tokens.STRING, Tokens.URI]);
    /*if (!tokenStream.match(Tokens.STRING)){
        tokenStream.mustMatch(Tokens.URI);
    }*/

    //grab the URI value
    uri = tokenStream.token().value.replace(/(?:url\()?[&#x22;&#x27;]([^&#x22;&#x27;]+)[&#x22;&#x27;]\)?/, &#x22;$1&#x22;);

    this._readWhitespace();

    //must end with a semicolon
    tokenStream.mustMatch(Tokens.SEMICOLON);
    this._readWhitespace();

    if (emit !== false) {
        this.fire({
            type:   &#x22;namespace&#x22;,
            prefix: prefix,
            uri:    uri,
            line:   line,
            col:    col
        });
    }

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
while (tokenStream.peek() === Tokens.IMPORT_SYM) {
    this._import();
    this._skipCruft();
}

//try to read namespaces - may be more than one
while (tokenStream.peek() === Tokens.NAMESPACE_SYM) {
    this.<span class="apidocCodeKeywordSpan">_namespace</span>();
    this._skipCruft();
}

//get the next token
tt = tokenStream.peek();

//try to read the rest
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._namespace_prefix" id="apidoc.element.parserlib.css.Parser.prototype._namespace_prefix">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_namespace_prefix
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_namespace_prefix = function () {
    /*
     * namespace_prefix
     *   : [ IDENT | &#x27;*&#x27; ]? &#x27;|&#x27;
     *   ;
     */
    var tokenStream = this._tokenStream,
        value       = &#x22;&#x22;;

    //verify that this is a namespace prefix
    if (tokenStream.LA(1) === Tokens.PIPE || tokenStream.LA(2) === Tokens.PIPE) {

        if (tokenStream.match([Tokens.IDENT, Tokens.STAR])) {
            value += tokenStream.token().value;
        }

        tokenStream.mustMatch(Tokens.PIPE);
        value += &#x22;|&#x22;;

    }

    return value.length ? value : null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/*
 * type_selector
 *   : [ namespace_prefix ]? element_name
 *   ;
 */

var tokenStream = this._tokenStream,
    ns          = this.<span class="apidocCodeKeywordSpan">_namespace_prefix</span>(),
    elementName = this._element_name();

if (!elementName) {
    /*
     * Need to back out the namespace that was read due to both
     * type_selector and universal reading namespace_prefix
     * first. Kind of hacky, but only way I can figure out
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._negation" id="apidoc.element.parserlib.css.Parser.prototype._negation">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_negation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_negation = function () {
    /*
     * negation
     *   : NOT S* negation_arg S* &#x27;)&#x27;
     *   ;
     */

    var tokenStream = this._tokenStream,
        line,
        col,
        value       = &#x22;&#x22;,
        arg,
        subpart     = null;

    if (tokenStream.match(Tokens.NOT)) {
        value = tokenStream.token().value;
        line = tokenStream.token().startLine;
        col = tokenStream.token().startCol;
        value += this._readWhitespace();
        arg = this._negation_arg();
        value += arg;
        value += this._readWhitespace();
        tokenStream.match(Tokens.RPAREN);
        value += tokenStream.token().value;

        subpart = new SelectorSubPart(value, &#x22;not&#x22;, line, col);
        subpart.args.push(arg);
    }

    return subpart;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._negation_arg" id="apidoc.element.parserlib.css.Parser.prototype._negation_arg">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_negation_arg
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_negation_arg = function () {
    /*
     * negation_arg
     *   : type_selector | universal | HASH | class | attrib | pseudo
     *   ;
     */

    var tokenStream = this._tokenStream,
        args        = [
            this._type_selector,
            this._universal,
            function() {
                return tokenStream.match(Tokens.HASH) ?
                        new SelectorSubPart(tokenStream.token().value, &#x22;id&#x22;, tokenStream.token().startLine, tokenStream.token().
startCol) :
                        null;
            },
            this._class,
            this._attrib,
            this._pseudo
        ],
        arg         = null,
        i           = 0,
        len         = args.length,
        line,
        col,
        part;

    line = tokenStream.LT(1).startLine;
    col = tokenStream.LT(1).startCol;

    while (i &#x3c; len &#x26;&#x26; arg === null) {

        arg = args[i].call(this);
        i++;
    }

    //must be a negation arg
    if (arg === null) {
        this._unexpectedToken(tokenStream.LT(1));
    }

    //it&#x27;s an element name
    if (arg.type === &#x22;elementName&#x22;) {
        part = new SelectorPart(arg, [], arg.toString(), line, col);
    } else {
        part = new SelectorPart(null, [arg], arg.toString(), line, col);
    }

    return part;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
subpart     = null;

                if (tokenStream.match(Tokens.NOT)) {
value = tokenStream.token().value;
line = tokenStream.token().startLine;
col = tokenStream.token().startCol;
value += this._readWhitespace();
arg = this.<span class="apidocCodeKeywordSpan">_negation_arg</span>();
value += arg;
value += this._readWhitespace();
tokenStream.match(Tokens.RPAREN);
value += tokenStream.token().value;

subpart = new SelectorSubPart(value, &#x22;not&#x22;, line, col);
subpart.args.push(arg);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._operator" id="apidoc.element.parserlib.css.Parser.prototype._operator">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_operator
        <span class="apidocSignatureSpan">(inFunction)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_operator = function (inFunction) {

    /*
     * operator (outside function)
     *  : &#x27;/&#x27; S* | &#x27;,&#x27; S* | /( empty )/
     * operator (inside function)
     *  : &#x27;/&#x27; S* | &#x27;+&#x27; S* | &#x27;*&#x27; S* | &#x27;-&#x27; S* /( empty )/
     *  ;
     */

    var tokenStream = this._tokenStream,
        token       = null;

    if (tokenStream.match([Tokens.SLASH, Tokens.COMMA]) ||
        (inFunction &#x26;&#x26; tokenStream.match([Tokens.PLUS, Tokens.STAR, Tokens.MINUS]))) {
        token =  tokenStream.token();
        this._readWhitespace();
    }
    return token ? PropertyValuePart.fromToken(token) : null;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

                value = this._term(inFunction);
                if (value !== null) {

                    values.push(value);

                    do {
operator = this.<span class="apidocCodeKeywordSpan">_operator</span>(inFunction);

//if there&#x27;s an operator, keep building up the value parts
if (operator) {
    values.push(operator);
} /*else {
    //if there&#x27;s not an operator, you have a full value
    values.push(new PropertyValue(valueParts, valueParts[0].line, valueParts[0].col));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._page" id="apidoc.element.parserlib.css.Parser.prototype._page">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_page
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_page = function () {
    /*
     * page:
     *    PAGE_SYM S* IDENT? pseudo_page? S*
     *    &#x27;{&#x27; S* [ declaration | margin ]? [ &#x27;;&#x27; S* [ declaration | margin ]? ]* &#x27;}&#x27; S*
     *    ;
     */
    var tokenStream = this._tokenStream,
        line,
        col,
        identifier  = null,
        pseudoPage  = null;

    //look for @page
    tokenStream.mustMatch(Tokens.PAGE_SYM);
    line = tokenStream.token().startLine;
    col = tokenStream.token().startCol;

    this._readWhitespace();

    if (tokenStream.match(Tokens.IDENT)) {
        identifier = tokenStream.token().value;

        //The value &#x27;auto&#x27; may not be used as a page name and MUST be treated as a syntax error.
        if (identifier.toLowerCase() === &#x22;auto&#x22;) {
            this._unexpectedToken(tokenStream.token());
        }
    }

    //see if there&#x27;s a colon upcoming
    if (tokenStream.peek() === Tokens.COLON) {
        pseudoPage = this._pseudo_page();
    }

    this._readWhitespace();

    this.fire({
        type:   &#x22;startpage&#x22;,
        id:     identifier,
        pseudo: pseudoPage,
        line:   line,
        col:    col
    });

    this._readDeclarations(true, true);

    this.fire({
        type:   &#x22;endpage&#x22;,
        id:     identifier,
        pseudo: pseudoPage,
        line:   line,
        col:    col
    });

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

                        switch (tt) {
case Tokens.MEDIA_SYM:
    this._media();
    this._skipCruft();
    break;
case Tokens.PAGE_SYM:
    this.<span class="apidocCodeKeywordSpan">_page</span>();
    this._skipCruft();
    break;
case Tokens.FONT_FACE_SYM:
    this._font_face();
    this._skipCruft();
    break;
case Tokens.KEYFRAMES_SYM:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._prio" id="apidoc.element.parserlib.css.Parser.prototype._prio">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_prio
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_prio = function () {
    /*
     * prio
     *   : IMPORTANT_SYM S*
     *   ;
     */

    var tokenStream = this._tokenStream,
        result      = tokenStream.match(Tokens.IMPORTANT_SYM);

    this._readWhitespace();
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
expr = this._expr();

//if there&#x27;s no parts for the value, it&#x27;s an error
if (!expr || expr.length === 0) {
    this._unexpectedToken(tokenStream.LT(1));
}

prio = this.<span class="apidocCodeKeywordSpan">_prio</span>();

/*
 * If hacks should be allowed, then only check the root
 * property. If hacks should not be allowed, treat
 * _property or *property as invalid properties.
 */
propertyName = property.toString();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._property" id="apidoc.element.parserlib.css.Parser.prototype._property">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_property
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_property = function () {

    /*
     * property
     *   : IDENT S*
     *   ;
     */

    var tokenStream = this._tokenStream,
        value       = null,
        hack        = null,
        tokenValue,
        token,
        line,
        col;

    //check for star hack - throws error if not allowed
    if (tokenStream.peek() === Tokens.STAR &#x26;&#x26; this.options.starHack) {
        tokenStream.get();
        token = tokenStream.token();
        hack = token.value;
        line = token.startLine;
        col = token.startCol;
    }

    if (tokenStream.match(Tokens.IDENT)) {
        token = tokenStream.token();
        tokenValue = token.value;

        //check for underscore hack - no error if not allowed because it&#x27;s valid CSS syntax
        if (tokenValue.charAt(0) === &#x22;_&#x22; &#x26;&#x26; this.options.underscoreHack) {
            hack = &#x22;_&#x22;;
            tokenValue = tokenValue.substring(1);
        }

        value = new PropertyName(tokenValue, hack, (line||token.startLine), (col||token.startCol));
        this._readWhitespace();
    }

    return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                var tokenStream = this._tokenStream,
property    = null,
expr        = null,
prio        = null,
invalid     = null,
propertyName= &#x22;&#x22;;

                property = this.<span class="apidocCodeKeywordSpan">_property</span>();
                if (property !== null) {

tokenStream.mustMatch(Tokens.COLON);
this._readWhitespace();

expr = this._expr();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._pseudo" id="apidoc.element.parserlib.css.Parser.prototype._pseudo">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_pseudo
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_pseudo = function () {

    /*
     * pseudo
     *   : &#x27;:&#x27; &#x27;:&#x27;? [ IDENT | functional_pseudo ]
     *   ;
     */

    var tokenStream = this._tokenStream,
        pseudo      = null,
        colons      = &#x22;:&#x22;,
        line,
        col;

    if (tokenStream.match(Tokens.COLON)) {

        if (tokenStream.match(Tokens.COLON)) {
            colons += &#x22;:&#x22;;
        }

        if (tokenStream.match(Tokens.IDENT)) {
            pseudo = tokenStream.token().value;
            line = tokenStream.token().startLine;
            col = tokenStream.token().startCol - colons.length;
        } else if (tokenStream.peek() === Tokens.FUNCTION) {
            line = tokenStream.LT(1).startLine;
            col = tokenStream.LT(1).startCol - colons.length;
            pseudo = this._functional_pseudo();
        }

        if (pseudo) {
            pseudo = new SelectorSubPart(colons + pseudo, &#x22;pseudo&#x22;, line, col);
        } else {
            var startLine = tokenStream.LT(1).startLine,
                startCol  = tokenStream.LT(0).startCol;
            throw new SyntaxError(&#x22;Expected a `FUNCTION` or `IDENT` after colon at line &#x22; + startLine + &#x22;, col &#x22; + startCol + &#x22;.&#x22;,
startLine, startCol);
        }
    }

    return pseudo;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._pseudo_page" id="apidoc.element.parserlib.css.Parser.prototype._pseudo_page">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_pseudo_page
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_pseudo_page = function () {
    /*
     * pseudo_page
     *   : &#x27;:&#x27; IDENT
     *   ;
     */

    var tokenStream = this._tokenStream;

    tokenStream.mustMatch(Tokens.COLON);
    tokenStream.mustMatch(Tokens.IDENT);

    //TODO: CSS3 Paged Media says only &#x22;left&#x22;, &#x22;center&#x22;, and &#x22;right&#x22; are allowed

    return tokenStream.token().value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (identifier.toLowerCase() === &#x22;auto&#x22;) {
        this._unexpectedToken(tokenStream.token());
    }
}

//see if there&#x27;s a colon upcoming
if (tokenStream.peek() === Tokens.COLON) {
    pseudoPage = this.<span class="apidocCodeKeywordSpan">_pseudo_page</span>();
}

this._readWhitespace();

this.fire({
    type:   &#x22;startpage&#x22;,
    id:     identifier,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._readDeclarations" id="apidoc.element.parserlib.css.Parser.prototype._readDeclarations">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_readDeclarations
        <span class="apidocSignatureSpan">(checkStart, readMargins)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_readDeclarations = function (checkStart, readMargins) {
    /*
     * Reads the pattern
     * S* &#x27;{&#x27; S* declaration [ &#x27;;&#x27; S* declaration ]* &#x27;}&#x27; S*
     * or
     * S* &#x27;{&#x27; S* [ declaration | margin ]? [ &#x27;;&#x27; S* [ declaration | margin ]? ]* &#x27;}&#x27; S*
     * Note that this is how it is described in CSS3 Paged Media, but is actually incorrect.
     * A semicolon is only necessary following a declaration if there&#x27;s another declaration
     * or margin afterwards.
     */
    var tokenStream = this._tokenStream,
        tt;


    this._readWhitespace();

    if (checkStart) {
        tokenStream.mustMatch(Tokens.LBRACE);
    }

    this._readWhitespace();

    try {

        while (true) {

            if (tokenStream.match(Tokens.SEMICOLON) || (readMargins &#x26;&#x26; this._margin())) {
                //noop
            } else if (this._declaration()) {
                if (!tokenStream.match(Tokens.SEMICOLON)) {
                    break;
                }
            } else {
                break;
            }

            //if ((!this._margin() &#x26;&#x26; !this._declaration()) || !tokenStream.match(Tokens.SEMICOLON)){
            //    break;
            //}
            this._readWhitespace();
        }

        tokenStream.mustMatch(Tokens.RBRACE);
        this._readWhitespace();

    } catch (ex) {
        if (ex instanceof SyntaxError &#x26;&#x26; !this.options.strict) {

            //fire error event
            this.fire({
                type:       &#x22;error&#x22;,
                error:      ex,
                message:    ex.message,
                line:       ex.line,
                col:        ex.col
            });

            //see if there&#x27;s another declaration
            tt = tokenStream.advance([Tokens.SEMICOLON, Tokens.RBRACE]);
            if (tt === Tokens.SEMICOLON) {
                //if there&#x27;s a semicolon, then there might be another declaration
                this._readDeclarations(false, readMargins);
            } else if (tt !== Tokens.RBRACE) {
                //if there&#x27;s a right brace, the rule is finished so don&#x27;t do anything
                //otherwise, rethrow the error because it wasn&#x27;t handled properly
                throw ex;
            }

        } else {
            //not a syntax error, rethrow it
            throw ex;
        }
    }

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    type:   &#x22;startpage&#x22;,
    id:     identifier,
    pseudo: pseudoPage,
    line:   line,
    col:    col
});

this.<span class="apidocCodeKeywordSpan">_readDeclarations</span>(true, true);

this.fire({
    type:   &#x22;endpage&#x22;,
    id:     identifier,
    pseudo: pseudoPage,
    line:   line,
    col:    col
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._readWhitespace" id="apidoc.element.parserlib.css.Parser.prototype._readWhitespace">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_readWhitespace
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_readWhitespace = function () {

    var tokenStream = this._tokenStream,
        ws = &#x22;&#x22;;

    while (tokenStream.match(Tokens.S)) {
        ws += tokenStream.token().value;
    }

    return ws;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

                                } else {
//not a syntax error, rethrow it
throw new SyntaxError(&#x22;Unknown @ rule.&#x22;, tokenStream.LT(0).startLine, tokenStream.LT(0).startCol);
                                }
                                break;
                            case Tokens.S:
                                this.<span class="apidocCodeKeywordSpan">_readWhitespace</span>();
                                break;
                            default:
                                if (!this._ruleset()) {

//error handling for known issues
switch (tt) {
    case Tokens.CHARSET_SYM:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._ruleset" id="apidoc.element.parserlib.css.Parser.prototype._ruleset">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_ruleset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_ruleset = function () {
    /*
     * ruleset
     *   : selectors_group
     *     &#x27;{&#x27; S* declaration? [ &#x27;;&#x27; S* declaration? ]* &#x27;}&#x27; S*
     *   ;
     */

    var tokenStream = this._tokenStream,
        tt,
        selectors;


    /*
     * Error Recovery: If even a single selector fails to parse,
     * then the entire ruleset should be thrown away.
     */
    try {
        selectors = this._selectors_group();
    } catch (ex) {
        if (ex instanceof SyntaxError &#x26;&#x26; !this.options.strict) {

            //fire error event
            this.fire({
                type:       &#x22;error&#x22;,
                error:      ex,
                message:    ex.message,
                line:       ex.line,
                col:        ex.col
            });

            //skip over everything until closing brace
            tt = tokenStream.advance([Tokens.RBRACE]);
            if (tt === Tokens.RBRACE) {
                //if there&#x27;s a right brace, the rule is finished so don&#x27;t do anything
            } else {
                //otherwise, rethrow the error because it wasn&#x27;t handled properly
                throw ex;
            }

        } else {
            //not a syntax error, rethrow it
            throw ex;
        }

        //trigger parser to continue
        return true;
    }

    //if it got here, all selectors parsed
    if (selectors) {

        this.fire({
            type:       &#x22;startrule&#x22;,
            selectors:  selectors,
            line:       selectors[0].line,
            col:        selectors[0].col
        });

        this._readDeclarations(true);

        this.fire({
            type:       &#x22;endrule&#x22;,
            selectors:  selectors,
            line:       selectors[0].line,
            col:        selectors[0].col
        });

    }

    return selectors;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
throw new SyntaxError(&#x22;Unknown @ rule.&#x22;, tokenStream.LT(0).startLine, tokenStream.LT(0).startCol);
                                }
                                break;
                            case Tokens.S:
                                this._readWhitespace();
                                break;
                            default:
                                if (!this.<span class="apidocCodeKeywordSpan">_ruleset</span>()) {

//error handling for known issues
switch (tt) {
    case Tokens.CHARSET_SYM:
        token = tokenStream.LT(1);
        this._charset(false);
        throw new SyntaxError(&#x22;@charset not allowed here.&#x22;, token.startLine, token.startCol);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._selector" id="apidoc.element.parserlib.css.Parser.prototype._selector">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_selector
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_selector = function () {
    /*
     * selector
     *   : simple_selector_sequence [ combinator simple_selector_sequence ]*
     *   ;
     */

    var tokenStream = this._tokenStream,
        selector    = [],
        nextSelector = null,
        combinator  = null,
        ws          = null;

    //if there&#x27;s no simple selector, then there&#x27;s no selector
    nextSelector = this._simple_selector_sequence();
    if (nextSelector === null) {
        return null;
    }

    selector.push(nextSelector);

    do {

        //look for a combinator
        combinator = this._combinator();

        if (combinator !== null) {
            selector.push(combinator);
            nextSelector = this._simple_selector_sequence();

            //there must be a next selector
            if (nextSelector === null) {
                this._unexpectedToken(tokenStream.LT(1));
            } else {

                //nextSelector is an instance of SelectorPart
                selector.push(nextSelector);
            }
        } else {

            //if there&#x27;s not whitespace, we&#x27;re done
            if (this._readWhitespace()) {

                //add whitespace separator
                ws = new Combinator(tokenStream.token().value, tokenStream.token().startLine, tokenStream.token().startCol);

                //combinator is not required
                combinator = this._combinator();

                //selector is required if there&#x27;s a combinator
                nextSelector = this._simple_selector_sequence();
                if (nextSelector === null) {
                    if (combinator !== null) {
                        this._unexpectedToken(tokenStream.LT(1));
                    }
                } else {

                    if (combinator !== null) {
                        selector.push(combinator);
                    } else {
                        selector.push(ws);
                    }

                    selector.push(nextSelector);
                }
            } else {
                break;
            }

        }
    } while (true);

    return new Selector(selector, selector[0].line, selector[0].col);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                 *   : selector [ COMMA S* selector ]*
                 *   ;
                 */
                var tokenStream = this._tokenStream,
selectors   = [],
selector;

                selector = this.<span class="apidocCodeKeywordSpan">_selector</span>();
                if (selector !== null) {

selectors.push(selector);
while (tokenStream.match(Tokens.COMMA)) {
    this._readWhitespace();
    selector = this._selector();
    if (selector !== null) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._selectors_group" id="apidoc.element.parserlib.css.Parser.prototype._selectors_group">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_selectors_group
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_selectors_group = function () {

    /*
     * selectors_group
     *   : selector [ COMMA S* selector ]*
     *   ;
     */
    var tokenStream = this._tokenStream,
        selectors   = [],
        selector;

    selector = this._selector();
    if (selector !== null) {

        selectors.push(selector);
        while (tokenStream.match(Tokens.COMMA)) {
            this._readWhitespace();
            selector = this._selector();
            if (selector !== null) {
                selectors.push(selector);
            } else {
                this._unexpectedToken(tokenStream.LT(1));
            }
        }
    }

    return selectors.length ? selectors : null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


                /*
                 * Error Recovery: If even a single selector fails to parse,
                 * then the entire ruleset should be thrown away.
                 */
                try {
                    selectors = this.<span class="apidocCodeKeywordSpan">_selectors_group</span>();
                } catch (ex) {
                    if (ex instanceof SyntaxError &#x26;&#x26; !this.options.strict) {

//fire error event
this.fire({
    type:       &#x22;error&#x22;,
    error:      ex,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._simple_selector_sequence" id="apidoc.element.parserlib.css.Parser.prototype._simple_selector_sequence">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_simple_selector_sequence
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_simple_selector_sequence = function () {
    /*
     * simple_selector_sequence
     *   : [ type_selector | universal ]
     *     [ HASH | class | attrib | pseudo | negation ]*
     *   | [ HASH | class | attrib | pseudo | negation ]+
     *   ;
     */

    var tokenStream = this._tokenStream,

        //parts of a simple selector
        elementName = null,
        modifiers   = [],

        //complete selector text
        selectorText= &#x22;&#x22;,

        //the different parts after the element name to search for
        components  = [
            //HASH
            function() {
                return tokenStream.match(Tokens.HASH) ?
                        new SelectorSubPart(tokenStream.token().value, &#x22;id&#x22;, tokenStream.token().startLine, tokenStream.token().
startCol) :
                        null;
            },
            this._class,
            this._attrib,
            this._pseudo,
            this._negation
        ],
        i           = 0,
        len         = components.length,
        component   = null,
        line,
        col;


    //get starting line and column for the selector
    line = tokenStream.LT(1).startLine;
    col = tokenStream.LT(1).startCol;

    elementName = this._type_selector();
    if (!elementName) {
        elementName = this._universal();
    }

    if (elementName !== null) {
        selectorText += elementName;
    }

    while (true) {

        //whitespace means we&#x27;re done
        if (tokenStream.peek() === Tokens.S) {
            break;
        }

        //check for each component
        while (i &#x3c; len &#x26;&#x26; component === null) {
            component = components[i++].call(this);
        }

        if (component === null) {

            //we don&#x27;t have a selector
            if (selectorText === &#x22;&#x22;) {
                return null;
            } else {
                break;
            }
        } else {
            i = 0;
            modifiers.push(component);
            selectorText += component.toString();
            component = null;
        }
    }


    return selectorText !== &#x22;&#x22; ?
            new SelectorPart(elementName, modifiers, selectorText, line, col) :
            null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var tokenStream = this._tokenStream,
    selector    = [],
    nextSelector = null,
    combinator  = null,
    ws          = null;

//if there&#x27;s no simple selector, then there&#x27;s no selector
nextSelector = this.<span class="apidocCodeKeywordSpan">_simple_selector_sequence</span>();
if (nextSelector === null) {
    return null;
}

selector.push(nextSelector);

do {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._skipCruft" id="apidoc.element.parserlib.css.Parser.prototype._skipCruft">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_skipCruft
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_skipCruft = function () {
    while (this._tokenStream.match([Tokens.S, Tokens.CDO, Tokens.CDC])) {
        //noop
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    tt;

this.fire(&#x22;startstylesheet&#x22;);

//try to read character set
this._charset();

this.<span class="apidocCodeKeywordSpan">_skipCruft</span>();

//try to read imports - may be more than one
while (tokenStream.peek() === Tokens.IMPORT_SYM) {
    this._import();
    this._skipCruft();
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._stylesheet" id="apidoc.element.parserlib.css.Parser.prototype._stylesheet">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_stylesheet
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_stylesheet = function () {

    /*
     * stylesheet
     *  : [ CHARSET_SYM S* STRING S* &#x27;;&#x27; ]?
     *    [S|CDO|CDC]* [ import [S|CDO|CDC]* ]*
     *    [ namespace [S|CDO|CDC]* ]*
     *    [ [ ruleset | media | page | font_face | keyframes_rule | supports_rule ] [S|CDO|CDC]* ]*
     *  ;
     */

    var tokenStream = this._tokenStream,
        count,
        token,
        tt;

    this.fire(&#x22;startstylesheet&#x22;);

    //try to read character set
    this._charset();

    this._skipCruft();

    //try to read imports - may be more than one
    while (tokenStream.peek() === Tokens.IMPORT_SYM) {
        this._import();
        this._skipCruft();
    }

    //try to read namespaces - may be more than one
    while (tokenStream.peek() === Tokens.NAMESPACE_SYM) {
        this._namespace();
        this._skipCruft();
    }

    //get the next token
    tt = tokenStream.peek();

    //try to read the rest
    while (tt &#x3e; Tokens.EOF) {

        try {

            switch (tt) {
                case Tokens.MEDIA_SYM:
                    this._media();
                    this._skipCruft();
                    break;
                case Tokens.PAGE_SYM:
                    this._page();
                    this._skipCruft();
                    break;
                case Tokens.FONT_FACE_SYM:
                    this._font_face();
                    this._skipCruft();
                    break;
                case Tokens.KEYFRAMES_SYM:
                    this._keyframes();
                    this._skipCruft();
                    break;
                case Tokens.VIEWPORT_SYM:
                    this._viewport();
                    this._skipCruft();
                    break;
                case Tokens.DOCUMENT_SYM:
                    this._document();
                    this._skipCruft();
                    break;
                case Tokens.SUPPORTS_SYM:
                    this._supports();
                    this._skipCruft();
                    break;
                case Tokens.UNKNOWN_SYM:  //unknown @ rule
                    tokenStream.get();
                    if (!this.options.strict) {

                        //fire error event
                        this.fire({
                            type:       &#x22;error&#x22;,
                            error:      null,
                            message:    &#x22;Unknown @ rule: &#x22; + tokenStream.LT(0).value + &#x22;.&#x22;,
                            line:       tokenStream.LT(0).startLine,
                            col:        tokenStream.LT(0).startCol
                        });

                        //skip braces
                        count=0;
                        while (tokenStream.advance([Tokens.LBRACE, Tokens.RBRACE]) === Tokens.LBRACE) {
                            count++;    //keep track of nesting depth
                        }

                        while (count) {
                            tokenStream.advance([Tokens.RBRACE]);
                            count--;
                        }

                    } else {
                        //not a syntax error, rethrow it
                        throw new SyntaxError(&#x22;Unknown @ rule.&#x22;, tokenStream.LT(0).startLine, tokenStream.LT(0).startCol);
                    }
                    break;
                case Tokens.S:
                    this._readWhitespace();
                    break;
                default:
                    if (!this._ruleset()) {

                        //error handling for known issues
                        switch (tt) {
                            case Tokens.CHARSET_SYM:
                                token = tokenStream.LT(1);
                                this._charset(false);
                                throw new SyntaxError(&#x22;@charset not allowed here.&#x22;, token.startLine, token.startCol);
                            case Tokens.IMPORT_SYM:
                                token = tokenStream.LT(1);
                                this._import(false); ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

//-----------------------------------------------------------------
// Parsing methods
//-----------------------------------------------------------------

parse: function(input) {
    this._tokenStream = new TokenStream(input, Tokens);
    this.<span class="apidocCodeKeywordSpan">_stylesheet</span>();
},

parseStyleSheet: function(input) {
    //just passthrough
    return this.parse(input);
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._supports" id="apidoc.element.parserlib.css.Parser.prototype._supports">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_supports
        <span class="apidocSignatureSpan">(emit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_supports = function (emit) {
    /*
     * supports_rule
     *  : SUPPORTS_SYM S* supports_condition S* group_rule_body
     *  ;
     */
    var tokenStream = this._tokenStream,
        line,
        col;

    if (tokenStream.match(Tokens.SUPPORTS_SYM)) {
        line = tokenStream.token().startLine;
        col = tokenStream.token().startCol;

        this._readWhitespace();
        this._supports_condition();
        this._readWhitespace();

        tokenStream.mustMatch(Tokens.LBRACE);
        this._readWhitespace();

        if (emit !== false) {
            this.fire({
                type:   &#x22;startsupports&#x22;,
                line:   line,
                col:    col
            });
        }

        while (true) {
            if (!this._ruleset()) {
                break;
            }
        }

        tokenStream.mustMatch(Tokens.RBRACE);
        this._readWhitespace();

        this.fire({
            type:   &#x22;endsupports&#x22;,
            line:   line,
            col:    col
        });
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                                this._skipCruft();
                                break;
                            case Tokens.DOCUMENT_SYM:
                                this._document();
                                this._skipCruft();
                                break;
                            case Tokens.SUPPORTS_SYM:
                                this.<span class="apidocCodeKeywordSpan">_supports</span>();
                                this._skipCruft();
                                break;
                            case Tokens.UNKNOWN_SYM:  //unknown @ rule
                                tokenStream.get();
                                if (!this.options.strict) {

//fire error event
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._supports_condition" id="apidoc.element.parserlib.css.Parser.prototype._supports_condition">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_supports_condition
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_supports_condition = function () {
    /*
     * supports_condition
     *  : supports_negation | supports_conjunction | supports_disjunction |
     *    supports_condition_in_parens
     *  ;
     */
    var tokenStream = this._tokenStream,
        ident;

    if (tokenStream.match(Tokens.IDENT)) {
        ident = tokenStream.token().value.toLowerCase();

        if (ident === &#x22;not&#x22;) {
            tokenStream.mustMatch(Tokens.S);
            this._supports_condition_in_parens();
        } else {
            tokenStream.unget();
        }
    } else {
        this._supports_condition_in_parens();
        this._readWhitespace();

        while (tokenStream.peek() === Tokens.IDENT) {
            ident = tokenStream.LT(1).value.toLowerCase();
            if (ident === &#x22;and&#x22; || ident === &#x22;or&#x22;) {
                tokenStream.mustMatch(Tokens.IDENT);
                this._readWhitespace();
                this._supports_condition_in_parens();
                this._readWhitespace();
            }
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
col;

                if (tokenStream.match(Tokens.SUPPORTS_SYM)) {
line = tokenStream.token().startLine;
col = tokenStream.token().startCol;

this._readWhitespace();
this.<span class="apidocCodeKeywordSpan">_supports_condition</span>();
this._readWhitespace();

tokenStream.mustMatch(Tokens.LBRACE);
this._readWhitespace();

if (emit !== false) {
    this.fire({
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._supports_condition_in_parens" id="apidoc.element.parserlib.css.Parser.prototype._supports_condition_in_parens">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_supports_condition_in_parens
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_supports_condition_in_parens = function () {
    /*
     * supports_condition_in_parens
     *  : ( &#x27;(&#x27; S* supports_condition S* &#x27;)&#x27; ) | supports_declaration_condition |
     *    general_enclosed
     *  ;
     */
    var tokenStream = this._tokenStream,
        ident;

    if (tokenStream.match(Tokens.LPAREN)) {
        this._readWhitespace();
        if (tokenStream.match(Tokens.IDENT)) {
            // look ahead for not keyword, if not given, continue with declaration condition.
            ident = tokenStream.token().value.toLowerCase();
            if (ident === &#x22;not&#x22;) {
                this._readWhitespace();
                this._supports_condition();
                this._readWhitespace();
                tokenStream.mustMatch(Tokens.RPAREN);
            } else {
                tokenStream.unget();
                this._supports_declaration_condition(false);
            }
        } else {
            this._supports_condition();
            this._readWhitespace();
            tokenStream.mustMatch(Tokens.RPAREN);
        }
    } else {
        this._supports_declaration_condition();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    ident;

if (tokenStream.match(Tokens.IDENT)) {
    ident = tokenStream.token().value.toLowerCase();

    if (ident === &#x22;not&#x22;) {
        tokenStream.mustMatch(Tokens.S);
        this.<span class="apidocCodeKeywordSpan">_supports_condition_in_parens</span>();
    } else {
        tokenStream.unget();
    }
} else {
    this._supports_condition_in_parens();
    this._readWhitespace();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._supports_declaration_condition" id="apidoc.element.parserlib.css.Parser.prototype._supports_declaration_condition">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_supports_declaration_condition
        <span class="apidocSignatureSpan">(requireStartParen)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_supports_declaration_condition = function (requireStartParen) {
    /*
     * supports_declaration_condition
     *  : &#x27;(&#x27; S* declaration &#x27;)&#x27;
     *  ;
     */
    var tokenStream = this._tokenStream;

    if (requireStartParen !== false) {
        tokenStream.mustMatch(Tokens.LPAREN);
    }
    this._readWhitespace();
    this._declaration();
    tokenStream.mustMatch(Tokens.RPAREN);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        if (ident === &#x22;not&#x22;) {
            this._readWhitespace();
            this._supports_condition();
            this._readWhitespace();
            tokenStream.mustMatch(Tokens.RPAREN);
        } else {
            tokenStream.unget();
            this.<span class="apidocCodeKeywordSpan">_supports_declaration_condition</span>(false);
        }
    } else {
        this._supports_condition();
        this._readWhitespace();
        tokenStream.mustMatch(Tokens.RPAREN);
    }
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._term" id="apidoc.element.parserlib.css.Parser.prototype._term">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_term
        <span class="apidocSignatureSpan">(inFunction)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_term = function (inFunction) {

    /*
     * term
     *   : unary_operator?
     *     [ NUMBER S* | PERCENTAGE S* | LENGTH S* | ANGLE S* |
     *       TIME S* | FREQ S* | function | ie_function ]
     *   | STRING S* | IDENT S* | URI S* | UNICODERANGE S* | hexcolor
     *   ;
     */

    var tokenStream = this._tokenStream,
        unary       = null,
        value       = null,
        endChar     = null,
        part        = null,
        token,
        line,
        col;

    //returns the operator or null
    unary = this._unary_operator();
    if (unary !== null) {
        line = tokenStream.token().startLine;
        col = tokenStream.token().startCol;
    }

    //exception for IE filters
    if (tokenStream.peek() === Tokens.IE_FUNCTION &#x26;&#x26; this.options.ieFilters) {

        value = this._ie_function();
        if (unary === null) {
            line = tokenStream.token().startLine;
            col = tokenStream.token().startCol;
        }

    //see if it&#x27;s a simple block
    } else if (inFunction &#x26;&#x26; tokenStream.match([Tokens.LPAREN, Tokens.LBRACE, Tokens.LBRACKET])) {

        token = tokenStream.token();
        endChar = token.endChar;
        value = token.value + this._expr(inFunction).text;
        if (unary === null) {
            line = tokenStream.token().startLine;
            col = tokenStream.token().startCol;
        }
        tokenStream.mustMatch(Tokens.type(endChar));
        value += endChar;
        this._readWhitespace();

    //see if there&#x27;s a simple match
    } else if (tokenStream.match([Tokens.NUMBER, Tokens.PERCENTAGE, Tokens.LENGTH,
            Tokens.ANGLE, Tokens.TIME,
            Tokens.FREQ, Tokens.STRING, Tokens.IDENT, Tokens.URI, Tokens.UNICODE_RANGE])) {

        value = tokenStream.token().value;
        if (unary === null) {
            line = tokenStream.token().startLine;
            col = tokenStream.token().startCol;
            // Correct potentially-inaccurate IDENT parsing in
            // PropertyValuePart constructor.
            part = PropertyValuePart.fromToken(tokenStream.token());
        }
        this._readWhitespace();
    } else {

        //see if it&#x27;s a color
        token = this._hexcolor();
        if (token === null) {

            //if there&#x27;s no unary, get the start of the next token for line/col info
            if (unary === null) {
                line = tokenStream.LT(1).startLine;
                col = tokenStream.LT(1).startCol;
            }

            //has to be a function
            if (value === null) {

                /*
                 * This checks for alpha(opacity=0) style of IE
                 * functions. IE_FUNCTION only presents progid: style.
                 */
                if (tokenStream.LA(3) === Tokens.EQUALS &#x26;&#x26; this.options.ieFilters) {
                    value = this._ie_function();
                } else {
                    value = this._function();
                }
            }

            /*if (value === null) {
                return null;
                //throw new Error(&#x22;Expected identifier at line &#x22; + tokenStream.token().startLine + &#x22;, character &#x22; +  tokenStream
.token().startCol + &#x22;.&#x22;);
            }*/

        } else {
            value = token.value;
            if (unary === null) {
                line = token.startLine;
                col = token.startCol;
            }
        }

    }

    return part !== null ? part : value !== null ?
            new PropertyValuePart(unary !== null ? unary + value : value, line, col) :
            null;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                 */

                var values      = [],
//valueParts    = [],
value       = null,
operator    = null;

                value = this.<span class="apidocCodeKeywordSpan">_term</span>(inFunction);
                if (value !== null) {

values.push(value);

do {
    operator = this._operator(inFunction);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._type_selector" id="apidoc.element.parserlib.css.Parser.prototype._type_selector">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_type_selector
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_type_selector = function () {
    /*
     * type_selector
     *   : [ namespace_prefix ]? element_name
     *   ;
     */

    var tokenStream = this._tokenStream,
        ns          = this._namespace_prefix(),
        elementName = this._element_name();

    if (!elementName) {
        /*
         * Need to back out the namespace that was read due to both
         * type_selector and universal reading namespace_prefix
         * first. Kind of hacky, but only way I can figure out
         * right now how to not change the grammar.
         */
        if (ns) {
            tokenStream.unget();
            if (ns.length &#x3e; 1) {
                tokenStream.unget();
            }
        }

        return null;
    } else {
        if (ns) {
            elementName.text = ns + elementName.text;
            elementName.col -= ns.length;
        }
        return elementName;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    col;


//get starting line and column for the selector
line = tokenStream.LT(1).startLine;
col = tokenStream.LT(1).startCol;

elementName = this.<span class="apidocCodeKeywordSpan">_type_selector</span>();
if (!elementName) {
    elementName = this._universal();
}

if (elementName !== null) {
    selectorText += elementName;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._unary_operator" id="apidoc.element.parserlib.css.Parser.prototype._unary_operator">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_unary_operator
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_unary_operator = function () {

    /*
     * unary_operator
     *  : &#x27;-&#x27; | &#x27;+&#x27;
     *  ;
     */

    var tokenStream = this._tokenStream;

    if (tokenStream.match([Tokens.MINUS, Tokens.PLUS])) {
        return tokenStream.token().value;
    } else {
        return null;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    endChar     = null,
    part        = null,
    token,
    line,
    col;

//returns the operator or null
unary = this.<span class="apidocCodeKeywordSpan">_unary_operator</span>();
if (unary !== null) {
    line = tokenStream.token().startLine;
    col = tokenStream.token().startCol;
}

//exception for IE filters
if (tokenStream.peek() === Tokens.IE_FUNCTION &#x26;&#x26; this.options.ieFilters) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._unexpectedToken" id="apidoc.element.parserlib.css.Parser.prototype._unexpectedToken">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_unexpectedToken
        <span class="apidocSignatureSpan">(token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_unexpectedToken = function (token) {
    throw new SyntaxError(&#x22;Unexpected token &#x27;&#x22; + token.value + &#x22;&#x27; at line &#x22; + token.startLine + &#x22;, col &#x22; + token.startCol + &#x22;.&#x22;,
token.startLine, token.startCol);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                        throw new SyntaxError(&#x22;@import not allowed here.&#x22;, token.startLine, token.startCol);
                    case Tokens.NAMESPACE_SYM:
                        token = tokenStream.LT(1);
                        this._namespace(false);
                        throw new SyntaxError(&#x22;@namespace not allowed here.&#x22;, token.startLine, token.startCol);
                    default:
                        tokenStream.get();  //get the last token
                        this.<span class="apidocCodeKeywordSpan">_unexpectedToken</span>(tokenStream.token());
                }

            }
    }
} catch (ex) {
    if (ex instanceof SyntaxError &#x26;&#x26; !this.options.strict) {
        this.fire({
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._universal" id="apidoc.element.parserlib.css.Parser.prototype._universal">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_universal
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_universal = function () {
    /*
     * universal
     *   : [ namespace_prefix ]? &#x27;*&#x27;
     *   ;
     */
    var tokenStream = this._tokenStream,
        value       = &#x22;&#x22;,
        ns;

    ns = this._namespace_prefix();
    if (ns) {
        value += ns;
    }

    if (tokenStream.match(Tokens.STAR)) {
        value += &#x22;*&#x22;;
    }

    return value.length ? value : null;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

//get starting line and column for the selector
line = tokenStream.LT(1).startLine;
col = tokenStream.LT(1).startCol;

elementName = this._type_selector();
if (!elementName) {
    elementName = this.<span class="apidocCodeKeywordSpan">_universal</span>();
}

if (elementName !== null) {
    selectorText += elementName;
}

while (true) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._validateProperty" id="apidoc.element.parserlib.css.Parser.prototype._validateProperty">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_validateProperty
        <span class="apidocSignatureSpan">(property, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_validateProperty = function (property, value) {
    Validation.validate(property, value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (this.options.starHack &#x26;&#x26; property.hack === &#x22;*&#x22; ||
        this.options.underscoreHack &#x26;&#x26; property.hack === &#x22;_&#x22;) {

    propertyName = property.text;
}

try {
    this.<span class="apidocCodeKeywordSpan">_validateProperty</span>(propertyName, expr);
} catch (ex) {
    invalid = ex;
}

this.fire({
    type:       &#x22;property&#x22;,
    property:   property,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._verifyEnd" id="apidoc.element.parserlib.css.Parser.prototype._verifyEnd">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_verifyEnd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_verifyEnd = function () {
    if (this._tokenStream.LA(1) !== Tokens.EOF) {
        this._unexpectedToken(this._tokenStream.LT(1));
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},

parseMediaQuery: function(input) {
    this._tokenStream = new TokenStream(input, Tokens);
    var result = this._media_query();

    //if there&#x27;s anything more, then it&#x27;s an invalid selector
    this.<span class="apidocCodeKeywordSpan">_verifyEnd</span>();

    //otherwise return result
    return result;
},

/**
 * Parses a property value (everything after the semicolon).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype._viewport" id="apidoc.element.parserlib.css.Parser.prototype._viewport">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>_viewport
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_viewport = function () {
    /*
     * viewport
     *   : VIEWPORT_SYM S*
     *     &#x27;{&#x27; S* declaration? [ &#x27;;&#x27; S* declaration? ]* &#x27;}&#x27; S*
     *   ;
     */
    var tokenStream = this._tokenStream,
        line,
        col;

    tokenStream.mustMatch(Tokens.VIEWPORT_SYM);
    line = tokenStream.token().startLine;
    col = tokenStream.token().startCol;

    this._readWhitespace();

    this.fire({
        type:   &#x22;startviewport&#x22;,
        line:   line,
        col:    col
    });

    this._readDeclarations(true);

    this.fire({
        type:   &#x22;endviewport&#x22;,
        line:   line,
        col:    col
    });

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this._skipCruft();
    break;
case Tokens.KEYFRAMES_SYM:
    this._keyframes();
    this._skipCruft();
    break;
case Tokens.VIEWPORT_SYM:
    this.<span class="apidocCodeKeywordSpan">_viewport</span>();
    this._skipCruft();
    break;
case Tokens.DOCUMENT_SYM:
    this._document();
    this._skipCruft();
    break;
case Tokens.SUPPORTS_SYM:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype.constructor" id="apidoc.element.parserlib.css.Parser.prototype.constructor">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>constructor
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parser(options) {

    //inherit event functionality
    EventTarget.call(this);


    this.options = options || {};

    this._tokenStream = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype.parse" id="apidoc.element.parserlib.css.Parser.prototype.parse">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>parse
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (input) {
    this._tokenStream = new TokenStream(input, Tokens);
    this._stylesheet();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
var parser = new parserlib.css.Parser({ starHack: true, underscoreHack: true });
```

You can then parse a string of CSS code by passing into the `parse()` method:

```js
parser.<span class="apidocCodeKeywordSpan">parse</span>(someCSSText);
```

The `parse()` method throws an error if a non-recoverable syntax error occurs,
otherwise it finishes silently.
This method does not return a value nor does it build up an abstract syntax
tree (AST) for you, it simply parses the CSS text and fires events at important
moments along the parse.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype.parseMediaQuery" id="apidoc.element.parserlib.css.Parser.prototype.parseMediaQuery">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>parseMediaQuery
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseMediaQuery = function (input) {
    this._tokenStream = new TokenStream(input, Tokens);
    var result = this._media_query();

    //if there&#x27;s anything more, then it&#x27;s an invalid selector
    this._verifyEnd();

    //otherwise return result
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    suite.add(new YUITest.TestCase({

        name: &#x22;Media Queries&#x22;,


        testSimpleMediaQuery: function() {
var parser = new Parser();
var result = parser.<span class="apidocCodeKeywordSpan">parseMediaQuery</span>(&#x22;print&#x22;);

Assert.isInstanceOf(MediaQuery, result, &#x22;Result should be an instance of MediaQuery.&#x22;);
Assert.areEqual(1, result.line, &#x22;Line should be 1&#x22;);
Assert.areEqual(1, result.col, &#x22;Column should be 1&#x22;);
Assert.isNull(result.modifier);
Assert.areEqual(&#x22;print&#x22;, result.mediaType);
Assert.areEqual(0, result.features.length, &#x22;Should be zero parts.&#x22;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype.parsePropertyValue" id="apidoc.element.parserlib.css.Parser.prototype.parsePropertyValue">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>parsePropertyValue
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parsePropertyValue = function (input) {

    this._tokenStream = new TokenStream(input, Tokens);
    this._readWhitespace();

    var result = this._expr();

    //okay to have a trailing white space
    this._readWhitespace();

    //if there&#x27;s anything more, then it&#x27;s an invalid selector
    this._verifyEnd();

    //otherwise return result
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    suite.add(new YUITest.TestCase({

name: &#x22;Property Values&#x22;,

testIdentifierValue: function() {
    var parser = new Parser();
    var result = parser.<span class="apidocCodeKeywordSpan">parsePropertyValue</span>(&#x22;foo&#x22;);

    Assert.isInstanceOf(parserlib.css.PropertyValue, result);
    Assert.areEqual(1, result.parts.length);
    Assert.areEqual(&#x22;identifier&#x22;, result.parts[0].type);
},

testIdentifierValue2: function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype.parseRule" id="apidoc.element.parserlib.css.Parser.prototype.parseRule">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>parseRule
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseRule = function (input) {
    this._tokenStream = new TokenStream(input, Tokens);

    //skip any leading white space
    this._readWhitespace();

    var result = this._ruleset();

    //skip any trailing white space
    this._readWhitespace();

    //if there&#x27;s anything more, then it&#x27;s an invalid selector
    this._verifyEnd();

    //otherwise return result
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    suite.add(new YUITest.TestCase({

name: &#x22;Rules&#x22;,

testRuleWithOnePartSelector: function() {
    var parser = new Parser();
    var result = parser.<span class="apidocCodeKeywordSpan">parseRule</span>(&#x22;p { color: red; }&#x22;);

    Assert.isObject(result, &#x22;Parse should have completed.&#x22;);
},

testRuleWithTwoPartSelector: function() {
    var parser = new Parser();
    var result = parser.parseRule(&#x22;p li { color: red; }&#x22;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype.parseSelector" id="apidoc.element.parserlib.css.Parser.prototype.parseSelector">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>parseSelector
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseSelector = function (input) {

    this._tokenStream = new TokenStream(input, Tokens);

    //skip any leading white space
    this._readWhitespace();

    var result = this._selector();

    //skip any trailing white space
    this._readWhitespace();

    //if there&#x27;s anything more, then it&#x27;s an invalid selector
    this._verifyEnd();

    //otherwise return result
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    suite.add(new YUITest.TestCase({

        name: &#x22;Type Selector Tests&#x22;,

        testSimpleTypeSelector: function() {
var parser = new Parser();
var result = parser.<span class="apidocCodeKeywordSpan">parseSelector</span>(&#x22;li&#x22;);

Assert.isInstanceOf(Selector, result, &#x22;Result should be an instance of Selector.&#x22;);
Assert.areEqual(Parser.SELECTOR_TYPE, result.type);
Assert.areEqual(1, result.line, &#x22;Line start should be 1&#x22;);
Assert.areEqual(1, result.col, &#x22;Column start should be 1&#x22;);
Assert.areEqual(1, result.parts.length, &#x22;Selector should have three parts.&#x22;);
Assert.isInstanceOf(SelectorPart, result.parts[0], &#x22;First part should be a SelectorPart.&#x22;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype.parseStyleAttribute" id="apidoc.element.parserlib.css.Parser.prototype.parseStyleAttribute">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>parseStyleAttribute
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseStyleAttribute = function (input) {
    input += &#x22;}&#x22;; // for error recovery in _readDeclarations()
    this._tokenStream = new TokenStream(input, Tokens);
    this._readDeclarations();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Parser.prototype.parseStyleSheet" id="apidoc.element.parserlib.css.Parser.prototype.parseStyleSheet">
        function <span class="apidocSignatureSpan">parserlib.css.Parser.prototype.</span>parseStyleSheet
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseStyleSheet = function (input) {
    //just passthrough
    return this.parse(input);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
























</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.parserlib.css.PropertyName" id="apidoc.module.parserlib.css.PropertyName">module parserlib.css.PropertyName</a></h1>


    <h2>
        <a href="#apidoc.element.parserlib.css.PropertyName.PropertyName" id="apidoc.element.parserlib.css.PropertyName.PropertyName">
        function <span class="apidocSignatureSpan">parserlib.css.</span>PropertyName
        <span class="apidocSignatureSpan">(text, hack, line, col)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PropertyName(text, hack, line, col) {

    SyntaxUnit.call(this, text, line, col, Parser.PROPERTY_NAME_TYPE);

    /**
     * The type of IE hack applied (&#x22;*&#x22;, &#x22;_&#x22;, or null).
     * @type String
     * @property hack
     */
    this.hack = hack;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.parserlib.css.PropertyName.prototype" id="apidoc.module.parserlib.css.PropertyName.prototype">module parserlib.css.PropertyName.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.parserlib.css.PropertyName.prototype.constructor" id="apidoc.element.parserlib.css.PropertyName.prototype.constructor">
        function <span class="apidocSignatureSpan">parserlib.css.PropertyName.prototype.</span>constructor
        <span class="apidocSignatureSpan">(text, hack, line, col)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PropertyName(text, hack, line, col) {

    SyntaxUnit.call(this, text, line, col, Parser.PROPERTY_NAME_TYPE);

    /**
     * The type of IE hack applied (&#x22;*&#x22;, &#x22;_&#x22;, or null).
     * @type String
     * @property hack
     */
    this.hack = hack;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.PropertyName.prototype.toString" id="apidoc.element.parserlib.css.PropertyName.prototype.toString">
        function <span class="apidocSignatureSpan">parserlib.css.PropertyName.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
    return (this.hack ? this.hack : &#x22;&#x22;) + this.text;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        for (i = 0; result &#x26;&#x26; i &#x3c; ms.length; i++) {
            result = ms[i].match(expression);
        }
        return result;
    }, function(prec) {
        var p = Matcher.prec.SEQ;
        var s = ms.map(function(m) {
            return m.<span class="apidocCodeKeywordSpan">toString</span>(p);
        }).join(&#x22; &#x22;);
        if (prec &#x3e; p) {
            s = &#x22;[ &#x22; + s + &#x22; ]&#x22;;
        }
        return s;
    });
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.parserlib.css.PropertyValue" id="apidoc.module.parserlib.css.PropertyValue">module parserlib.css.PropertyValue</a></h1>


    <h2>
        <a href="#apidoc.element.parserlib.css.PropertyValue.PropertyValue" id="apidoc.element.parserlib.css.PropertyValue.PropertyValue">
        function <span class="apidocSignatureSpan">parserlib.css.</span>PropertyValue
        <span class="apidocSignatureSpan">(parts, line, col)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PropertyValue(parts, line, col) {

    SyntaxUnit.call(this, parts.join(&#x22; &#x22;), line, col, Parser.PROPERTY_VALUE_TYPE);

    /**
     * The parts that make up the selector.
     * @type Array
     * @property parts
     */
    this.parts = parts;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.parserlib.css.PropertyValue.prototype" id="apidoc.module.parserlib.css.PropertyValue.prototype">module parserlib.css.PropertyValue.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.parserlib.css.PropertyValue.prototype.constructor" id="apidoc.element.parserlib.css.PropertyValue.prototype.constructor">
        function <span class="apidocSignatureSpan">parserlib.css.PropertyValue.prototype.</span>constructor
        <span class="apidocSignatureSpan">(parts, line, col)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PropertyValue(parts, line, col) {

    SyntaxUnit.call(this, parts.join(&#x22; &#x22;), line, col, Parser.PROPERTY_VALUE_TYPE);

    /**
     * The parts that make up the selector.
     * @type Array
     * @property parts
     */
    this.parts = parts;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.parserlib.css.PropertyValuePart" id="apidoc.module.parserlib.css.PropertyValuePart">module parserlib.css.PropertyValuePart</a></h1>


    <h2>
        <a href="#apidoc.element.parserlib.css.PropertyValuePart.PropertyValuePart" id="apidoc.element.parserlib.css.PropertyValuePart.PropertyValuePart">
        function <span class="apidocSignatureSpan">parserlib.css.</span>PropertyValuePart
        <span class="apidocSignatureSpan">(text, line, col, optionalHint)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PropertyValuePart(text, line, col, optionalHint) {
    var hint = optionalHint || {};

    SyntaxUnit.call(this, text, line, col, Parser.PROPERTY_VALUE_PART_TYPE);

    /**
     * Indicates the type of value unit.
     * @type String
     * @property type
     */
    this.type = &#x22;unknown&#x22;;

    //figure out what type of data it is

    var temp;

    //it is a measurement?
    if (/^([+\-]?[\d\.]+)([a-z]+)$/i.test(text)) {  //dimension
        this.type = &#x22;dimension&#x22;;
        this.value = +RegExp.$1;
        this.units = RegExp.$2;

        //try to narrow down
        switch (this.units.toLowerCase()) {

            case &#x22;em&#x22;:
            case &#x22;rem&#x22;:
            case &#x22;ex&#x22;:
            case &#x22;px&#x22;:
            case &#x22;cm&#x22;:
            case &#x22;mm&#x22;:
            case &#x22;in&#x22;:
            case &#x22;pt&#x22;:
            case &#x22;pc&#x22;:
            case &#x22;ch&#x22;:
            case &#x22;vh&#x22;:
            case &#x22;vw&#x22;:
            case &#x22;vmax&#x22;:
            case &#x22;vmin&#x22;:
                this.type = &#x22;length&#x22;;
                break;

            case &#x22;fr&#x22;:
                this.type = &#x22;grid&#x22;;
                break;

            case &#x22;deg&#x22;:
            case &#x22;rad&#x22;:
            case &#x22;grad&#x22;:
            case &#x22;turn&#x22;:
                this.type = &#x22;angle&#x22;;
                break;

            case &#x22;ms&#x22;:
            case &#x22;s&#x22;:
                this.type = &#x22;time&#x22;;
                break;

            case &#x22;hz&#x22;:
            case &#x22;khz&#x22;:
                this.type = &#x22;frequency&#x22;;
                break;

            case &#x22;dpi&#x22;:
            case &#x22;dpcm&#x22;:
                this.type = &#x22;resolution&#x22;;
                break;

            //default

        }

    } else if (/^([+\-]?[\d\.]+)%$/i.test(text)) {  //percentage
        this.type = &#x22;percentage&#x22;;
        this.value = +RegExp.$1;
    } else if (/^([+\-]?\d+)$/i.test(text)) {  //integer
        this.type = &#x22;integer&#x22;;
        this.value = +RegExp.$1;
    } else if (/^([+\-]?[\d\.]+)$/i.test(text)) {  //number
        this.type = &#x22;number&#x22;;
        this.value = +RegExp.$1;

    } else if (/^#([a-f0-9]{3,6})/i.test(text)) {  //hexcolor
        this.type = &#x22;color&#x22;;
        temp = RegExp.$1;
        if (temp.length === 3) {
            this.red    = parseInt(temp.charAt(0)+temp.charAt(0), 16);
            this.green  = parseInt(temp.charAt(1)+temp.charAt(1), 16);
            this.blue   = parseInt(temp.charAt(2)+temp.charAt(2), 16);
        } else {
            this.red    = parseInt(temp.substring(0, 2), 16);
            this.green  = parseInt(temp.substring(2, 4), 16);
            this.blue   = parseInt(temp.substring(4, 6), 16);
        }
    } else if (/^rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/i.test(text)) { //rgb() color with absolute numbers
        this.type   = &#x22;color&#x22;;
        this.red    = +RegExp.$1;
        this.green  = +RegExp.$2;
        this.blue   = +RegExp.$3;
    } else if (/^rgb\(\s*(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*\)/i.test(text)) { //rgb() color with percentages
        this.type   = &#x22;color&#x22;;
        this.red    = +RegExp.$1 * 255 / 100;
        this.green  = +RegExp.$2 * 255 / 100;
        this.blue   = +RegExp.$3 * 255 / 100;
    } else if (/^rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d\.]+)\s*\)/i.test(text)) { //rgba() color with absolute numbers
        this.type   = &#x22;color&#x22;;
        this.red    = +RegExp.$1;
        this.green  = +RegExp.$2;
        this.blue   = +RegExp.$3;
        this.alpha  = +RegExp.$4;
    } else if (/^rgba\(\s*(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*,\s*([\d\.]+)\s*\)/i.test(text)) { //rgba() color with percentages
        this.type   = &#x22;color&#x22;;
        this.red    = +RegExp.$1 * 255 / 100;
        this.green  = +RegExp.$2 * 255 / 100;
        this.blue   = +RegExp.$3 * 255 / 100;
        this.alpha  = +RegExp.$4;
    } else if (/^hsl\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*\)/i.test(text)) { //hsl()
        this.type   = &#x22;color&#x22;;
        this.hue    = +RegExp.$1;
        this.saturation = +RegExp.$2 / 100;
        this.lightness  = +RegExp.$3 / 100;
    } else if ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.PropertyValuePart.fromToken" id="apidoc.element.parserlib.css.PropertyValuePart.fromToken">
        function <span class="apidocSignatureSpan">parserlib.css.PropertyValuePart.</span>fromToken
        <span class="apidocSignatureSpan">(token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromToken = function (token) {
    var part = new PropertyValuePart(token.value, token.startLine, token.startCol, {
        // Tokens can have escaped characters that would fool the type
        // identification in the PropertyValuePart constructor, so pass
        // in a hint if this was an identifier.
        ident: token.type === Tokens.IDENT
    });
    return part;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     */
    var tokenStream = this._tokenStream;

    this._readWhitespace();

    tokenStream.mustMatch(Tokens.IDENT);

    return SyntaxUnit.<span class="apidocCodeKeywordSpan">fromToken</span>(tokenStream.token());
},

//CSS3 Paged Media
_page: function() {
    /*
     * page:
     *    PAGE_SYM S* IDENT? pseudo_page? S*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.PropertyValuePart.parseString" id="apidoc.element.parserlib.css.PropertyValuePart.parseString">
        function <span class="apidocSignatureSpan">parserlib.css.PropertyValuePart.</span>parseString
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseString = function (str) {
    str = str.slice(1, -1); // Strip surrounding single/double quotes
    var replacer = function(match, esc) {
        if (/^(\n|\r\n|\r|\f)$/.test(esc)) {
            return &#x22;&#x22;;
        }
        var m = /^[0-9a-f]{1,6}/i.exec(esc);
        if (m) {
            var codePoint = parseInt(m[0], 16);
            if (String.fromCodePoint) {
                return String.fromCodePoint(codePoint);
            } else {
                // XXX No support for surrogates on old JavaScript engines.
                return String.fromCharCode(codePoint);
            }
        }
        return esc;
    };
    return str.replace(/\\(\r\n|[^\r0-9a-f]|[0-9a-f]{1,6}(\r\n|[ \n\r\t\f])?)/ig,
                       replacer);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.hue    = +RegExp.$1;
    this.saturation = +RegExp.$2 / 100;
    this.lightness  = +RegExp.$3 / 100;
    this.alpha  = +RegExp.$4;
} else if (/^url\((&#x22;([^\\&#x22;]|\\.)*&#x22;)\)/i.test(text)) { //URI
    // generated by TokenStream.readURI, so always double-quoted.
    this.type   = &#x22;uri&#x22;;
    this.uri    = PropertyValuePart.<span class="apidocCodeKeywordSpan">parseString</span>(RegExp.$1);
} else if (/^([^\(]+)\(/i.test(text)) {
    this.type   = &#x22;function&#x22;;
    this.name   = RegExp.$1;
    this.value  = text;
} else if (/^&#x22;([^\n\r\f\\&#x22;]|\\\r\n|\\[^\r0-9a-f]|\\[0-9a-f]{1,6}(\r\n|[ \n\r\t\f])?)*&#x22;/i.test(text)) {    //double
-quoted string
    this.type   = &#x22;string&#x22;;
    this.value  = PropertyValuePart.parseString(text);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.PropertyValuePart.serializeString" id="apidoc.element.parserlib.css.PropertyValuePart.serializeString">
        function <span class="apidocSignatureSpan">parserlib.css.PropertyValuePart.</span>serializeString
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serializeString = function (value) {
    var replacer = function(match, c) {
        if (c === &#x22;\&#x22;&#x22;) {
            return &#x22;\\&#x22; + c;
        }
        var cp = String.codePointAt ? String.codePointAt(0) :
            // We only escape non-surrogate chars, so using charCodeAt
            // is harmless here.
            String.charCodeAt(0);
        return &#x22;\\&#x22; + cp.toString(16) + &#x22; &#x22;;
    };
    return &#x22;\&#x22;&#x22; + value.replace(/[&#x22;\r\n\f]/g, replacer) + &#x22;\&#x22;&#x22;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    //if there was no inner value or the next character isn&#x27;t closing paren, it&#x27;s not a URI
    if (inner === null || c !== &#x22;)&#x22;) {
        uri = null;
    } else {
        // Ensure argument to URL is always double-quoted
        // (This simplifies later processing in PropertyValuePart.)
        uri += PropertyValuePart.<span class="apidocCodeKeywordSpan">serializeString</span>(inner) + reader.read();
    }

    return uri;
},
// This method never fails, although it may return an empty string.
readUnquotedURL: function(first) {
    var reader  = this._reader,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.parserlib.css.PropertyValuePart.prototype" id="apidoc.module.parserlib.css.PropertyValuePart.prototype">module parserlib.css.PropertyValuePart.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.parserlib.css.PropertyValuePart.prototype.constructor" id="apidoc.element.parserlib.css.PropertyValuePart.prototype.constructor">
        function <span class="apidocSignatureSpan">parserlib.css.PropertyValuePart.prototype.</span>constructor
        <span class="apidocSignatureSpan">(text, line, col, optionalHint)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PropertyValuePart(text, line, col, optionalHint) {
    var hint = optionalHint || {};

    SyntaxUnit.call(this, text, line, col, Parser.PROPERTY_VALUE_PART_TYPE);

    /**
     * Indicates the type of value unit.
     * @type String
     * @property type
     */
    this.type = &#x22;unknown&#x22;;

    //figure out what type of data it is

    var temp;

    //it is a measurement?
    if (/^([+\-]?[\d\.]+)([a-z]+)$/i.test(text)) {  //dimension
        this.type = &#x22;dimension&#x22;;
        this.value = +RegExp.$1;
        this.units = RegExp.$2;

        //try to narrow down
        switch (this.units.toLowerCase()) {

            case &#x22;em&#x22;:
            case &#x22;rem&#x22;:
            case &#x22;ex&#x22;:
            case &#x22;px&#x22;:
            case &#x22;cm&#x22;:
            case &#x22;mm&#x22;:
            case &#x22;in&#x22;:
            case &#x22;pt&#x22;:
            case &#x22;pc&#x22;:
            case &#x22;ch&#x22;:
            case &#x22;vh&#x22;:
            case &#x22;vw&#x22;:
            case &#x22;vmax&#x22;:
            case &#x22;vmin&#x22;:
                this.type = &#x22;length&#x22;;
                break;

            case &#x22;fr&#x22;:
                this.type = &#x22;grid&#x22;;
                break;

            case &#x22;deg&#x22;:
            case &#x22;rad&#x22;:
            case &#x22;grad&#x22;:
            case &#x22;turn&#x22;:
                this.type = &#x22;angle&#x22;;
                break;

            case &#x22;ms&#x22;:
            case &#x22;s&#x22;:
                this.type = &#x22;time&#x22;;
                break;

            case &#x22;hz&#x22;:
            case &#x22;khz&#x22;:
                this.type = &#x22;frequency&#x22;;
                break;

            case &#x22;dpi&#x22;:
            case &#x22;dpcm&#x22;:
                this.type = &#x22;resolution&#x22;;
                break;

            //default

        }

    } else if (/^([+\-]?[\d\.]+)%$/i.test(text)) {  //percentage
        this.type = &#x22;percentage&#x22;;
        this.value = +RegExp.$1;
    } else if (/^([+\-]?\d+)$/i.test(text)) {  //integer
        this.type = &#x22;integer&#x22;;
        this.value = +RegExp.$1;
    } else if (/^([+\-]?[\d\.]+)$/i.test(text)) {  //number
        this.type = &#x22;number&#x22;;
        this.value = +RegExp.$1;

    } else if (/^#([a-f0-9]{3,6})/i.test(text)) {  //hexcolor
        this.type = &#x22;color&#x22;;
        temp = RegExp.$1;
        if (temp.length === 3) {
            this.red    = parseInt(temp.charAt(0)+temp.charAt(0), 16);
            this.green  = parseInt(temp.charAt(1)+temp.charAt(1), 16);
            this.blue   = parseInt(temp.charAt(2)+temp.charAt(2), 16);
        } else {
            this.red    = parseInt(temp.substring(0, 2), 16);
            this.green  = parseInt(temp.substring(2, 4), 16);
            this.blue   = parseInt(temp.substring(4, 6), 16);
        }
    } else if (/^rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/i.test(text)) { //rgb() color with absolute numbers
        this.type   = &#x22;color&#x22;;
        this.red    = +RegExp.$1;
        this.green  = +RegExp.$2;
        this.blue   = +RegExp.$3;
    } else if (/^rgb\(\s*(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*\)/i.test(text)) { //rgb() color with percentages
        this.type   = &#x22;color&#x22;;
        this.red    = +RegExp.$1 * 255 / 100;
        this.green  = +RegExp.$2 * 255 / 100;
        this.blue   = +RegExp.$3 * 255 / 100;
    } else if (/^rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d\.]+)\s*\)/i.test(text)) { //rgba() color with absolute numbers
        this.type   = &#x22;color&#x22;;
        this.red    = +RegExp.$1;
        this.green  = +RegExp.$2;
        this.blue   = +RegExp.$3;
        this.alpha  = +RegExp.$4;
    } else if (/^rgba\(\s*(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*,\s*([\d\.]+)\s*\)/i.test(text)) { //rgba() color with percentages
        this.type   = &#x22;color&#x22;;
        this.red    = +RegExp.$1 * 255 / 100;
        this.green  = +RegExp.$2 * 255 / 100;
        this.blue   = +RegExp.$3 * 255 / 100;
        this.alpha  = +RegExp.$4;
    } else if (/^hsl\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*\)/i.test(text)) { //hsl()
        this.type   = &#x22;color&#x22;;
        this.hue    = +RegExp.$1;
        this.saturation = +RegExp.$2 / 100;
        this.lightness  = +RegExp.$3 / 100;
    } else if ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.parserlib.css.Selector" id="apidoc.module.parserlib.css.Selector">module parserlib.css.Selector</a></h1>


    <h2>
        <a href="#apidoc.element.parserlib.css.Selector.Selector" id="apidoc.element.parserlib.css.Selector.Selector">
        function <span class="apidocSignatureSpan">parserlib.css.</span>Selector
        <span class="apidocSignatureSpan">(parts, line, col)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Selector(parts, line, col) {

    SyntaxUnit.call(this, parts.join(&#x22; &#x22;), line, col, Parser.SELECTOR_TYPE);

    /**
     * The parts that make up the selector.
     * @type Array
     * @property parts
     */
    this.parts = parts;

    /**
     * The specificity of the selector.
     * @type parserlib.css.Specificity
     * @property specificity
     */
    this.specificity = Specificity.calculate(this);

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.parserlib.css.Selector.prototype" id="apidoc.module.parserlib.css.Selector.prototype">module parserlib.css.Selector.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.parserlib.css.Selector.prototype.constructor" id="apidoc.element.parserlib.css.Selector.prototype.constructor">
        function <span class="apidocSignatureSpan">parserlib.css.Selector.prototype.</span>constructor
        <span class="apidocSignatureSpan">(parts, line, col)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Selector(parts, line, col) {

    SyntaxUnit.call(this, parts.join(&#x22; &#x22;), line, col, Parser.SELECTOR_TYPE);

    /**
     * The parts that make up the selector.
     * @type Array
     * @property parts
     */
    this.parts = parts;

    /**
     * The specificity of the selector.
     * @type parserlib.css.Specificity
     * @property specificity
     */
    this.specificity = Specificity.calculate(this);

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.parserlib.css.SelectorPart" id="apidoc.module.parserlib.css.SelectorPart">module parserlib.css.SelectorPart</a></h1>


    <h2>
        <a href="#apidoc.element.parserlib.css.SelectorPart.SelectorPart" id="apidoc.element.parserlib.css.SelectorPart.SelectorPart">
        function <span class="apidocSignatureSpan">parserlib.css.</span>SelectorPart
        <span class="apidocSignatureSpan">(elementName, modifiers, text, line, col)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SelectorPart(elementName, modifiers, text, line, col) {

    SyntaxUnit.call(this, text, line, col, Parser.SELECTOR_PART_TYPE);

    /**
     * The tag name of the element to which this part
     * of the selector affects.
     * @type String
     * @property elementName
     */
    this.elementName = elementName;

    /**
     * The parts that come after the element name, such as class names, IDs,
     * pseudo classes/elements, etc.
     * @type Array
     * @property modifiers
     */
    this.modifiers = modifiers;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.parserlib.css.SelectorPart.prototype" id="apidoc.module.parserlib.css.SelectorPart.prototype">module parserlib.css.SelectorPart.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.parserlib.css.SelectorPart.prototype.constructor" id="apidoc.element.parserlib.css.SelectorPart.prototype.constructor">
        function <span class="apidocSignatureSpan">parserlib.css.SelectorPart.prototype.</span>constructor
        <span class="apidocSignatureSpan">(elementName, modifiers, text, line, col)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SelectorPart(elementName, modifiers, text, line, col) {

    SyntaxUnit.call(this, text, line, col, Parser.SELECTOR_PART_TYPE);

    /**
     * The tag name of the element to which this part
     * of the selector affects.
     * @type String
     * @property elementName
     */
    this.elementName = elementName;

    /**
     * The parts that come after the element name, such as class names, IDs,
     * pseudo classes/elements, etc.
     * @type Array
     * @property modifiers
     */
    this.modifiers = modifiers;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.parserlib.css.SelectorSubPart" id="apidoc.module.parserlib.css.SelectorSubPart">module parserlib.css.SelectorSubPart</a></h1>


    <h2>
        <a href="#apidoc.element.parserlib.css.SelectorSubPart.SelectorSubPart" id="apidoc.element.parserlib.css.SelectorSubPart.SelectorSubPart">
        function <span class="apidocSignatureSpan">parserlib.css.</span>SelectorSubPart
        <span class="apidocSignatureSpan">(text, type, line, col)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SelectorSubPart(text, type, line, col) {

    SyntaxUnit.call(this, text, line, col, Parser.SELECTOR_SUB_PART_TYPE);

    /**
     * The type of modifier.
     * @type String
     * @property type
     */
    this.type = type;

    /**
     * Some subparts have arguments, this represents them.
     * @type Array
     * @property args
     */
    this.args = [];

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.parserlib.css.SelectorSubPart.prototype" id="apidoc.module.parserlib.css.SelectorSubPart.prototype">module parserlib.css.SelectorSubPart.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.parserlib.css.SelectorSubPart.prototype.constructor" id="apidoc.element.parserlib.css.SelectorSubPart.prototype.constructor">
        function <span class="apidocSignatureSpan">parserlib.css.SelectorSubPart.prototype.</span>constructor
        <span class="apidocSignatureSpan">(text, type, line, col)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SelectorSubPart(text, type, line, col) {

    SyntaxUnit.call(this, text, line, col, Parser.SELECTOR_SUB_PART_TYPE);

    /**
     * The type of modifier.
     * @type String
     * @property type
     */
    this.type = type;

    /**
     * Some subparts have arguments, this represents them.
     * @type Array
     * @property args
     */
    this.args = [];

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.parserlib.css.Specificity" id="apidoc.module.parserlib.css.Specificity">module parserlib.css.Specificity</a></h1>


    <h2>
        <a href="#apidoc.element.parserlib.css.Specificity.Specificity" id="apidoc.element.parserlib.css.Specificity.Specificity">
        function <span class="apidocSignatureSpan">parserlib.css.</span>Specificity
        <span class="apidocSignatureSpan">(a, b, c, d)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Specificity(a, b, c, d) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Specificity.calculate" id="apidoc.element.parserlib.css.Specificity.calculate">
        function <span class="apidocSignatureSpan">parserlib.css.Specificity.</span>calculate
        <span class="apidocSignatureSpan">(selector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">calculate = function (selector) {

    var i, len,
        part,
        b=0, c=0, d=0;

    function updateValues(part) {

        var i, j, len, num,
            elementName = part.elementName ? part.elementName.text : &#x22;&#x22;,
            modifier;

        if (elementName &#x26;&#x26; elementName.charAt(elementName.length-1) !== &#x22;*&#x22;) {
            d++;
        }

        for (i=0, len=part.modifiers.length; i &#x3c; len; i++) {
            modifier = part.modifiers[i];
            switch (modifier.type) {
                case &#x22;class&#x22;:
                case &#x22;attribute&#x22;:
                    c++;
                    break;

                case &#x22;id&#x22;:
                    b++;
                    break;

                case &#x22;pseudo&#x22;:
                    if (Pseudos.isElement(modifier.text)) {
                        d++;
                    } else {
                        c++;
                    }
                    break;

                case &#x22;not&#x22;:
                    for (j=0, num=modifier.args.length; j &#x3c; num; j++) {
                        updateValues(modifier.args[j]);
                    }
            }
        }
    }

    for (i=0, len=selector.parts.length; i &#x3c; len; i++) {
        part = selector.parts[i];

        if (part instanceof SelectorPart) {
            updateValues(part);
        }
    }

    return new Specificity(0, b, c, d);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.parts = parts;

    /**
     * The specificity of the selector.
     * @type parserlib.css.Specificity
     * @property specificity
     */
    this.specificity = Specificity.<span class="apidocCodeKeywordSpan">calculate</span>(this);

}

Selector.prototype = new SyntaxUnit();
Selector.prototype.constructor = Selector;

},{&#x22;../util/SyntaxUnit&#x22;:26,&#x22;./Parser&#x22;:6,&#x22;./Specificity&#x22;:16}],14:[function(require,module,exports){
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.parserlib.css.Specificity.prototype" id="apidoc.module.parserlib.css.Specificity.prototype">module parserlib.css.Specificity.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.parserlib.css.Specificity.prototype.compare" id="apidoc.element.parserlib.css.Specificity.prototype.compare">
        function <span class="apidocSignatureSpan">parserlib.css.Specificity.prototype.</span>compare
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compare = function (other) {
    var comps = [&#x22;a&#x22;, &#x22;b&#x22;, &#x22;c&#x22;, &#x22;d&#x22;],
        i, len;

    for (i=0, len=comps.length; i &#x3c; len; i++) {
        if (this[comps[i]] &#x3c; other[comps[i]]) {
            return -1;
        } else if (this[comps[i]] &#x3e; other[comps[i]]) {
            return 1;
        }
    }

    return 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Specificity.prototype.constructor" id="apidoc.element.parserlib.css.Specificity.prototype.constructor">
        function <span class="apidocSignatureSpan">parserlib.css.Specificity.prototype.</span>constructor
        <span class="apidocSignatureSpan">(a, b, c, d)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Specificity(a, b, c, d) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Specificity.prototype.toString" id="apidoc.element.parserlib.css.Specificity.prototype.toString">
        function <span class="apidocSignatureSpan">parserlib.css.Specificity.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
    return this.a + &#x22;,&#x22; + this.b + &#x22;,&#x22; + this.c + &#x22;,&#x22; + this.d;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        for (i = 0; result &#x26;&#x26; i &#x3c; ms.length; i++) {
            result = ms[i].match(expression);
        }
        return result;
    }, function(prec) {
        var p = Matcher.prec.SEQ;
        var s = ms.map(function(m) {
            return m.<span class="apidocCodeKeywordSpan">toString</span>(p);
        }).join(&#x22; &#x22;);
        if (prec &#x3e; p) {
            s = &#x22;[ &#x22; + s + &#x22; ]&#x22;;
        }
        return s;
    });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Specificity.prototype.valueOf" id="apidoc.element.parserlib.css.Specificity.prototype.valueOf">
        function <span class="apidocSignatureSpan">parserlib.css.Specificity.prototype.</span>valueOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">valueOf = function () {
    return (this.a * 1000) + (this.b * 100) + (this.c * 10) + this.d;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Assert.areEqual(1, result.line, &#x22;Line start should be 1&#x22;);
Assert.areEqual(1, result.col, &#x22;Column start should be 1&#x22;);
Assert.areEqual(1, result.parts.length, &#x22;Selector should have three parts.&#x22;);
Assert.isInstanceOf(SelectorPart, result.parts[0], &#x22;First part should be a SelectorPart.&#x22;);
Assert.areEqual(Parser.SELECTOR_PART_TYPE, result.parts[0].type);
Assert.areEqual(&#x22;li&#x22;, result.parts[0].elementName, &#x22;Element name should be &#x27;li&#x27;.&#x22;);
Assert.areEqual(0, result.parts[0].modifiers, &#x22;Element should have zero modifiers.&#x22;);
Assert.areEqual(1, result.specificity.<span class="apidocCodeKeywordSpan">valueOf</span>());
        },

        testSimpleTypeSelectorPlusNamespace: function() {
var parser = new Parser();
var result = parser.parseSelector(&#x22;svg|rect&#x22;);

Assert.isInstanceOf(Selector, result, &#x22;Result should be an instance of Selector.&#x22;);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.parserlib.css.TokenStream" id="apidoc.module.parserlib.css.TokenStream">module parserlib.css.TokenStream</a></h1>


    <h2>
        <a href="#apidoc.element.parserlib.css.TokenStream.TokenStream" id="apidoc.element.parserlib.css.TokenStream.TokenStream">
        function <span class="apidocSignatureSpan">parserlib.css.</span>TokenStream
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TokenStream(input) {
    TokenStreamBase.call(this, input, Tokens);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.parserlib.css.TokenStream.prototype" id="apidoc.module.parserlib.css.TokenStream.prototype">module parserlib.css.TokenStream.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.parserlib.css.TokenStream.prototype._getToken" id="apidoc.element.parserlib.css.TokenStream.prototype._getToken">
        function <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>_getToken
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getToken = function () {

    var c,
        reader = this._reader,
        token   = null,
        startLine   = reader.getLine(),
        startCol    = reader.getCol();

    c = reader.read();


    while (c) {
        switch (c) {

            /*
             * Potential tokens:
             * - COMMENT
             * - SLASH
             * - CHAR
             */
            case &#x22;/&#x22;:

                if (reader.peek() === &#x22;*&#x22;) {
                    token = this.commentToken(c, startLine, startCol);
                } else {
                    token = this.charToken(c, startLine, startCol);
                }
                break;

            /*
             * Potential tokens:
             * - DASHMATCH
             * - INCLUDES
             * - PREFIXMATCH
             * - SUFFIXMATCH
             * - SUBSTRINGMATCH
             * - CHAR
             */
            case &#x22;|&#x22;:
            case &#x22;~&#x22;:
            case &#x22;^&#x22;:
            case &#x22;$&#x22;:
            case &#x22;*&#x22;:
                if (reader.peek() === &#x22;=&#x22;) {
                    token = this.comparisonToken(c, startLine, startCol);
                } else {
                    token = this.charToken(c, startLine, startCol);
                }
                break;

            /*
             * Potential tokens:
             * - STRING
             * - INVALID
             */
            case &#x22;\&#x22;&#x22;:
            case &#x22;&#x27;&#x22;:
                token = this.stringToken(c, startLine, startCol);
                break;

            /*
             * Potential tokens:
             * - HASH
             * - CHAR
             */
            case &#x22;#&#x22;:
                if (isNameChar(reader.peek())) {
                    token = this.hashToken(c, startLine, startCol);
                } else {
                    token = this.charToken(c, startLine, startCol);
                }
                break;

            /*
             * Potential tokens:
             * - DOT
             * - NUMBER
             * - DIMENSION
             * - PERCENTAGE
             */
            case &#x22;.&#x22;:
                if (isDigit(reader.peek())) {
                    token = this.numberToken(c, startLine, startCol);
                } else {
                    token = this.charToken(c, startLine, startCol);
                }
                break;

            /*
             * Potential tokens:
             * - CDC
             * - MINUS
             * - NUMBER
             * - DIMENSION
             * - PERCENTAGE
             */
            case &#x22;-&#x22;:
                if (reader.peek() === &#x22;-&#x22;) {  //could be closing HTML-style comment
                    token = this.htmlCommentEndToken(c, startLine, startCol);
                } else if (isNameStart(reader.peek())) {
                    token = this.identOrFunctionToken(c, startLine, startCol);
                } else {
                    token = this.charToken(c, startLine, startCol);
                }
                break;

            /*
             * Potential tokens:
             * - IMPORTANT_SYM
             * - CHAR
             */
            case &#x22;!&#x22;:
                token = this.importantToken(c, startLine, startCol);
                break;

            /*
             * Any at-keyword or CHAR
             */
            case &#x22;@&#x22;:
                token = this.atRuleToken(c, startLine, startCol);
                break;

            /*
             * Potential tokens:
             * - NOT
             * - CHAR
             */
            case &#x22;:&#x22;:
                token = this.notToken(c, startLine, startCol);
                break;

            /*
             * Potential tokens:
             * - CDO
             * - CHAR
             */
            case &#x22;&#x3c;&#x22;:
                token = this.htmlCommentStartToken(c, startLine, startCol);
                break;

            /*
             * Potential tokens:
             * - IDENT
             * - CHAR
             */
            case &#x22;\\&#x22;:
                if (/[^\r\ ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        this._ltIndex &#x3c;= this._lt.length) {
    this._ltIndexCache.push(i);
    return this._token.type;
}
        }

        //call token retriever method
        token = this.<span class="apidocCodeKeywordSpan">_getToken</span>();

        //if it should be hidden, don&#x27;t save a token
        if (token.type &#x3e; -1 &#x26;&#x26; !tokenInfo[token.type].hide) {

//apply token channel
token.channel = tokenInfo[token.type].channel;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.TokenStream.prototype.atRuleToken" id="apidoc.element.parserlib.css.TokenStream.prototype.atRuleToken">
        function <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>atRuleToken
        <span class="apidocSignatureSpan">(first, startLine, startCol)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">atRuleToken = function (first, startLine, startCol) {
    var rule    = first,
        reader  = this._reader,
        tt      = Tokens.CHAR,
        ident;

    /*
     * First, mark where we are. There are only four @ rules,
     * so anything else is really just an invalid token.
     * Basically, if this doesn&#x27;t match one of the known @
     * rules, just return &#x27;@&#x27; as an unknown token and allow
     * parsing to continue after that point.
     */
    reader.mark();

    //try to find the at-keyword
    ident = this.readName();
    rule = first + ident;
    tt = Tokens.type(rule.toLowerCase());

    //if it&#x27;s not valid, use the first character only and reset the reader
    if (tt === Tokens.CHAR || tt === Tokens.UNKNOWN) {
        if (rule.length &#x3e; 1) {
            tt = Tokens.UNKNOWN_SYM;
        } else {
            tt = Tokens.CHAR;
            rule = first;
            reader.reset();
        }
    }

    return this.createToken(tt, rule, startLine, startCol);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    token = this.importantToken(c, startLine, startCol);
    break;

/*
 * Any at-keyword or CHAR
 */
case &#x22;@&#x22;:
    token = this.<span class="apidocCodeKeywordSpan">atRuleToken</span>(c, startLine, startCol);
    break;

/*
 * Potential tokens:
 * - NOT
 * - CHAR
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.TokenStream.prototype.charToken" id="apidoc.element.parserlib.css.TokenStream.prototype.charToken">
        function <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>charToken
        <span class="apidocSignatureSpan">(c, startLine, startCol)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">charToken = function (c, startLine, startCol) {
    var tt = Tokens.type(c);
    var opts = {};

    if (tt === -1) {
        tt = Tokens.CHAR;
    } else {
        opts.endChar = Tokens[tt].endChar;
    }

    return this.createToken(tt, c, startLine, startCol, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * - CHAR
 */
case &#x22;/&#x22;:

    if (reader.peek() === &#x22;*&#x22;) {
        token = this.commentToken(c, startLine, startCol);
    } else {
        token = this.<span class="apidocCodeKeywordSpan">charToken</span>(c, startLine, startCol);
    }
    break;

/*
 * Potential tokens:
 * - DASHMATCH
 * - INCLUDES
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.TokenStream.prototype.commentToken" id="apidoc.element.parserlib.css.TokenStream.prototype.commentToken">
        function <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>commentToken
        <span class="apidocSignatureSpan">(first, startLine, startCol)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">commentToken = function (first, startLine, startCol) {
    var comment = this.readComment(first);

    return this.createToken(Tokens.COMMENT, comment, startLine, startCol);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * - COMMENT
 * - SLASH
 * - CHAR
 */
case &#x22;/&#x22;:

    if (reader.peek() === &#x22;*&#x22;) {
        token = this.<span class="apidocCodeKeywordSpan">commentToken</span>(c, startLine, startCol);
    } else {
        token = this.charToken(c, startLine, startCol);
    }
    break;

/*
 * Potential tokens:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.TokenStream.prototype.comparisonToken" id="apidoc.element.parserlib.css.TokenStream.prototype.comparisonToken">
        function <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>comparisonToken
        <span class="apidocSignatureSpan">(c, startLine, startCol)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">comparisonToken = function (c, startLine, startCol) {
    var reader  = this._reader,
        comparison  = c + reader.read(),
        tt      = Tokens.type(comparison) || Tokens.CHAR;

    return this.createToken(tt, comparison, startLine, startCol);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
case &#x22;|&#x22;:
case &#x22;~&#x22;:
case &#x22;^&#x22;:
case &#x22;$&#x22;:
case &#x22;*&#x22;:
    if (reader.peek() === &#x22;=&#x22;) {
        token = this.<span class="apidocCodeKeywordSpan">comparisonToken</span>(c, startLine, startCol);
    } else {
        token = this.charToken(c, startLine, startCol);
    }
    break;

/*
 * Potential tokens:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.TokenStream.prototype.createToken" id="apidoc.element.parserlib.css.TokenStream.prototype.createToken">
        function <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>createToken
        <span class="apidocSignatureSpan">(tt, value, startLine, startCol, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createToken = function (tt, value, startLine, startCol, options) {
    var reader = this._reader;
    options = options || {};

    return {
        value:      value,
        type:       tt,
        channel:    options.channel,
        endChar:    options.endChar,
        hide:       options.hide || false,
        startLine:  startLine,
        startCol:   startCol,
        endLine:    reader.getLine(),
        endCol:     reader.getCol()
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

        //make sure this token is wanted
        //TODO: check channel
        break;
    }

    if (!token &#x26;&#x26; c === null) {
        token = this.<span class="apidocCodeKeywordSpan">createToken</span>(Tokens.EOF, null, startLine, startCol);
    }

    return token;
},

//-------------------------------------------------------------------------
// Methods to create tokens
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.TokenStream.prototype.hashToken" id="apidoc.element.parserlib.css.TokenStream.prototype.hashToken">
        function <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>hashToken
        <span class="apidocSignatureSpan">(first, startLine, startCol)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hashToken = function (first, startLine, startCol) {
    var name    = this.readName(first);

    return this.createToken(Tokens.HASH, name, startLine, startCol);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/*
 * Potential tokens:
 * - HASH
 * - CHAR
 */
case &#x22;#&#x22;:
    if (isNameChar(reader.peek())) {
        token = this.<span class="apidocCodeKeywordSpan">hashToken</span>(c, startLine, startCol);
    } else {
        token = this.charToken(c, startLine, startCol);
    }
    break;

/*
 * Potential tokens:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.TokenStream.prototype.htmlCommentEndToken" id="apidoc.element.parserlib.css.TokenStream.prototype.htmlCommentEndToken">
        function <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>htmlCommentEndToken
        <span class="apidocSignatureSpan">(first, startLine, startCol)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">htmlCommentEndToken = function (first, startLine, startCol) {
    var reader      = this._reader,
        text        = first;

    reader.mark();
    text += reader.readCount(2);

    if (text === &#x22;--&#x3e;&#x22;) {
        return this.createToken(Tokens.CDC, text, startLine, startCol);
    } else {
        reader.reset();
        return this.charToken(first, startLine, startCol);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * - MINUS
 * - NUMBER
 * - DIMENSION
 * - PERCENTAGE
 */
case &#x22;-&#x22;:
    if (reader.peek() === &#x22;-&#x22;) {  //could be closing HTML-style comment
        token = this.<span class="apidocCodeKeywordSpan">htmlCommentEndToken</span>(c, startLine, startCol);
    } else if (isNameStart(reader.peek())) {
        token = this.identOrFunctionToken(c, startLine, startCol);
    } else {
        token = this.charToken(c, startLine, startCol);
    }
    break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.TokenStream.prototype.htmlCommentStartToken" id="apidoc.element.parserlib.css.TokenStream.prototype.htmlCommentStartToken">
        function <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>htmlCommentStartToken
        <span class="apidocSignatureSpan">(first, startLine, startCol)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">htmlCommentStartToken = function (first, startLine, startCol) {
    var reader      = this._reader,
        text        = first;

    reader.mark();
    text += reader.readCount(3);

    if (text === &#x22;&#x3c;!--&#x22;) {
        return this.createToken(Tokens.CDO, text, startLine, startCol);
    } else {
        reader.reset();
        return this.charToken(first, startLine, startCol);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/*
 * Potential tokens:
 * - CDO
 * - CHAR
 */
case &#x22;&#x3c;&#x22;:
    token = this.<span class="apidocCodeKeywordSpan">htmlCommentStartToken</span>(c, startLine, startCol);
    break;

/*
 * Potential tokens:
 * - IDENT
 * - CHAR
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.TokenStream.prototype.identOrFunctionToken" id="apidoc.element.parserlib.css.TokenStream.prototype.identOrFunctionToken">
        function <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>identOrFunctionToken
        <span class="apidocSignatureSpan">(first, startLine, startCol)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">identOrFunctionToken = function (first, startLine, startCol) {
    var reader  = this._reader,
        ident   = this.readName(first),
        tt      = Tokens.IDENT,
        uriFns  = [&#x22;url(&#x22;, &#x22;url-prefix(&#x22;, &#x22;domain(&#x22;],
        uri;

    //if there&#x27;s a left paren immediately after, it&#x27;s a URI or function
    if (reader.peek() === &#x22;(&#x22;) {
        ident += reader.read();
        if (uriFns.indexOf(ident.toLowerCase()) &#x3e; -1) {
            reader.mark();
            uri = this.readURI(ident);
            if (uri === null) {
                //didn&#x27;t find a valid URL or there&#x27;s no closing paren
                reader.reset();
                tt = Tokens.FUNCTION;
            } else {
                tt = Tokens.URI;
                ident = uri;
            }
        } else {
            tt = Tokens.FUNCTION;
        }
    } else if (reader.peek() === &#x22;:&#x22;) {  //might be an IE function

        //IE-specific functions always being with progid:
        if (ident.toLowerCase() === &#x22;progid&#x22;) {
            ident += reader.readTo(&#x22;(&#x22;);
            tt = Tokens.IE_FUNCTION;
        }
    }

    return this.createToken(tt, ident, startLine, startCol);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * - DIMENSION
 * - PERCENTAGE
 */
case &#x22;-&#x22;:
    if (reader.peek() === &#x22;-&#x22;) {  //could be closing HTML-style comment
        token = this.htmlCommentEndToken(c, startLine, startCol);
    } else if (isNameStart(reader.peek())) {
        token = this.<span class="apidocCodeKeywordSpan">identOrFunctionToken</span>(c, startLine, startCol);
    } else {
        token = this.charToken(c, startLine, startCol);
    }
    break;

/*
 * Potential tokens:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.TokenStream.prototype.importantToken" id="apidoc.element.parserlib.css.TokenStream.prototype.importantToken">
        function <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>importantToken
        <span class="apidocSignatureSpan">(first, startLine, startCol)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">importantToken = function (first, startLine, startCol) {
    var reader      = this._reader,
        important   = first,
        tt          = Tokens.CHAR,
        temp,
        c;

    reader.mark();
    c = reader.read();

    while (c) {

        //there can be a comment in here
        if (c === &#x22;/&#x22;) {

            //if the next character isn&#x27;t a star, then this isn&#x27;t a valid !important token
            if (reader.peek() !== &#x22;*&#x22;) {
                break;
            } else {
                temp = this.readComment(c);
                if (temp === &#x22;&#x22;) {    //broken!
                    break;
                }
            }
        } else if (isWhitespace(c)) {
            important += c + this.readWhitespace();
        } else if (/i/i.test(c)) {
            temp = reader.readCount(8);
            if (/mportant/i.test(temp)) {
                important += c + temp;
                tt = Tokens.IMPORTANT_SYM;

            }
            break;  //we&#x27;re done
        } else {
            break;
        }

        c = reader.read();
    }

    if (tt === Tokens.CHAR) {
        reader.reset();
        return this.charToken(first, startLine, startCol);
    } else {
        return this.createToken(tt, important, startLine, startCol);
    }


}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/*
 * Potential tokens:
 * - IMPORTANT_SYM
 * - CHAR
 */
case &#x22;!&#x22;:
    token = this.<span class="apidocCodeKeywordSpan">importantToken</span>(c, startLine, startCol);
    break;

/*
 * Any at-keyword or CHAR
 */
case &#x22;@&#x22;:
    token = this.atRuleToken(c, startLine, startCol);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.TokenStream.prototype.notToken" id="apidoc.element.parserlib.css.TokenStream.prototype.notToken">
        function <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>notToken
        <span class="apidocSignatureSpan">(first, startLine, startCol)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notToken = function (first, startLine, startCol) {
    var reader      = this._reader,
        text        = first;

    reader.mark();
    text += reader.readCount(4);

    if (text.toLowerCase() === &#x22;:not(&#x22;) {
        return this.createToken(Tokens.NOT, text, startLine, startCol);
    } else {
        reader.reset();
        return this.charToken(first, startLine, startCol);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/*
 * Potential tokens:
 * - NOT
 * - CHAR
 */
case &#x22;:&#x22;:
    token = this.<span class="apidocCodeKeywordSpan">notToken</span>(c, startLine, startCol);
    break;

/*
 * Potential tokens:
 * - CDO
 * - CHAR
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.TokenStream.prototype.numberToken" id="apidoc.element.parserlib.css.TokenStream.prototype.numberToken">
        function <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>numberToken
        <span class="apidocSignatureSpan">(first, startLine, startCol)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">numberToken = function (first, startLine, startCol) {
    var reader  = this._reader,
        value   = this.readNumber(first),
        ident,
        tt      = Tokens.NUMBER,
        c       = reader.peek();

    if (isIdentStart(c)) {
        ident = this.readName(reader.read());
        value += ident;

        if (/^em$|^ex$|^px$|^gd$|^rem$|^vw$|^vh$|^vmax$|^vmin$|^ch$|^cm$|^mm$|^in$|^pt$|^pc$/i.test(ident)) {
            tt = Tokens.LENGTH;
        } else if (/^deg|^rad$|^grad$|^turn$/i.test(ident)) {
            tt = Tokens.ANGLE;
        } else if (/^ms$|^s$/i.test(ident)) {
            tt = Tokens.TIME;
        } else if (/^hz$|^khz$/i.test(ident)) {
            tt = Tokens.FREQ;
        } else if (/^dpi$|^dpcm$/i.test(ident)) {
            tt = Tokens.RESOLUTION;
        } else {
            tt = Tokens.DIMENSION;
        }

    } else if (c === &#x22;%&#x22;) {
        value += reader.read();
        tt = Tokens.PERCENTAGE;
    }

    return this.createToken(tt, value, startLine, startCol);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * - DOT
 * - NUMBER
 * - DIMENSION
 * - PERCENTAGE
 */
case &#x22;.&#x22;:
    if (isDigit(reader.peek())) {
        token = this.<span class="apidocCodeKeywordSpan">numberToken</span>(c, startLine, startCol);
    } else {
        token = this.charToken(c, startLine, startCol);
    }
    break;

/*
 * Potential tokens:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.TokenStream.prototype.readComment" id="apidoc.element.parserlib.css.TokenStream.prototype.readComment">
        function <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>readComment
        <span class="apidocSignatureSpan">(first)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readComment = function (first) {
    var reader  = this._reader,
        comment = first || &#x22;&#x22;,
        c       = reader.read();

    if (c === &#x22;*&#x22;) {
        while (c) {
            comment += c;

            //look for end of comment
            if (comment.length &#x3e; 2 &#x26;&#x26; c === &#x22;*&#x22; &#x26;&#x26; reader.peek() === &#x22;/&#x22;) {
                comment += reader.read();
                break;
            }

            c = reader.read();
        }

        return comment;
    } else {
        return &#x22;&#x22;;
    }

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {String} first The first character for the token.
 * @param {int} startLine The beginning line for the character.
 * @param {int} startCol The beginning column for the character.
 * @return {Object} A token object.
 * @method commentToken
 */
commentToken: function(first, startLine, startCol) {
    var comment = this.<span class="apidocCodeKeywordSpan">readComment</span>(first);

    return this.createToken(Tokens.COMMENT, comment, startLine, startCol);
},

/**
 * Produces a comparison token based on the given character
 * and location in the stream. The next character must be
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.TokenStream.prototype.readEscape" id="apidoc.element.parserlib.css.TokenStream.prototype.readEscape">
        function <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>readEscape
        <span class="apidocSignatureSpan">(first, unescape)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readEscape = function (first, unescape) {
    var reader  = this._reader,
        cssEscape = first || &#x22;&#x22;,
        i       = 0,
        c       = reader.peek();

    if (isHexDigit(c)) {
        do {
            cssEscape += reader.read();
            c = reader.peek();
        } while (c &#x26;&#x26; isHexDigit(c) &#x26;&#x26; ++i &#x3c; 6);
    }

    if (cssEscape.length === 1) {
        if (/^[^\r\n\f0-9a-f]$/.test(c)) {
            reader.read();
            if (unescape) {
                return c;
            }
        } else {
            // We should never get here (readName won&#x27;t call readEscape
            // if the escape sequence is bad).
            throw new Error(&#x22;Bad escape sequence.&#x22;);
        }
    } else if (c === &#x22;\r&#x22;) {
        reader.read();
        if (reader.peek() === &#x22;\n&#x22;) {
            c += reader.read();
        }
    } else if (/^[ \t\n\f]$/.test(c)) {
        reader.read();
    } else {
        c = &#x22;&#x22;;
    }

    if (unescape) {
        var cp = parseInt(cssEscape.slice(first.length), 16);
        return String.fromCodePoint ? String.fromCodePoint(cp) :
            String.fromCharCode(cp);
    }
    return cssEscape + c;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/*
 * Potential tokens:
 * - IDENT
 * - CHAR
 */
case &#x22;\\&#x22;:
    if (/[^\r\n\f]/.test(reader.peek())) {
        token = this.identOrFunctionToken(this.<span class="apidocCodeKeywordSpan">readEscape</span>(c, true), startLine, startCol
);
    } else {
        token = this.charToken(c, startLine, startCol);
    }
    break;

/*
 * Potential tokens:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.TokenStream.prototype.readName" id="apidoc.element.parserlib.css.TokenStream.prototype.readName">
        function <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>readName
        <span class="apidocSignatureSpan">(first)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readName = function (first) {
    var reader  = this._reader,
        ident   = first || &#x22;&#x22;,
        c;

    for (c = reader.peek(); c; c = reader.peek()) {
        if (c === &#x22;\\&#x22;) {
            if (/^[^\r\n\f]$/.test(reader.peek(2))) {
                ident += this.readEscape(reader.read(), true);
            } else {
                // Bad escape sequence.
                break;
            }
        } else if (isNameChar(c)) {
            ident += reader.read();
        } else {
            break;
        }
    }

    return ident;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Basically, if this doesn&#x27;t match one of the known @
 * rules, just return &#x27;@&#x27; as an unknown token and allow
 * parsing to continue after that point.
 */
reader.mark();

//try to find the at-keyword
ident = this.<span class="apidocCodeKeywordSpan">readName</span>();
rule = first + ident;
tt = Tokens.type(rule.toLowerCase());

//if it&#x27;s not valid, use the first character only and reset the reader
if (tt === Tokens.CHAR || tt === Tokens.UNKNOWN) {
    if (rule.length &#x3e; 1) {
        tt = Tokens.UNKNOWN_SYM;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.TokenStream.prototype.readNumber" id="apidoc.element.parserlib.css.TokenStream.prototype.readNumber">
        function <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>readNumber
        <span class="apidocSignatureSpan">(first)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readNumber = function (first) {
    var reader  = this._reader,
        number  = first,
        hasDot  = (first === &#x22;.&#x22;),
        c       = reader.peek();


    while (c) {
        if (isDigit(c)) {
            number += reader.read();
        } else if (c === &#x22;.&#x22;) {
            if (hasDot) {
                break;
            } else {
                hasDot = true;
                number += reader.read();
            }
        } else {
            break;
        }

        c = reader.peek();
    }

    return number;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method numberToken
     */
    numberToken: function(first, startLine, startCol) {
var reader  = this._reader,
    value   = this.<span class="apidocCodeKeywordSpan">readNumber</span>(first),
    ident,
    tt      = Tokens.NUMBER,
    c       = reader.peek();

if (isIdentStart(c)) {
    ident = this.readName(reader.read());
    value += ident;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.TokenStream.prototype.readString" id="apidoc.element.parserlib.css.TokenStream.prototype.readString">
        function <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>readString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readString = function () {
    var token = this.stringToken(this._reader.read(), 0, 0);
    return token.type === Tokens.INVALID ? null : token.value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
while (c &#x26;&#x26; isWhitespace(c)) {
    reader.read();
    c = reader.peek();
}

//it&#x27;s a string
if (c === &#x22;&#x27;&#x22; || c === &#x22;\&#x22;&#x22;) {
    inner = this.<span class="apidocCodeKeywordSpan">readString</span>();
    if (inner !== null) {
        inner = PropertyValuePart.parseString(inner);
    }
} else {
    inner = this.readUnquotedURL();
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.TokenStream.prototype.readURI" id="apidoc.element.parserlib.css.TokenStream.prototype.readURI">
        function <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>readURI
        <span class="apidocSignatureSpan">(first)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readURI = function (first) {
    var reader  = this._reader,
        uri     = first,
        inner   = &#x22;&#x22;,
        c       = reader.peek();

    //skip whitespace before
    while (c &#x26;&#x26; isWhitespace(c)) {
        reader.read();
        c = reader.peek();
    }

    //it&#x27;s a string
    if (c === &#x22;&#x27;&#x22; || c === &#x22;\&#x22;&#x22;) {
        inner = this.readString();
        if (inner !== null) {
            inner = PropertyValuePart.parseString(inner);
        }
    } else {
        inner = this.readUnquotedURL();
    }

    c = reader.peek();

    //skip whitespace after
    while (c &#x26;&#x26; isWhitespace(c)) {
        reader.read();
        c = reader.peek();
    }

    //if there was no inner value or the next character isn&#x27;t closing paren, it&#x27;s not a URI
    if (inner === null || c !== &#x22;)&#x22;) {
        uri = null;
    } else {
        // Ensure argument to URL is always double-quoted
        // (This simplifies later processing in PropertyValuePart.)
        uri += PropertyValuePart.serializeString(inner) + reader.read();
    }

    return uri;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    uri;

//if there&#x27;s a left paren immediately after, it&#x27;s a URI or function
if (reader.peek() === &#x22;(&#x22;) {
    ident += reader.read();
    if (uriFns.indexOf(ident.toLowerCase()) &#x3e; -1) {
        reader.mark();
        uri = this.<span class="apidocCodeKeywordSpan">readURI</span>(ident);
        if (uri === null) {
            //didn&#x27;t find a valid URL or there&#x27;s no closing paren
            reader.reset();
            tt = Tokens.FUNCTION;
        } else {
            tt = Tokens.URI;
            ident = uri;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.TokenStream.prototype.readUnicodeRangePart" id="apidoc.element.parserlib.css.TokenStream.prototype.readUnicodeRangePart">
        function <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>readUnicodeRangePart
        <span class="apidocSignatureSpan">(allowQuestionMark)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readUnicodeRangePart = function (allowQuestionMark) {
    var reader  = this._reader,
        part = &#x22;&#x22;,
        c       = reader.peek();

    //first read hex digits
    while (isHexDigit(c) &#x26;&#x26; part.length &#x3c; 6) {
        reader.read();
        part += c;
        c = reader.peek();
    }

    //then read question marks if allowed
    if (allowQuestionMark) {
        while (c === &#x22;?&#x22; &#x26;&#x26; part.length &#x3c; 6) {
            reader.read();
            part += c;
            c = reader.peek();
        }
    }

    //there can&#x27;t be any other characters after this point

    return part;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            temp,
            tt      = Tokens.CHAR;

        //then it should be a unicode range
        if (reader.peek() === &#x22;+&#x22;) {
            reader.mark();
            value += reader.read();
            value += this.<span class="apidocCodeKeywordSpan">readUnicodeRangePart</span>(true);

            //ensure there&#x27;s an actual unicode range here
            if (value.length === 2) {
reader.reset();
            } else {

tt = Tokens.UNICODE_RANGE;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.TokenStream.prototype.readUnquotedURL" id="apidoc.element.parserlib.css.TokenStream.prototype.readUnquotedURL">
        function <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>readUnquotedURL
        <span class="apidocSignatureSpan">(first)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readUnquotedURL = function (first) {
    var reader  = this._reader,
        url     = first || &#x22;&#x22;,
        c;

    for (c = reader.peek(); c; c = reader.peek()) {
        // Note that the grammar at
        // https://www.w3.org/TR/CSS2/grammar.html#scanner
        // incorrectly includes the backslash character in the
        // `url` production, although it is correctly omitted in
        // the `baduri1` production.
        if (nonascii.test(c) || /^[\-!#$%&#x26;*-\[\]-~]$/.test(c)) {
            url += c;
            reader.read();
        } else if (c === &#x22;\\&#x22;) {
            if (/^[^\r\n\f]$/.test(reader.peek(2))) {
                url += this.readEscape(reader.read(), true);
            } else {
                break; // bad escape sequence.
            }
        } else {
            break; // bad character
        }
    }

    return url;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//it&#x27;s a string
if (c === &#x22;&#x27;&#x22; || c === &#x22;\&#x22;&#x22;) {
    inner = this.readString();
    if (inner !== null) {
        inner = PropertyValuePart.parseString(inner);
    }
} else {
    inner = this.<span class="apidocCodeKeywordSpan">readUnquotedURL</span>();
}

c = reader.peek();

//skip whitespace after
while (c &#x26;&#x26; isWhitespace(c)) {
    reader.read();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.TokenStream.prototype.readWhitespace" id="apidoc.element.parserlib.css.TokenStream.prototype.readWhitespace">
        function <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>readWhitespace
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readWhitespace = function () {
    var reader  = this._reader,
        whitespace = &#x22;&#x22;,
        c       = reader.peek();

    while (isWhitespace(c)) {
        reader.read();
        whitespace += c;
        c = reader.peek();
    }

    return whitespace;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} else {
    temp = this.readComment(c);
    if (temp === &#x22;&#x22;) {    //broken!
        break;
    }
}
            } else if (isWhitespace(c)) {
important += c + this.<span class="apidocCodeKeywordSpan">readWhitespace</span>();
            } else if (/i/i.test(c)) {
temp = reader.readCount(8);
if (/mportant/i.test(temp)) {
    important += c + temp;
    tt = Tokens.IMPORTANT_SYM;

}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.TokenStream.prototype.stringToken" id="apidoc.element.parserlib.css.TokenStream.prototype.stringToken">
        function <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>stringToken
        <span class="apidocSignatureSpan">(first, startLine, startCol)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringToken = function (first, startLine, startCol) {
    var delim   = first,
        string  = first,
        reader  = this._reader,
        tt      = Tokens.STRING,
        c       = reader.read(),
        i;

    while (c) {
        string += c;

        if (c === &#x22;\\&#x22;) {
            c = reader.read();
            if (c === null) {
                break; // premature EOF after backslash
            } else if (/[^\r\n\f0-9a-f]/i.test(c)) {
                // single-character escape
                string += c;
            } else {
                // read up to six hex digits
                for (i=0; isHexDigit(c) &#x26;&#x26; i&#x3c;6; i++) {
                    string += c;
                    c = reader.read();
                }
                // swallow trailing newline or space
                if (c === &#x22;\r&#x22; &#x26;&#x26; reader.peek() === &#x22;\n&#x22;) {
                    string += c;
                    c = reader.read();
                }
                if (isWhitespace(c)) {
                    string += c;
                } else {
                    // This character is null or not part of the escape;
                    // jump back to the top to process it.
                    continue;
                }
            }
        } else if (c === delim) {
            break; // delimiter found.
        } else if (isNewLine(reader.peek())) {
            // newline without an escapement: it&#x27;s an invalid string
            tt = Tokens.INVALID;
            break;
        }
        c = reader.read();
    }

    //if c is null, that means we&#x27;re out of input and the string was never closed
    if (c === null) {
        tt = Tokens.INVALID;
    }

    return this.createToken(tt, string, startLine, startCol);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/*
 * Potential tokens:
 * - STRING
 * - INVALID
 */
case &#x22;\&#x22;&#x22;:
case &#x22;&#x27;&#x22;:
    token = this.<span class="apidocCodeKeywordSpan">stringToken</span>(c, startLine, startCol);
    break;

/*
 * Potential tokens:
 * - HASH
 * - CHAR
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.TokenStream.prototype.unicodeRangeToken" id="apidoc.element.parserlib.css.TokenStream.prototype.unicodeRangeToken">
        function <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>unicodeRangeToken
        <span class="apidocSignatureSpan">(first, startLine, startCol)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unicodeRangeToken = function (first, startLine, startCol) {
    var reader  = this._reader,
        value   = first,
        temp,
        tt      = Tokens.CHAR;

    //then it should be a unicode range
    if (reader.peek() === &#x22;+&#x22;) {
        reader.mark();
        value += reader.read();
        value += this.readUnicodeRangePart(true);

        //ensure there&#x27;s an actual unicode range here
        if (value.length === 2) {
            reader.reset();
        } else {

            tt = Tokens.UNICODE_RANGE;

            //if there&#x27;s a ? in the first part, there can&#x27;t be a second part
            if (value.indexOf(&#x22;?&#x22;) === -1) {

                if (reader.peek() === &#x22;-&#x22;) {
                    reader.mark();
                    temp = reader.read();
                    temp += this.readUnicodeRangePart(false);

                    //if there&#x27;s not another value, back up and just take the first
                    if (temp.length === 1) {
                        reader.reset();
                    } else {
                        value += temp;
                    }
                }

            }
        }
    }

    return this.createToken(tt, value, startLine, startCol);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                 * - UNICODE_RANGE
                 * - URL
                 * - CHAR
                 */
                case &#x22;U&#x22;:
                case &#x22;u&#x22;:
if (reader.peek() === &#x22;+&#x22;) {
    token = this.<span class="apidocCodeKeywordSpan">unicodeRangeToken</span>(c, startLine, startCol);
    break;
}
/* falls through */
                default:

/*
 * Potential tokens:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.TokenStream.prototype.whitespaceToken" id="apidoc.element.parserlib.css.TokenStream.prototype.whitespaceToken">
        function <span class="apidocSignatureSpan">parserlib.css.TokenStream.prototype.</span>whitespaceToken
        <span class="apidocSignatureSpan">(first, startLine, startCol)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">whitespaceToken = function (first, startLine, startCol) {
    var value   = first + this.readWhitespace();
    return this.createToken(Tokens.S, value, startLine, startCol);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} else

/*
 * Potential tokens:
 * - S
 */
if (isWhitespace(c)) {
    token = this.<span class="apidocCodeKeywordSpan">whitespaceToken</span>(c, startLine, startCol);
} else

/*
 * Potential tokens:
 * - IDENT
 */
if (isIdentStart(c)) {
...</pre></li>
    </ul>












</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.parserlib.css.Tokens" id="apidoc.module.parserlib.css.Tokens">module parserlib.css.Tokens</a></h1>


    <h2>
        <a href="#apidoc.element.parserlib.css.Tokens.name" id="apidoc.element.parserlib.css.Tokens.name">
        function <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>name
        <span class="apidocSignatureSpan">(tt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">name = function (tt) {
    return nameMap[tt];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    CSSTokenTestCase.prototype._testPattern = function(pattern, outputs) {
var tokenStream = new TokenStream(pattern, CSSTokens);
var tt;

for (var i=0, len=outputs.length; i &#x3c; len; i++) {
    tt = tokenStream.get(outputs[i] &#x3e; -1 ? CSSTokens[outputs[i]].channel : undefined);
    Assert.areEqual(outputs[i], tt, &#x22;Token type should be &#x22; + CSSTokens.<span class="apidocCodeKeywordSpan">name</span
>(outputs[i]) + &#x22; but was &#x22; + CSSTokens.name(tt) + &#x22; (&#x22; + (tokenStream.token() ? tokenStream.token().value : &#
x22;unknown&#x22;) + &#x22;).&#x22;);
}

//if there was an invalid token, stop here
if (tt &#x3e; -1) {
    tt = tokenStream.get();
    Assert.areEqual(CSSTokens.EOF, tt, &#x22;Expected end of input but found token &#x22; + CSSTokens.name(tt) + &#x22; (&#x22; + (
tokenStream.token() ? tokenStream.token().value : &#x22;unknown&#x22;) + &#x22;).&#x22;);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.css.Tokens.type" id="apidoc.element.parserlib.css.Tokens.type">
        function <span class="apidocSignatureSpan">parserlib.css.Tokens.</span>type
        <span class="apidocSignatureSpan">(c)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">type = function (c) {
    return typeMap[c] || -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    token = tokenStream.token();
    endChar = token.endChar;
    value = token.value + this._expr(inFunction).text;
    if (unary === null) {
        line = tokenStream.token().startLine;
        col = tokenStream.token().startCol;
    }
    tokenStream.mustMatch(Tokens.<span class="apidocCodeKeywordSpan">type</span>(endChar));
    value += endChar;
    this._readWhitespace();

//see if there&#x27;s a simple match
} else if (tokenStream.match([Tokens.NUMBER, Tokens.PERCENTAGE, Tokens.LENGTH,
        Tokens.ANGLE, Tokens.TIME,
        Tokens.FREQ, Tokens.STRING, Tokens.IDENT, Tokens.URI, Tokens.UNICODE_RANGE])) {
...</pre></li>
    </ul>












































































































































































































































































































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.parserlib.util" id="apidoc.module.parserlib.util">module parserlib.util</a></h1>


    <h2>
        <a href="#apidoc.element.parserlib.util.EventTarget" id="apidoc.element.parserlib.util.EventTarget">
        function <span class="apidocSignatureSpan">parserlib.util.</span>EventTarget
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventTarget() {

    /**
     * The array of listeners for various events.
     * @type Object
     * @property _listeners
     * @private
     */
    this._listeners = Object.create(null);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.util.StringReader" id="apidoc.element.parserlib.util.StringReader">
        function <span class="apidocSignatureSpan">parserlib.util.</span>StringReader
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function StringReader(text) {

    /**
     * The input text with line endings normalized.
     * @property _input
     * @type String
     * @private
     */
    this._input = text.replace(/(\r\n?|\n)/g, &#x22;\n&#x22;);


    /**
     * The row for the character to be read next.
     * @property _line
     * @type int
     * @private
     */
    this._line = 1;


    /**
     * The column for the character to be read next.
     * @property _col
     * @type int
     * @private
     */
    this._col = 1;

    /**
     * The index of the character in the input to be read next.
     * @property _cursor
     * @type int
     * @private
     */
    this._cursor = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.util.SyntaxError" id="apidoc.element.parserlib.util.SyntaxError">
        function <span class="apidocSignatureSpan">parserlib.util.</span>SyntaxError
        <span class="apidocSignatureSpan">(message, line, col)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntaxError(message, line, col) {
    Error.call(this);
    this.name = this.constructor.name;

    /**
     * The column at which the error occurred.
     * @type int
     * @property col
     */
    this.col = col;

    /**
     * The line at which the error occurred.
     * @type int
     * @property line
     */
    this.line = line;

    /**
     * The text representation of the unit.
     * @type String
     * @property text
     */
    this.message = message;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.util.SyntaxUnit" id="apidoc.element.parserlib.util.SyntaxUnit">
        function <span class="apidocSignatureSpan">parserlib.util.</span>SyntaxUnit
        <span class="apidocSignatureSpan">(text, line, col, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntaxUnit(text, line, col, type) {


    /**
     * The column of text on which the unit resides.
     * @type int
     * @property col
     */
    this.col = col;

    /**
     * The line of text on which the unit resides.
     * @type int
     * @property line
     */
    this.line = line;

    /**
     * The text representation of the unit.
     * @type String
     * @property text
     */
    this.text = text;

    /**
     * The type of syntax unit.
     * @type int
     * @property type
     */
    this.type = type;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.util.TokenStreamBase" id="apidoc.element.parserlib.util.TokenStreamBase">
        function <span class="apidocSignatureSpan">parserlib.util.</span>TokenStreamBase
        <span class="apidocSignatureSpan">(input, tokenData)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TokenStreamBase(input, tokenData) {

    /**
     * The string reader for easy access to the text.
     * @type StringReader
     * @property _reader
     * @private
     */
    this._reader = new StringReader(input ? input.toString() : &#x22;&#x22;);

    /**
     * Token object for the last consumed token.
     * @type Token
     * @property _token
     * @private
     */
    this._token = null;

    /**
     * The array of token information.
     * @type Array
     * @property _tokenData
     * @private
     */
    this._tokenData = tokenData;

    /**
     * Lookahead token buffer.
     * @type Array
     * @property _lt
     * @private
     */
    this._lt = [];

    /**
     * Lookahead token buffer index.
     * @type int
     * @property _ltIndex
     * @private
     */
    this._ltIndex = 0;

    this._ltIndexCache = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.parserlib.util.EventTarget" id="apidoc.module.parserlib.util.EventTarget">module parserlib.util.EventTarget</a></h1>


    <h2>
        <a href="#apidoc.element.parserlib.util.EventTarget.EventTarget" id="apidoc.element.parserlib.util.EventTarget.EventTarget">
        function <span class="apidocSignatureSpan">parserlib.util.</span>EventTarget
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventTarget() {

    /**
     * The array of listeners for various events.
     * @type Object
     * @property _listeners
     * @private
     */
    this._listeners = Object.create(null);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.parserlib.util.EventTarget.prototype" id="apidoc.module.parserlib.util.EventTarget.prototype">module parserlib.util.EventTarget.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.parserlib.util.EventTarget.prototype.addListener" id="apidoc.element.parserlib.util.EventTarget.prototype.addListener">
        function <span class="apidocSignatureSpan">parserlib.util.EventTarget.prototype.</span>addListener
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addListener = function (type, listener) {
    if (!this._listeners[type]) {
        this._listeners[type] = [];
    }

    this._listeners[type].push(listener);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### `startstylesheet` and `endstylesheet` events

The `startstylesheet` event fires just before parsing of the CSS text begins
and the `endstylesheet` event fires just after all of the CSS text has been parsed.
There is no additional information provided for these events. Example:

```js
parser.<span class="apidocCodeKeywordSpan">addListener</span>(&#x22;startstylesheet&#x22;, function() {
    console.log(&#x22;Starting to parse stylesheet&#x22;);
});

parser.addListener(&#x22;endstylesheet&#x22;, function() {
    console.log(&#x22;Finished parsing stylesheet&#x22;);
});
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.util.EventTarget.prototype.constructor" id="apidoc.element.parserlib.util.EventTarget.prototype.constructor">
        function <span class="apidocSignatureSpan">parserlib.util.EventTarget.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventTarget() {

    /**
     * The array of listeners for various events.
     * @type Object
     * @property _listeners
     * @private
     */
    this._listeners = Object.create(null);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.util.EventTarget.prototype.fire" id="apidoc.element.parserlib.util.EventTarget.prototype.fire">
        function <span class="apidocSignatureSpan">parserlib.util.EventTarget.prototype.</span>fire
        <span class="apidocSignatureSpan">(event)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fire = function (event) {
    if (typeof event === &#x22;string&#x22;) {
        event = { type: event };
    }
    if (typeof event.target !== &#x22;undefined&#x22;) {
        event.target = this;
    }

    if (typeof event.type === &#x22;undefined&#x22;) {
        throw new Error(&#x22;Event object missing &#x27;type&#x27; property.&#x22;);
    }

    if (this._listeners[event.type]) {

        //create a copy of the array and use that so listeners can&#x27;t chane
        var listeners = this._listeners[event.type].concat();
        for (var i=0, len=listeners.length; i &#x3c; len; i++) {
            listeners[i].call(this, event);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */

var tokenStream = this._tokenStream,
    count,
    token,
    tt;

this.<span class="apidocCodeKeywordSpan">fire</span>(&#x22;startstylesheet&#x22;);

//try to read character set
this._charset();

this._skipCruft();

//try to read imports - may be more than one
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.util.EventTarget.prototype.removeListener" id="apidoc.element.parserlib.util.EventTarget.prototype.removeListener">
        function <span class="apidocSignatureSpan">parserlib.util.EventTarget.prototype.</span>removeListener
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeListener = function (type, listener) {
    if (this._listeners[type]) {
        var listeners = this._listeners[type];
        for (var i=0, len=listeners.length; i &#x3c; len; i++) {
            if (listeners[i] === listener) {
                listeners.splice(i, 1);
                break;
            }
        }


    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.parserlib.util.StringReader" id="apidoc.module.parserlib.util.StringReader">module parserlib.util.StringReader</a></h1>


    <h2>
        <a href="#apidoc.element.parserlib.util.StringReader.StringReader" id="apidoc.element.parserlib.util.StringReader.StringReader">
        function <span class="apidocSignatureSpan">parserlib.util.</span>StringReader
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function StringReader(text) {

    /**
     * The input text with line endings normalized.
     * @property _input
     * @type String
     * @private
     */
    this._input = text.replace(/(\r\n?|\n)/g, &#x22;\n&#x22;);


    /**
     * The row for the character to be read next.
     * @property _line
     * @type int
     * @private
     */
    this._line = 1;


    /**
     * The column for the character to be read next.
     * @property _col
     * @type int
     * @private
     */
    this._col = 1;

    /**
     * The index of the character in the input to be read next.
     * @property _cursor
     * @type int
     * @private
     */
    this._cursor = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.parserlib.util.StringReader.prototype" id="apidoc.module.parserlib.util.StringReader.prototype">module parserlib.util.StringReader.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.parserlib.util.StringReader.prototype.constructor" id="apidoc.element.parserlib.util.StringReader.prototype.constructor">
        function <span class="apidocSignatureSpan">parserlib.util.StringReader.prototype.</span>constructor
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function StringReader(text) {

    /**
     * The input text with line endings normalized.
     * @property _input
     * @type String
     * @private
     */
    this._input = text.replace(/(\r\n?|\n)/g, &#x22;\n&#x22;);


    /**
     * The row for the character to be read next.
     * @property _line
     * @type int
     * @private
     */
    this._line = 1;


    /**
     * The column for the character to be read next.
     * @property _col
     * @type int
     * @private
     */
    this._col = 1;

    /**
     * The index of the character in the input to be read next.
     * @property _cursor
     * @type int
     * @private
     */
    this._cursor = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.util.StringReader.prototype.eof" id="apidoc.element.parserlib.util.StringReader.prototype.eof">
        function <span class="apidocSignatureSpan">parserlib.util.StringReader.prototype.</span>eof
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eof = function () {
    return this._cursor === this._input.length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            var m = expr();
            eat(&#x22; ]&#x22;);
            return m;
        }
        return Matcher.fromType(eat(/^[^ ?*+#{]+/));
    };
    result = expr();
    if (!reader.<span class="apidocCodeKeywordSpan">eof</span>()) {
        throw new SyntaxError(
            &#x22;Expected end of string&#x22;, reader.getLine(), reader.getCol());
    }
    return result;
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.util.StringReader.prototype.getCol" id="apidoc.element.parserlib.util.StringReader.prototype.getCol">
        function <span class="apidocSignatureSpan">parserlib.util.StringReader.prototype.</span>getCol
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getCol = function () {
    return this._col;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Matcher.parse = function(str) {
var reader, eat, expr, oror, andand, seq, mod, term, result;
reader = new StringReader(str);
eat = function(matcher) {
    var result = reader.readMatch(matcher);
    if (result === null) {
        throw new SyntaxError(
            &#x22;Expected &#x22;+matcher, reader.getLine(), reader.<span class="apidocCodeKeywordSpan">getCol</span>());
    }
    return result;
};
expr = function() {
    // expr = oror (&#x22; | &#x22; oror)*
    var m = [ oror() ];
    while (reader.readMatch(&#x22; | &#x22;) !== null) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.util.StringReader.prototype.getLine" id="apidoc.element.parserlib.util.StringReader.prototype.getLine">
        function <span class="apidocSignatureSpan">parserlib.util.StringReader.prototype.</span>getLine
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLine = function () {
    return this._line;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Matcher.parse = function(str) {
var reader, eat, expr, oror, andand, seq, mod, term, result;
reader = new StringReader(str);
eat = function(matcher) {
    var result = reader.readMatch(matcher);
    if (result === null) {
        throw new SyntaxError(
            &#x22;Expected &#x22;+matcher, reader.<span class="apidocCodeKeywordSpan">getLine</span>(), reader.getCol());
    }
    return result;
};
expr = function() {
    // expr = oror (&#x22; | &#x22; oror)*
    var m = [ oror() ];
    while (reader.readMatch(&#x22; | &#x22;) !== null) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.util.StringReader.prototype.mark" id="apidoc.element.parserlib.util.StringReader.prototype.mark">
        function <span class="apidocSignatureSpan">parserlib.util.StringReader.prototype.</span>mark
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mark = function () {
    this._bookmark = {
        cursor: this._cursor,
        line:   this._line,
        col:    this._col
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * https://developer.mozilla.org/en-US/docs/Web/CSS/Value_definition_syntax#Component_value_combinators
 */
function Matcher(matchFunc, toString) {
this.match = function(expression) {
    // Save/restore marks to ensure that failed matches always restore
    // the original location in the expression.
    var result;
    expression.<span class="apidocCodeKeywordSpan">mark</span>();
    result = matchFunc(expression);
    if (result) {
        expression.drop();
    } else {
        expression.restore();
    }
    return result;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.util.StringReader.prototype.peek" id="apidoc.element.parserlib.util.StringReader.prototype.peek">
        function <span class="apidocSignatureSpan">parserlib.util.StringReader.prototype.</span>peek
        <span class="apidocSignatureSpan">(count)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">peek = function (count) {
    var c = null;
    count = typeof count === &#x22;undefined&#x22; ? 1 : count;

    // if we&#x27;re not at the end of the input...
    if (this._cursor &#x3c; this._input.length) {

        // get character and increment cursor and column
        c = this._input.charAt(this._cursor + count - 1);
    }

    return c;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

//try to read character set
this._charset();

this._skipCruft();

//try to read imports - may be more than one
while (tokenStream.<span class="apidocCodeKeywordSpan">peek</span>() === Tokens.IMPORT_SYM) {
    this._import();
    this._skipCruft();
}

//try to read namespaces - may be more than one
while (tokenStream.peek() === Tokens.NAMESPACE_SYM) {
    this._namespace();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.util.StringReader.prototype.read" id="apidoc.element.parserlib.util.StringReader.prototype.read">
        function <span class="apidocSignatureSpan">parserlib.util.StringReader.prototype.</span>read
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function () {
    var c = null;

    // if we&#x27;re not at the end of the input...
    if (this._cursor &#x3c; this._input.length) {

        // if the last character was a newline, increment row count
        // and reset column count
        if (this._input.charAt(this._cursor) === &#x22;\n&#x22;) {
            this._line++;
            this._col=1;
        } else {
            this._col++;
        }

        // get character and increment cursor and column
        c = this._input.charAt(this._cursor++);
    }

    return c;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

        var c,
            reader = this._reader,
            token   = null,
            startLine   = reader.getLine(),
            startCol    = reader.getCol();

        c = reader.<span class="apidocCodeKeywordSpan">read</span>();


        while (c) {
            switch (c) {

/*
 * Potential tokens:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.util.StringReader.prototype.readCount" id="apidoc.element.parserlib.util.StringReader.prototype.readCount">
        function <span class="apidocSignatureSpan">parserlib.util.StringReader.prototype.</span>readCount
        <span class="apidocSignatureSpan">(count)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readCount = function (count) {
    var buffer = &#x22;&#x22;;

    while (count--) {
        buffer += this.read();
    }

    return buffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * @method htmlCommentStartToken
     */
    htmlCommentStartToken: function(first, startLine, startCol) {
var reader      = this._reader,
    text        = first;

reader.mark();
text += reader.<span class="apidocCodeKeywordSpan">readCount</span>(3);

if (text === &#x22;&#x3c;!--&#x22;) {
    return this.createToken(Tokens.CDO, text, startLine, startCol);
} else {
    reader.reset();
    return this.charToken(first, startLine, startCol);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.util.StringReader.prototype.readMatch" id="apidoc.element.parserlib.util.StringReader.prototype.readMatch">
        function <span class="apidocSignatureSpan">parserlib.util.StringReader.prototype.</span>readMatch
        <span class="apidocSignatureSpan">(matcher)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readMatch = function (matcher) {

    var source = this._input.substring(this._cursor),
        value = null;

    // if it&#x27;s a string, just do a straight match
    if (typeof matcher === &#x22;string&#x22;) {
        if (source.slice(0, matcher.length) === matcher) {
            value = this.readCount(matcher.length);
        }
    } else if (matcher instanceof RegExp) {
        if (matcher.test(source)) {
            value = this.readCount(RegExp.lastMatch.length);
        }
    }

    return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/** Simple recursive-descent grammar to build matchers from strings. */
Matcher.parse = function(str) {
var reader, eat, expr, oror, andand, seq, mod, term, result;
reader = new StringReader(str);
eat = function(matcher) {
    var result = reader.<span class="apidocCodeKeywordSpan">readMatch</span>(matcher);
    if (result === null) {
        throw new SyntaxError(
            &#x22;Expected &#x22;+matcher, reader.getLine(), reader.getCol());
    }
    return result;
};
expr = function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.util.StringReader.prototype.readTo" id="apidoc.element.parserlib.util.StringReader.prototype.readTo">
        function <span class="apidocSignatureSpan">parserlib.util.StringReader.prototype.</span>readTo
        <span class="apidocSignatureSpan">(pattern)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readTo = function (pattern) {

    var buffer = &#x22;&#x22;,
        c;

    /*
     * First, buffer must be the same length as the pattern.
     * Then, buffer must end with the pattern or else reach the
     * end of the input.
     */
    while (buffer.length &#x3c; pattern.length || buffer.lastIndexOf(pattern) !== buffer.length - pattern.length) {
        c = this.read();
        if (c) {
            buffer += c;
        } else {
            throw new Error(&#x22;Expected \&#x22;&#x22; + pattern + &#x22;\&#x22; at line &#x22; + this._line  + &#x22;, col &#x22; + this._col + &#x22;.&#x22;);
        }
    }

    return buffer;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        } else {
            tt = Tokens.FUNCTION;
        }
    } else if (reader.peek() === &#x22;:&#x22;) {  //might be an IE function

        //IE-specific functions always being with progid:
        if (ident.toLowerCase() === &#x22;progid&#x22;) {
            ident += reader.<span class="apidocCodeKeywordSpan">readTo</span>(&#x22;(&#x22;);
            tt = Tokens.IE_FUNCTION;
        }
    }

    return this.createToken(tt, ident, startLine, startCol);
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.util.StringReader.prototype.readWhile" id="apidoc.element.parserlib.util.StringReader.prototype.readWhile">
        function <span class="apidocSignatureSpan">parserlib.util.StringReader.prototype.</span>readWhile
        <span class="apidocSignatureSpan">(filter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readWhile = function (filter) {

    var buffer = &#x22;&#x22;,
        c = this.peek();

    while (c !== null &#x26;&#x26; filter(c)) {
        buffer += this.read();
        c = this.peek();
    }

    return buffer;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/*
 * Tests that the entire string can be read..
 */
testReadWhileSimple: function() {
    var testString = &#x22;Hello world!&#x22;,
        reader = new StringReader(testString);

    var result = reader.<span class="apidocCodeKeywordSpan">readWhile</span>(function() {
        return true;
    });

    Assert.areEqual(testString, result);
    Assert.areEqual(1, reader.getLine());
    Assert.areEqual(13, reader.getCol());
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.util.StringReader.prototype.reset" id="apidoc.element.parserlib.util.StringReader.prototype.reset">
        function <span class="apidocSignatureSpan">parserlib.util.StringReader.prototype.</span>reset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reset = function () {
    if (this._bookmark) {
        this._cursor = this._bookmark.cursor;
        this._line = this._bookmark.line;
        this._col = this._bookmark.col;
        delete this._bookmark;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    //if it&#x27;s not valid, use the first character only and reset the reader
    if (tt === Tokens.CHAR || tt === Tokens.UNKNOWN) {
        if (rule.length &#x3e; 1) {
            tt = Tokens.UNKNOWN_SYM;
        } else {
            tt = Tokens.CHAR;
            rule = first;
            reader.<span class="apidocCodeKeywordSpan">reset</span>();
        }
    }

    return this.createToken(tt, rule, startLine, startCol);
},

/**
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.parserlib.util.SyntaxError" id="apidoc.module.parserlib.util.SyntaxError">module parserlib.util.SyntaxError</a></h1>


    <h2>
        <a href="#apidoc.element.parserlib.util.SyntaxError.SyntaxError" id="apidoc.element.parserlib.util.SyntaxError.SyntaxError">
        function <span class="apidocSignatureSpan">parserlib.util.</span>SyntaxError
        <span class="apidocSignatureSpan">(message, line, col)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntaxError(message, line, col) {
    Error.call(this);
    this.name = this.constructor.name;

    /**
     * The column at which the error occurred.
     * @type int
     * @property col
     */
    this.col = col;

    /**
     * The line at which the error occurred.
     * @type int
     * @property line
     */
    this.line = line;

    /**
     * The text representation of the unit.
     * @type String
     * @property text
     */
    this.message = message;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.parserlib.util.SyntaxError.prototype" id="apidoc.module.parserlib.util.SyntaxError.prototype">module parserlib.util.SyntaxError.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.parserlib.util.SyntaxError.prototype.constructor" id="apidoc.element.parserlib.util.SyntaxError.prototype.constructor">
        function <span class="apidocSignatureSpan">parserlib.util.SyntaxError.prototype.</span>constructor
        <span class="apidocSignatureSpan">(message, line, col)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntaxError(message, line, col) {
    Error.call(this);
    this.name = this.constructor.name;

    /**
     * The column at which the error occurred.
     * @type int
     * @property col
     */
    this.col = col;

    /**
     * The line at which the error occurred.
     * @type int
     * @property line
     */
    this.line = line;

    /**
     * The text representation of the unit.
     * @type String
     * @property text
     */
    this.message = message;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.parserlib.util.SyntaxUnit" id="apidoc.module.parserlib.util.SyntaxUnit">module parserlib.util.SyntaxUnit</a></h1>


    <h2>
        <a href="#apidoc.element.parserlib.util.SyntaxUnit.SyntaxUnit" id="apidoc.element.parserlib.util.SyntaxUnit.SyntaxUnit">
        function <span class="apidocSignatureSpan">parserlib.util.</span>SyntaxUnit
        <span class="apidocSignatureSpan">(text, line, col, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntaxUnit(text, line, col, type) {


    /**
     * The column of text on which the unit resides.
     * @type int
     * @property col
     */
    this.col = col;

    /**
     * The line of text on which the unit resides.
     * @type int
     * @property line
     */
    this.line = line;

    /**
     * The text representation of the unit.
     * @type String
     * @property text
     */
    this.text = text;

    /**
     * The type of syntax unit.
     * @type int
     * @property type
     */
    this.type = type;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.util.SyntaxUnit.fromToken" id="apidoc.element.parserlib.util.SyntaxUnit.fromToken">
        function <span class="apidocSignatureSpan">parserlib.util.SyntaxUnit.</span>fromToken
        <span class="apidocSignatureSpan">(token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromToken = function (token) {
    return new SyntaxUnit(token.value, token.startLine, token.startCol);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     */
    var tokenStream = this._tokenStream;

    this._readWhitespace();

    tokenStream.mustMatch(Tokens.IDENT);

    return SyntaxUnit.<span class="apidocCodeKeywordSpan">fromToken</span>(tokenStream.token());
},

//CSS3 Paged Media
_page: function() {
    /*
     * page:
     *    PAGE_SYM S* IDENT? pseudo_page? S*
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.parserlib.util.SyntaxUnit.prototype" id="apidoc.module.parserlib.util.SyntaxUnit.prototype">module parserlib.util.SyntaxUnit.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.parserlib.util.SyntaxUnit.prototype.constructor" id="apidoc.element.parserlib.util.SyntaxUnit.prototype.constructor">
        function <span class="apidocSignatureSpan">parserlib.util.SyntaxUnit.prototype.</span>constructor
        <span class="apidocSignatureSpan">(text, line, col, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntaxUnit(text, line, col, type) {


    /**
     * The column of text on which the unit resides.
     * @type int
     * @property col
     */
    this.col = col;

    /**
     * The line of text on which the unit resides.
     * @type int
     * @property line
     */
    this.line = line;

    /**
     * The text representation of the unit.
     * @type String
     * @property text
     */
    this.text = text;

    /**
     * The type of syntax unit.
     * @type int
     * @property type
     */
    this.type = type;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.util.SyntaxUnit.prototype.toString" id="apidoc.element.parserlib.util.SyntaxUnit.prototype.toString">
        function <span class="apidocSignatureSpan">parserlib.util.SyntaxUnit.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
    return this.text;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        for (i = 0; result &#x26;&#x26; i &#x3c; ms.length; i++) {
            result = ms[i].match(expression);
        }
        return result;
    }, function(prec) {
        var p = Matcher.prec.SEQ;
        var s = ms.map(function(m) {
            return m.<span class="apidocCodeKeywordSpan">toString</span>(p);
        }).join(&#x22; &#x22;);
        if (prec &#x3e; p) {
            s = &#x22;[ &#x22; + s + &#x22; ]&#x22;;
        }
        return s;
    });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.util.SyntaxUnit.prototype.valueOf" id="apidoc.element.parserlib.util.SyntaxUnit.prototype.valueOf">
        function <span class="apidocSignatureSpan">parserlib.util.SyntaxUnit.prototype.</span>valueOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">valueOf = function () {
    return this.toString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Assert.areEqual(1, result.line, &#x22;Line start should be 1&#x22;);
Assert.areEqual(1, result.col, &#x22;Column start should be 1&#x22;);
Assert.areEqual(1, result.parts.length, &#x22;Selector should have three parts.&#x22;);
Assert.isInstanceOf(SelectorPart, result.parts[0], &#x22;First part should be a SelectorPart.&#x22;);
Assert.areEqual(Parser.SELECTOR_PART_TYPE, result.parts[0].type);
Assert.areEqual(&#x22;li&#x22;, result.parts[0].elementName, &#x22;Element name should be &#x27;li&#x27;.&#x22;);
Assert.areEqual(0, result.parts[0].modifiers, &#x22;Element should have zero modifiers.&#x22;);
Assert.areEqual(1, result.specificity.<span class="apidocCodeKeywordSpan">valueOf</span>());
        },

        testSimpleTypeSelectorPlusNamespace: function() {
var parser = new Parser();
var result = parser.parseSelector(&#x22;svg|rect&#x22;);

Assert.isInstanceOf(Selector, result, &#x22;Result should be an instance of Selector.&#x22;);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.parserlib.util.TokenStreamBase" id="apidoc.module.parserlib.util.TokenStreamBase">module parserlib.util.TokenStreamBase</a></h1>


    <h2>
        <a href="#apidoc.element.parserlib.util.TokenStreamBase.TokenStreamBase" id="apidoc.element.parserlib.util.TokenStreamBase.TokenStreamBase">
        function <span class="apidocSignatureSpan">parserlib.util.</span>TokenStreamBase
        <span class="apidocSignatureSpan">(input, tokenData)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TokenStreamBase(input, tokenData) {

    /**
     * The string reader for easy access to the text.
     * @type StringReader
     * @property _reader
     * @private
     */
    this._reader = new StringReader(input ? input.toString() : &#x22;&#x22;);

    /**
     * Token object for the last consumed token.
     * @type Token
     * @property _token
     * @private
     */
    this._token = null;

    /**
     * The array of token information.
     * @type Array
     * @property _tokenData
     * @private
     */
    this._tokenData = tokenData;

    /**
     * Lookahead token buffer.
     * @type Array
     * @property _lt
     * @private
     */
    this._lt = [];

    /**
     * Lookahead token buffer index.
     * @type int
     * @property _ltIndex
     * @private
     */
    this._ltIndex = 0;

    this._ltIndexCache = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.util.TokenStreamBase.createTokenData" id="apidoc.element.parserlib.util.TokenStreamBase.createTokenData">
        function <span class="apidocSignatureSpan">parserlib.util.TokenStreamBase.</span>createTokenData
        <span class="apidocSignatureSpan">(tokens)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createTokenData = function (tokens) {

    var nameMap     = [],
        typeMap     = Object.create(null),
        tokenData     = tokens.concat([]),
        i            = 0,
        len            = tokenData.length+1;

    tokenData.UNKNOWN = -1;
    tokenData.unshift({ name:&#x22;EOF&#x22; });

    for (; i &#x3c; len; i++) {
        nameMap.push(tokenData[i].name);
        tokenData[tokenData[i].name] = i;
        if (tokenData[i].text) {
            typeMap[tokenData[i].text] = i;
        }
    }

    tokenData.name = function(tt) {
        return nameMap[tt];
    };

    tokenData.type = function(c) {
        return typeMap[c];
    };

    return tokenData;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.parserlib.util.TokenStreamBase.prototype" id="apidoc.module.parserlib.util.TokenStreamBase.prototype">module parserlib.util.TokenStreamBase.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.parserlib.util.TokenStreamBase.prototype.LA" id="apidoc.element.parserlib.util.TokenStreamBase.prototype.LA">
        function <span class="apidocSignatureSpan">parserlib.util.TokenStreamBase.prototype.</span>LA
        <span class="apidocSignatureSpan">(index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">LA = function (index) {
    var total = index,
        tt;
    if (index &#x3e; 0) {
        //TODO: Store 5 somewhere
        if (index &#x3e; 5) {
            throw new Error(&#x22;Too much lookahead.&#x22;);
        }

        //get all those tokens
        while (total) {
            tt = this.get();
            total--;
        }

        //unget all those tokens
        while (total &#x3c; index) {
            this.unget();
            total++;
        }
    } else if (index &#x3c; 0) {

        if (this._lt[this._ltIndex+index]) {
            tt = this._lt[this._ltIndex+index].type;
        } else {
            throw new Error(&#x22;Too much lookbehind.&#x22;);
        }

    } else {
        tt = this._token.type;
    }

    return tt;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                 *   : [ IDENT | &#x27;*&#x27; ]? &#x27;|&#x27;
                 *   ;
                 */
                var tokenStream = this._tokenStream,
value       = &#x22;&#x22;;

                //verify that this is a namespace prefix
                if (tokenStream.<span class="apidocCodeKeywordSpan">LA</span>(1) === Tokens.PIPE || tokenStream.LA(2) === Tokens
.PIPE) {

if (tokenStream.match([Tokens.IDENT, Tokens.STAR])) {
    value += tokenStream.token().value;
}

tokenStream.mustMatch(Tokens.PIPE);
value += &#x22;|&#x22;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.util.TokenStreamBase.prototype.LT" id="apidoc.element.parserlib.util.TokenStreamBase.prototype.LT">
        function <span class="apidocSignatureSpan">parserlib.util.TokenStreamBase.prototype.</span>LT
        <span class="apidocSignatureSpan">(index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">LT = function (index) {

    //lookahead first to prime the token buffer
    this.LA(index);

    //now find the token, subtract one because _ltIndex is already at the next index
    return this._lt[this._ltIndex+index-1];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                                tokenStream.get();
                                if (!this.options.strict) {

//fire error event
this.fire({
    type:       &#x22;error&#x22;,
    error:      null,
    message:    &#x22;Unknown @ rule: &#x22; + tokenStream.<span class="apidocCodeKeywordSpan">LT</span>(0).value + &#x22;.&#x22
;,
    line:       tokenStream.LT(0).startLine,
    col:        tokenStream.LT(0).startCol
});

//skip braces
count=0;
while (tokenStream.advance([Tokens.LBRACE, Tokens.RBRACE]) === Tokens.LBRACE) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.util.TokenStreamBase.prototype.advance" id="apidoc.element.parserlib.util.TokenStreamBase.prototype.advance">
        function <span class="apidocSignatureSpan">parserlib.util.TokenStreamBase.prototype.</span>advance
        <span class="apidocSignatureSpan">(tokenTypes, channel)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">advance = function (tokenTypes, channel) {

    while (this.LA(0) !== 0 &#x26;&#x26; !this.match(tokenTypes, channel)) {
        this.get();
    }

    return this.LA(0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    message:    &#x22;Unknown @ rule: &#x22; + tokenStream.LT(0).value + &#x22;.&#x22;,
    line:       tokenStream.LT(0).startLine,
    col:        tokenStream.LT(0).startCol
});

//skip braces
count=0;
while (tokenStream.<span class="apidocCodeKeywordSpan">advance</span>([Tokens.LBRACE, Tokens.RBRACE]) === Tokens.LBRACE) {
    count++;    //keep track of nesting depth
}

while (count) {
    tokenStream.advance([Tokens.RBRACE]);
    count--;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.util.TokenStreamBase.prototype.constructor" id="apidoc.element.parserlib.util.TokenStreamBase.prototype.constructor">
        function <span class="apidocSignatureSpan">parserlib.util.TokenStreamBase.prototype.</span>constructor
        <span class="apidocSignatureSpan">(input, tokenData)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TokenStreamBase(input, tokenData) {

    /**
     * The string reader for easy access to the text.
     * @type StringReader
     * @property _reader
     * @private
     */
    this._reader = new StringReader(input ? input.toString() : &#x22;&#x22;);

    /**
     * Token object for the last consumed token.
     * @type Token
     * @property _token
     * @private
     */
    this._token = null;

    /**
     * The array of token information.
     * @type Array
     * @property _tokenData
     * @private
     */
    this._tokenData = tokenData;

    /**
     * Lookahead token buffer.
     * @type Array
     * @property _lt
     * @private
     */
    this._lt = [];

    /**
     * Lookahead token buffer index.
     * @type int
     * @property _ltIndex
     * @private
     */
    this._ltIndex = 0;

    this._ltIndexCache = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.util.TokenStreamBase.prototype.get" id="apidoc.element.parserlib.util.TokenStreamBase.prototype.get">
        function <span class="apidocSignatureSpan">parserlib.util.TokenStreamBase.prototype.</span>get
        <span class="apidocSignatureSpan">(channel)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (channel) {

    var tokenInfo   = this._tokenData,
        i           =0,
        token,
        info;

    //check the lookahead buffer first
    if (this._lt.length &#x26;&#x26; this._ltIndex &#x3e;= 0 &#x26;&#x26; this._ltIndex &#x3c; this._lt.length) {

        i++;
        this._token = this._lt[this._ltIndex++];
        info = tokenInfo[this._token.type];

        //obey channels logic
        while ((info.channel !== undefined &#x26;&#x26; channel !== info.channel) &#x26;&#x26;
                this._ltIndex &#x3c; this._lt.length) {
            this._token = this._lt[this._ltIndex++];
            info = tokenInfo[this._token.type];
            i++;
        }

        //here be dragons
        if ((info.channel === undefined || channel === info.channel) &#x26;&#x26;
                this._ltIndex &#x3c;= this._lt.length) {
            this._ltIndexCache.push(i);
            return this._token.type;
        }
    }

    //call token retriever method
    token = this._getToken();

    //if it should be hidden, don&#x27;t save a token
    if (token.type &#x3e; -1 &#x26;&#x26; !tokenInfo[token.type].hide) {

        //apply token channel
        token.channel = tokenInfo[token.type].channel;

        //save for later
        this._token = token;
        this._lt.push(token);

        //save space that will be moved (must be done before array is truncated)
        this._ltIndexCache.push(this._lt.length - this._ltIndex + i);

        //keep the buffer under 5 items
        if (this._lt.length &#x3e; 5) {
            this._lt.shift();
        }

        //also keep the shift buffer under 5 items
        if (this._ltIndexCache.length &#x3e; 5) {
            this._ltIndexCache.shift();
        }

        //update lookahead index
        this._ltIndex = this._lt.length;
    }

    /*
     * Skip to the next token if:
     * 1. The token type is marked as hidden.
     * 2. The token type has a channel specified and it isn&#x27;t the current channel.
     */
    info = tokenInfo[token.type];
    if (info &#x26;&#x26;
            (info.hide ||
            (info.channel !== undefined &#x26;&#x26; channel !== info.channel))) {
        return this.get(channel);
    } else {
        //return just the type
        return token.type;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                                this._skipCruft();
                                break;
                            case Tokens.SUPPORTS_SYM:
                                this._supports();
                                this._skipCruft();
                                break;
                            case Tokens.UNKNOWN_SYM:  //unknown @ rule
                                tokenStream.<span class="apidocCodeKeywordSpan">get</span>();
                                if (!this.options.strict) {

//fire error event
this.fire({
    type:       &#x22;error&#x22;,
    error:      null,
    message:    &#x22;Unknown @ rule: &#x22; + tokenStream.LT(0).value + &#x22;.&#x22;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.util.TokenStreamBase.prototype.match" id="apidoc.element.parserlib.util.TokenStreamBase.prototype.match">
        function <span class="apidocSignatureSpan">parserlib.util.TokenStreamBase.prototype.</span>match
        <span class="apidocSignatureSpan">(tokenTypes, channel)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">match = function (tokenTypes, channel) {

    //always convert to an array, makes things easier
    if (!(tokenTypes instanceof Array)) {
        tokenTypes = [tokenTypes];
    }

    var tt  = this.get(channel),
        i   = 0,
        len = tokenTypes.length;

    while (i &#x3c; len) {
        if (tt === tokenTypes[i++]) {
            return true;
        }
    }

    //no match found, put the token back
    this.unget();
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var ms = Array.prototype.slice.call(arguments).map(Matcher.cast);
if (ms.length === 1) {
    return ms[0];
}
return new Matcher(function(expression) {
    var i, result = true;
    for (i = 0; result &#x26;&#x26; i &#x3c; ms.length; i++) {
        result = ms[i].<span class="apidocCodeKeywordSpan">match</span>(expression);
    }
    return result;
}, function(prec) {
    var p = Matcher.prec.SEQ;
    var s = ms.map(function(m) {
        return m.toString(p);
    }).join(&#x22; &#x22;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.util.TokenStreamBase.prototype.mustMatch" id="apidoc.element.parserlib.util.TokenStreamBase.prototype.mustMatch">
        function <span class="apidocSignatureSpan">parserlib.util.TokenStreamBase.prototype.</span>mustMatch
        <span class="apidocSignatureSpan">(tokenTypes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mustMatch = function (tokenTypes) {

    var token;

    //always convert to an array, makes things easier
    if (!(tokenTypes instanceof Array)) {
        tokenTypes = [tokenTypes];
    }

    if (!this.match.apply(this, arguments)) {
        token = this.LT(1);
        throw new SyntaxError(&#x22;Expected &#x22; + this._tokenData[tokenTypes[0]].name +
            &#x22; at line &#x22; + token.startLine + &#x22;, col &#x22; + token.startCol + &#x22;.&#x22;, token.startLine, token.startCol);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
col;

                if (tokenStream.match(Tokens.CHARSET_SYM)) {
line = tokenStream.token().startLine;
col = tokenStream.token().startCol;

this._readWhitespace();
tokenStream.<span class="apidocCodeKeywordSpan">mustMatch</span>(Tokens.STRING);

token = tokenStream.token();
charset = token.value;

this._readWhitespace();
tokenStream.mustMatch(Tokens.SEMICOLON);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.util.TokenStreamBase.prototype.peek" id="apidoc.element.parserlib.util.TokenStreamBase.prototype.peek">
        function <span class="apidocSignatureSpan">parserlib.util.TokenStreamBase.prototype.</span>peek
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">peek = function () {
    return this.LA(1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

//try to read character set
this._charset();

this._skipCruft();

//try to read imports - may be more than one
while (tokenStream.<span class="apidocCodeKeywordSpan">peek</span>() === Tokens.IMPORT_SYM) {
    this._import();
    this._skipCruft();
}

//try to read namespaces - may be more than one
while (tokenStream.peek() === Tokens.NAMESPACE_SYM) {
    this._namespace();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.util.TokenStreamBase.prototype.token" id="apidoc.element.parserlib.util.TokenStreamBase.prototype.token">
        function <span class="apidocSignatureSpan">parserlib.util.TokenStreamBase.prototype.</span>token
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">token = function () {
    return this._token;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                        throw new SyntaxError(&#x22;@import not allowed here.&#x22;, token.startLine, token.startCol);
                    case Tokens.NAMESPACE_SYM:
                        token = tokenStream.LT(1);
                        this._namespace(false);
                        throw new SyntaxError(&#x22;@namespace not allowed here.&#x22;, token.startLine, token.startCol);
                    default:
                        tokenStream.get();  //get the last token
                        this._unexpectedToken(tokenStream.<span class="apidocCodeKeywordSpan">token</span>());
                }

            }
    }
} catch (ex) {
    if (ex instanceof SyntaxError &#x26;&#x26; !this.options.strict) {
        this.fire({
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.util.TokenStreamBase.prototype.tokenName" id="apidoc.element.parserlib.util.TokenStreamBase.prototype.tokenName">
        function <span class="apidocSignatureSpan">parserlib.util.TokenStreamBase.prototype.</span>tokenName
        <span class="apidocSignatureSpan">(tokenType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tokenName = function (tokenType) {
    if (tokenType &#x3c; 0 || tokenType &#x3e; this._tokenData.length) {
        return &#x22;UNKNOWN_TOKEN&#x22;;
    } else {
        return this._tokenData[tokenType].name;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.util.TokenStreamBase.prototype.tokenType" id="apidoc.element.parserlib.util.TokenStreamBase.prototype.tokenType">
        function <span class="apidocSignatureSpan">parserlib.util.TokenStreamBase.prototype.</span>tokenType
        <span class="apidocSignatureSpan">(tokenName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tokenType = function (tokenName) {
    return this._tokenData[tokenName] || -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parserlib.util.TokenStreamBase.prototype.unget" id="apidoc.element.parserlib.util.TokenStreamBase.prototype.unget">
        function <span class="apidocSignatureSpan">parserlib.util.TokenStreamBase.prototype.</span>unget
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unget = function () {
    //if (this._ltIndex &#x3e; -1) {
    if (this._ltIndexCache.length) {
        this._ltIndex -= this._ltIndexCache.pop();//--;
        this._token = this._lt[this._ltIndex - 1];
    } else {
        throw new Error(&#x22;Too much lookahead.&#x22;);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                if (tokenStream.match(Tokens.IDENT)) {
ident = tokenStream.token().value.toLowerCase();

if (ident === &#x22;not&#x22;) {
    tokenStream.mustMatch(Tokens.S);
    this._supports_condition_in_parens();
} else {
    tokenStream.<span class="apidocCodeKeywordSpan">unget</span>();
}
                } else {
this._supports_condition_in_parens();
this._readWhitespace();

while (tokenStream.peek() === Tokens.IDENT) {
    ident = tokenStream.LT(1).value.toLowerCase();
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
